declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextReplacementConfig$Condition, $TextReplacementConfig$Condition$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Condition"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$MatchResult, $MatchResult$Type} from "packages/java/util/regex/$MatchResult"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"

export interface $TextReplacementConfig$Builder extends $AbstractBuilder<($TextReplacementConfig)>, $Buildable$Builder<($TextReplacementConfig)> {

 "matchLiteral"(literal: string): $TextReplacementConfig$Builder
 "replacement"(replacement: string): $TextReplacementConfig$Builder
 "replacement"(replacement: $ComponentLike$Type): $TextReplacementConfig$Builder
 "replacement"(replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $TextReplacementConfig$Builder
 "replacement"(replacement: $BiFunction$Type<($MatchResult$Type), ($TextComponent$Builder$Type), ($ComponentLike$Type)>): $TextReplacementConfig$Builder
 "match"(pattern: string): $TextReplacementConfig$Builder
 "match"(pattern: $Pattern$Type): $TextReplacementConfig$Builder
 "condition"(condition: $IntFunction2$Type<($PatternReplacementResult$Type)>): $TextReplacementConfig$Builder
 "condition"(condition: $TextReplacementConfig$Condition$Type): $TextReplacementConfig$Builder
 "once"(): $TextReplacementConfig$Builder
 "times"(times: integer): $TextReplacementConfig$Builder
 "build"(): $TextReplacementConfig
}

export namespace $TextReplacementConfig$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $TextReplacementConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementConfig$Builder$Type = ($TextReplacementConfig$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementConfig$Builder_ = $TextReplacementConfig$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$MergeMode" {
import {$StackTraceNode, $StackTraceNode$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode"
import {$MethodDisambiguator, $MethodDisambiguator$Type} from "packages/me/lucko/spark/common/util/$MethodDisambiguator"

export class $MergeMode {


public static "sameMethod"(arg0: $MethodDisambiguator$Type): $MergeMode
public static "separateParentCalls"(arg0: $MethodDisambiguator$Type): $MergeMode
public "separateParentCalls"(): boolean
public "shouldMerge"(arg0: $StackTraceNode$Type, arg1: $StackTraceNode$Type): boolean
public "getMethodDisambiguator"(): $MethodDisambiguator
get "methodDisambiguator"(): $MethodDisambiguator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MergeMode$Type = ($MergeMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MergeMode_ = $MergeMode$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Value" {
import {$Value$Builder, $Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Value$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ListValue, $ListValue$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue"
import {$ValueOrBuilder, $ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ValueOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$NullValue, $NullValue$Type} from "packages/me/lucko/spark/lib/protobuf/$NullValue"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Struct, $Struct$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Value$KindCase, $Value$KindCase$Type} from "packages/me/lucko/spark/lib/protobuf/$Value$KindCase"

export class $Value extends $GeneratedMessageLite<($Value), ($Value$Builder)> implements $ValueOrBuilder {
static readonly "NULL_VALUE_FIELD_NUMBER": integer
static readonly "NUMBER_VALUE_FIELD_NUMBER": integer
static readonly "STRING_VALUE_FIELD_NUMBER": integer
static readonly "BOOL_VALUE_FIELD_NUMBER": integer
static readonly "STRUCT_VALUE_FIELD_NUMBER": integer
static readonly "LIST_VALUE_FIELD_NUMBER": integer


public "getStringValueBytes"(): $ByteString
public static "parser"(): $Parser<($Value)>
public static "newBuilder"(arg0: $Value$Type): $Value$Builder
public static "newBuilder"(): $Value$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Value
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Value
public static "getDefaultInstance"(): $Value
public "hasStringValue"(): boolean
public "getStringValue"(): string
public "getNumberValue"(): double
public "hasStructValue"(): boolean
public "getNullValueValue"(): integer
public "hasNumberValue"(): boolean
public "getKindCase"(): $Value$KindCase
public "getStructValue"(): $Struct
public "hasBoolValue"(): boolean
public "hasListValue"(): boolean
public "getBoolValue"(): boolean
public "getNullValue"(): $NullValue
public "getListValue"(): $ListValue
public "hasNullValue"(): boolean
public static "parseFrom"(arg0: (byte)[]): $Value
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Value
public static "parseFrom"(arg0: $ByteString$Type): $Value
public static "parseFrom"(arg0: $ByteBuffer$Type): $Value
public static "parseFrom"(arg0: $CodedInputStream$Type): $Value
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Value
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Value
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Value
public static "parseFrom"(arg0: $InputStream$Type): $Value
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Value
get "stringValueBytes"(): $ByteString
get "defaultInstance"(): $Value
get "stringValue"(): string
get "numberValue"(): double
get "nullValueValue"(): integer
get "kindCase"(): $Value$KindCase
get "structValue"(): $Struct
get "boolValue"(): boolean
get "nullValue"(): $NullValue
get "listValue"(): $ListValue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Value$Type = ($Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Value_ = $Value$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MemoryOrBuilder" {
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$MemoryOrBuilder extends $MessageLiteOrBuilder {

 "hasHeap"(): boolean
 "getHeap"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$MemoryOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$MemoryOrBuilder$Type = ($SparkProtos$PlatformStatistics$MemoryOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$MemoryOrBuilder_ = $SparkProtos$PlatformStatistics$MemoryOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$FramedataImpl1" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $FramedataImpl1 implements $Framedata {

constructor(arg0: $Opcode$Type)

public static "get"(arg0: $Opcode$Type): $FramedataImpl1
public "equals"(arg0: any): boolean
public "toString"(): string
public "append"(arg0: $Framedata$Type): void
public "hashCode"(): integer
public "isValid"(): void
public "getOpcode"(): $Opcode
public "setFin"(arg0: boolean): void
public "setPayload"(arg0: $ByteBuffer$Type): void
public "setTransferemasked"(arg0: boolean): void
public "setRSV1"(arg0: boolean): void
public "setRSV3"(arg0: boolean): void
public "setRSV2"(arg0: boolean): void
public "isRSV2"(): boolean
public "isFin"(): boolean
public "isRSV3"(): boolean
public "isRSV1"(): boolean
public "getTransfereMasked"(): boolean
public "getPayloadData"(): $ByteBuffer
get "valid"(): boolean
get "opcode"(): $Opcode
set "fin"(value: boolean)
set "payload"(value: $ByteBuffer$Type)
set "transferemasked"(value: boolean)
set "rSV1"(value: boolean)
set "rSV3"(value: boolean)
set "rSV2"(value: boolean)
get "rSV2"(): boolean
get "fin"(): boolean
get "rSV3"(): boolean
get "rSV1"(): boolean
get "transfereMasked"(): boolean
get "payloadData"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FramedataImpl1$Type = ($FramedataImpl1);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FramedataImpl1_ = $FramedataImpl1$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValuesOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$RollingAverageValuesOrBuilder extends $MessageLiteOrBuilder {

 "getMin"(): double
 "getMax"(): double
 "getMean"(): double
 "getMedian"(): double
 "getPercentile95"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$RollingAverageValuesOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$RollingAverageValuesOrBuilder$Type = ($SparkProtos$RollingAverageValuesOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$RollingAverageValuesOrBuilder_ = $SparkProtos$RollingAverageValuesOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$TickReporter$Callback" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $TickReporter$Callback {

 "onTick"(arg0: double): void

(arg0: double): void
}

export namespace $TickReporter$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickReporter$Callback$Type = ($TickReporter$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickReporter$Callback_ = $TickReporter$Callback$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/enums/$HandshakeState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HandshakeState extends $Enum<($HandshakeState)> {
static readonly "MATCHED": $HandshakeState
static readonly "NOT_MATCHED": $HandshakeState


public static "values"(): ($HandshakeState)[]
public static "valueOf"(arg0: string): $HandshakeState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeState$Type = (("not_matched") | ("matched")) | ($HandshakeState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeState_ = $HandshakeState$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectorStatistics" {
import {$GarbageCollectorMXBean, $GarbageCollectorMXBean$Type} from "packages/java/lang/management/$GarbageCollectorMXBean"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $GarbageCollectorStatistics {
static readonly "ZERO": $GarbageCollectorStatistics

constructor(arg0: long, arg1: long)
constructor(arg0: $GarbageCollectorMXBean$Type)

public "subtract"(arg0: $GarbageCollectorStatistics$Type): $GarbageCollectorStatistics
public static "pollStats"(): $Map<(string), ($GarbageCollectorStatistics)>
public "getCollectionCount"(): long
public "getCollectionTime"(): long
public static "pollStatsSubtractInitial"(arg0: $Map$Type<(string), ($GarbageCollectorStatistics$Type)>): $Map<(string), ($GarbageCollectorStatistics)>
public "getAverageCollectionTime"(): double
public "getAverageCollectionFrequency"(arg0: long): long
get "collectionCount"(): long
get "collectionTime"(): long
get "averageCollectionTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GarbageCollectorStatistics$Type = ($GarbageCollectorStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GarbageCollectorStatistics_ = $GarbageCollectorStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$TypeProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $TypeProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeProto$Type = ($TypeProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeProto_ = $TypeProto$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeSparkMod" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$FMLClientSetupEvent, $FMLClientSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent"
import {$ServerAboutToStartEvent, $ServerAboutToStartEvent$Type} from "packages/net/minecraftforge/event/server/$ServerAboutToStartEvent"
import {$FMLCommonSetupEvent, $FMLCommonSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLCommonSetupEvent"

export class $ForgeSparkMod {

constructor()

public "setup"(arg0: $FMLCommonSetupEvent$Type): void
public "getVersion"(): string
public "clientInit"(arg0: $FMLClientSetupEvent$Type): void
public "serverInit"(arg0: $ServerAboutToStartEvent$Type): void
public "getConfigDirectory"(): $Path
set "up"(value: $FMLCommonSetupEvent$Type)
get "version"(): string
get "configDirectory"(): $Path
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSparkMod$Type = ($ForgeSparkMod);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSparkMod_ = $ForgeSparkMod$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder$CharacterAndStyle" {
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"

export interface $Pagination$Builder$CharacterAndStyle {

 "style"(style: $Style$Type): $Pagination$Builder$CharacterAndStyle
 "character"(character: character): $Pagination$Builder$CharacterAndStyle
}

export namespace $Pagination$Builder$CharacterAndStyle {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$Builder$CharacterAndStyle$Type = ($Pagination$Builder$CharacterAndStyle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination$Builder$CharacterAndStyle_ = $Pagination$Builder$CharacterAndStyle$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeClassSourceLookup" {
import {$ClassSourceLookup$MethodCallByLine, $ClassSourceLookup$MethodCallByLine$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCallByLine"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$ClassSourceLookup$MethodCall, $ClassSourceLookup$MethodCall$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCall"
import {$ClassSourceLookup$Visitor, $ClassSourceLookup$Visitor$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$Visitor"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ClassSourceLookup, $ClassSourceLookup$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup"

export class $ForgeClassSourceLookup implements $ClassSourceLookup {

constructor()

public "identify"(arg0: $Class$Type<(any)>): string
public static "create"(arg0: $SparkPlatform$Type): $ClassSourceLookup
public "identify"(arg0: $ClassSourceLookup$MethodCall$Type): string
public "identify"(arg0: $ClassSourceLookup$MethodCallByLine$Type): string
public static "createVisitor"(arg0: $ClassSourceLookup$Type): $ClassSourceLookup$Visitor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeClassSourceLookup$Type = ($ForgeClassSourceLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeClassSourceLookup_ = $ForgeClassSourceLookup$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$AbstractWebSocket" {
import {$WebSocketAdapter, $WebSocketAdapter$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketAdapter"

export class $AbstractWebSocket extends $WebSocketAdapter {

constructor()

public "setTcpNoDelay"(arg0: boolean): void
public "isTcpNoDelay"(): boolean
public "getConnectionLostTimeout"(): integer
public "setConnectionLostTimeout"(arg0: integer): void
public "isReuseAddr"(): boolean
public "setReuseAddr"(arg0: boolean): void
set "tcpNoDelay"(value: boolean)
get "tcpNoDelay"(): boolean
get "connectionLostTimeout"(): integer
set "connectionLostTimeout"(value: integer)
get "reuseAddr"(): boolean
set "reuseAddr"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractWebSocket$Type = ($AbstractWebSocket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractWebSocket_ = $AbstractWebSocket$Type;
}}
declare module "packages/me/lucko/spark/common/command/modules/$HealthModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"

export class $HealthModule implements $CommandModule {

constructor()

public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HealthModule$Type = ($HealthModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HealthModule_ = $HealthModule$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapFieldSchemas" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MapFieldSchemas {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapFieldSchemas$Type = ($MapFieldSchemas);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapFieldSchemas_ = $MapFieldSchemas$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Mixin" {
import {$Mixin$Builder, $Mixin$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MixinOrBuilder, $MixinOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MixinOrBuilder"

export class $Mixin extends $GeneratedMessageLite<($Mixin), ($Mixin$Builder)> implements $MixinOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "ROOT_FIELD_NUMBER": integer


public "getName"(): string
public "getRoot"(): string
public static "parser"(): $Parser<($Mixin)>
public static "newBuilder"(arg0: $Mixin$Type): $Mixin$Builder
public static "newBuilder"(): $Mixin$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Mixin
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Mixin
public static "getDefaultInstance"(): $Mixin
public "getNameBytes"(): $ByteString
public static "parseFrom"(arg0: $ByteBuffer$Type): $Mixin
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Mixin
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Mixin
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Mixin
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Mixin
public static "parseFrom"(arg0: $CodedInputStream$Type): $Mixin
public static "parseFrom"(arg0: $InputStream$Type): $Mixin
public static "parseFrom"(arg0: $ByteString$Type): $Mixin
public static "parseFrom"(arg0: (byte)[]): $Mixin
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Mixin
public "getRootBytes"(): $ByteString
get "name"(): string
get "root"(): string
get "defaultInstance"(): $Mixin
get "nameBytes"(): $ByteString
get "rootBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Mixin$Type = ($Mixin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Mixin_ = $Mixin$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EmptyOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $EmptyOrBuilder extends $MessageLiteOrBuilder {

 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $EmptyOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyOrBuilder$Type = ($EmptyOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyOrBuilder_ = $EmptyOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/identity/$NilIdentity" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $NilIdentity implements $Identity {


public "equals"(that: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "uuid"(): $UUID
public static "identity"(uuid: $UUID$Type): $Identity
public "examinableProperties"(): $Stream<(any)>
public static "nil"(): $Identity
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NilIdentity$Type = ($NilIdentity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NilIdentity_ = $NilIdentity$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Writer" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Writer$FieldOrder, $Writer$FieldOrder$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer$FieldOrder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Writer {

 "writeMessageSetItem"(arg0: integer, arg1: any): void
 "writeBytes"(arg0: integer, arg1: $ByteString$Type): void
 "writeFloat"(arg0: integer, arg1: float): void
 "writeDouble"(arg0: integer, arg1: double): void
 "writeString"(arg0: integer, arg1: string): void
 "writeSInt64"(arg0: integer, arg1: long): void
 "writeMessage"(arg0: integer, arg1: any): void
 "writeMessage"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
 "writeUInt64"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "writeStartGroup"(arg0: integer): void
 "writeInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "writeEndGroup"(arg0: integer): void
 "writeInt64"(arg0: integer, arg1: long): void
 "writeFixed32"(arg0: integer, arg1: integer): void
 "writeUInt32"(arg0: integer, arg1: integer): void
 "writeSFixed32"(arg0: integer, arg1: integer): void
 "writeSFixed64"(arg0: integer, arg1: long): void
 "writeFixed64"(arg0: integer, arg1: long): void
 "writeSInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "writeGroup"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
 "writeGroup"(arg0: integer, arg1: any): void
 "writeBool"(arg0: integer, arg1: boolean): void
 "writeUInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
 "writeFloatList"(arg0: integer, arg1: $List$Type<(float)>, arg2: boolean): void
 "writeDoubleList"(arg0: integer, arg1: $List$Type<(double)>, arg2: boolean): void
 "writeUInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeSFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
 "writeBoolList"(arg0: integer, arg1: $List$Type<(boolean)>, arg2: boolean): void
/**
 * 
 * @deprecated
 */
 "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
 "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>): void
 "writeSFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
 "writeSInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeBytesList"(arg0: integer, arg1: $List$Type<($ByteString$Type)>): void
 "writeStringList"(arg0: integer, arg1: $List$Type<(string)>): void
 "writeInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>): void
 "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
 "writeSInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
 "writeInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
 "writeEnumList"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
 "writeEnum"(arg0: integer, arg1: integer): void
 "fieldOrder"(): $Writer$FieldOrder
 "writeMap"<K, V>(arg0: integer, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $Map$Type<(K), (V)>): void
}

export namespace $Writer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Writer$Type = ($Writer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Writer_ = $Writer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapFieldLite" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$LinkedHashMap, $LinkedHashMap$Type} from "packages/java/util/$LinkedHashMap"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapFieldLite<K, V> extends $LinkedHashMap<(K), (V)> {


public "remove"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "put"(arg0: $Map$Entry$Type<(K), (V)>): V
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clear"(): void
public "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "makeImmutable"(): void
public "mutableCopy"(): $MapFieldLite<(K), (V)>
public static "emptyMapField"<K, V>(): $MapFieldLite<(K), (V)>
public "mergeFrom"(arg0: $MapFieldLite$Type<(K), (V)>): void
public "isMutable"(): boolean
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "size"(): integer
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
get "mutable"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapFieldLite$Type<K, V> = ($MapFieldLite<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapFieldLite_<K, V> = $MapFieldLite$Type<(K), (V)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/$ExaminableProperty" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"

export class $ExaminableProperty {


public "name"(): string
public "toString"(): string
public static "of"(name: string, value: (float)[]): $ExaminableProperty
public static "of"(name: string, value: integer): $ExaminableProperty
public static "of"(name: string, value: (integer)[]): $ExaminableProperty
public static "of"(name: string, value: (double)[]): $ExaminableProperty
public static "of"(name: string, value: float): $ExaminableProperty
public static "of"(name: string, value: (character)[]): $ExaminableProperty
public static "of"(name: string, value: (short)[]): $ExaminableProperty
public static "of"(name: string, value: short): $ExaminableProperty
public static "of"(name: string, value: (long)[]): $ExaminableProperty
public static "of"(name: string, value: long): $ExaminableProperty
public static "of"(name: string, value: (boolean)[]): $ExaminableProperty
public static "of"(name: string, value: boolean): $ExaminableProperty
public static "of"(name: string, value: string): $ExaminableProperty
public static "of"(name: string, value: any): $ExaminableProperty
public static "of"(name: string, value: double): $ExaminableProperty
public static "of"(name: string, value: character): $ExaminableProperty
public static "of"(name: string, value: (byte)[]): $ExaminableProperty
public static "of"(name: string, value: byte): $ExaminableProperty
public "examine"<R>(examiner: $Examiner$Type<(any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExaminableProperty$Type = ($ExaminableProperty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExaminableProperty_ = $ExaminableProperty$Type;
}}
declare module "packages/me/lucko/spark/common/util/$IndexedListBuilder" {
import {$List, $List$Type} from "packages/java/util/$List"

export class $IndexedListBuilder<T> {

constructor()

public "add"(arg0: T): integer
public "build"(): $List<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexedListBuilder$Type<T> = ($IndexedListBuilder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexedListBuilder_<T> = $IndexedListBuilder$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$NBTComponentImpl, $NBTComponentImpl$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentImpl"

export class $StorageNBTComponentImpl extends $NBTComponentImpl<($StorageNBTComponent), ($StorageNBTComponent$Builder)> implements $StorageNBTComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "separator"(): $Component
public "style"(style: $Style$Type): $StorageNBTComponent
public "storage"(): $Key
public "storage"(storage: $Key$Type): $StorageNBTComponent
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $StorageNBTComponent
public "append"(like: $ComponentLike$Type): $StorageNBTComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $StorageNBTComponent
public "color"(color: $TextColor$Type): $StorageNBTComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $StorageNBTComponent
public "style"(style: $Style$Builder$Type): $StorageNBTComponent
public "mergeStyle"(that: $Component$Type): $StorageNBTComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $StorageNBTComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $StorageNBTComponent
public "colorIfAbsent"(color: $TextColor$Type): $StorageNBTComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $StorageNBTComponent
public "clickEvent"(event: $ClickEvent$Type): $StorageNBTComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $StorageNBTComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $StorageNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StorageNBTComponentImpl$Type = ($StorageNBTComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StorageNBTComponentImpl_ = $StorageNBTComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk$Builder" {
import {$SparkProtos$SystemStatistics$Disk, $SparkProtos$SystemStatistics$Disk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$DiskOrBuilder, $SparkProtos$SystemStatistics$DiskOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$DiskOrBuilder"

export class $SparkProtos$SystemStatistics$Disk$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Disk), ($SparkProtos$SystemStatistics$Disk$Builder)> implements $SparkProtos$SystemStatistics$DiskOrBuilder {


public "getTotal"(): long
public "clearTotal"(): $SparkProtos$SystemStatistics$Disk$Builder
public "clearUsed"(): $SparkProtos$SystemStatistics$Disk$Builder
public "getUsed"(): long
public "setUsed"(arg0: long): $SparkProtos$SystemStatistics$Disk$Builder
public "setTotal"(arg0: long): $SparkProtos$SystemStatistics$Disk$Builder
get "total"(): long
get "used"(): long
set "used"(value: long)
set "total"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Disk$Builder$Type = ($SparkProtos$SystemStatistics$Disk$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Disk$Builder_ = $SparkProtos$SystemStatistics$Disk$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft_6455" {
import {$HandshakeBuilder, $HandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder"
import {$IExtension, $IExtension$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$IExtension"
import {$WebSocketImpl, $WebSocketImpl$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$HandshakeState, $HandshakeState$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$HandshakeState"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$CloseHandshakeType, $CloseHandshakeType$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$CloseHandshakeType"
import {$ClientHandshakeBuilder, $ClientHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshakeBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ServerHandshakeBuilder, $ServerHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder"
import {$IProtocol, $IProtocol$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol"

export class $Draft_6455 extends $Draft {

constructor(arg0: $IExtension$Type)
constructor(arg0: $List$Type<($IExtension$Type)>)
constructor()
constructor(arg0: $List$Type<($IExtension$Type)>, arg1: $List$Type<($IProtocol$Type)>, arg2: integer)
constructor(arg0: $List$Type<($IExtension$Type)>, arg1: $List$Type<($IProtocol$Type)>)
constructor(arg0: $List$Type<($IExtension$Type)>, arg1: integer)

public "acceptHandshakeAsClient"(arg0: $ClientHandshake$Type, arg1: $ServerHandshake$Type): $HandshakeState
public "acceptHandshakeAsServer"(arg0: $ClientHandshake$Type): $HandshakeState
public "getCloseHandshakeType"(): $CloseHandshakeType
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "reset"(): void
public "getProtocol"(): $IProtocol
public "getExtension"(): $IExtension
public "processFrame"(arg0: $WebSocketImpl$Type, arg1: $Framedata$Type): void
public "copyInstance"(): $Draft
public "postProcessHandshakeResponseAsServer"(arg0: $ClientHandshake$Type, arg1: $ServerHandshakeBuilder$Type): $HandshakeBuilder
public "postProcessHandshakeRequestAsClient"(arg0: $ClientHandshakeBuilder$Type): $ClientHandshakeBuilder
public "createBinaryFrame"(arg0: $Framedata$Type): $ByteBuffer
public "createFrames"(arg0: string, arg1: boolean): $List<($Framedata)>
public "createFrames"(arg0: $ByteBuffer$Type, arg1: boolean): $List<($Framedata)>
public "translateFrame"(arg0: $ByteBuffer$Type): $List<($Framedata)>
public "getKnownExtensions"(): $List<($IExtension)>
public "getMaxFrameSize"(): integer
public "getKnownProtocols"(): $List<($IProtocol)>
get "closeHandshakeType"(): $CloseHandshakeType
get "protocol"(): $IProtocol
get "extension"(): $IExtension
get "knownExtensions"(): $List<($IExtension)>
get "maxFrameSize"(): integer
get "knownProtocols"(): $List<($IProtocol)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Draft_6455$Type = ($Draft_6455);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Draft_6455_ = $Draft_6455$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BufferAllocator" {
import {$AllocatedBuffer, $AllocatedBuffer$Type} from "packages/me/lucko/spark/lib/protobuf/$AllocatedBuffer"

export class $BufferAllocator {


public static "unpooled"(): $BufferAllocator
public "allocateHeapBuffer"(arg0: integer): $AllocatedBuffer
public "allocateDirectBuffer"(arg0: integer): $AllocatedBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BufferAllocator$Type = ($BufferAllocator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BufferAllocator_ = $BufferAllocator$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Flag" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BossBar$Flag extends $Enum<($BossBar$Flag)> {
static readonly "DARKEN_SCREEN": $BossBar$Flag
static readonly "PLAY_BOSS_MUSIC": $BossBar$Flag
static readonly "CREATE_WORLD_FOG": $BossBar$Flag
static readonly "NAMES": $Index<(string), ($BossBar$Flag)>


public static "values"(): ($BossBar$Flag)[]
public static "valueOf"(name: string): $BossBar$Flag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBar$Flag$Type = (("darken_screen") | ("play_boss_music") | ("create_world_fog")) | ($BossBar$Flag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBar$Flag_ = $BossBar$Flag$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/identity/$Identity" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export interface $Identity extends $Examinable {

 "examinableProperties"(): $Stream<(any)>
 "uuid"(): $UUID
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R

(uuid: $UUID$Type): $Identity
}

export namespace $Identity {
const NAME: $Pointer<(string)>
const UUID: $Pointer<($UUID)>
const DISPLAY_NAME: $Pointer<($Component)>
const LOCALE: $Pointer<($Locale)>
function identity(uuid: $UUID$Type): $Identity
function nil(): $Identity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Identity$Type = ($Identity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Identity_ = $Identity$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$TriState" {
import {$BooleanSupplier, $BooleanSupplier$Type} from "packages/java/util/function/$BooleanSupplier"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $TriState extends $Enum<($TriState)> {
static readonly "NOT_SET": $TriState
static readonly "FALSE": $TriState
static readonly "TRUE": $TriState


public static "values"(): ($TriState)[]
public static "valueOf"(name: string): $TriState
public "toBoolean"(): boolean
public static "byBoolean"(value: boolean): $TriState
public static "byBoolean"(value: boolean): $TriState
public "toBooleanOrElseGet"(supplier: $BooleanSupplier$Type): boolean
public "toBooleanOrElse"(other: boolean): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TriState$Type = (("not_set") | ("false") | ("true")) | ($TriState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TriState_ = $TriState$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AbstractParser" {
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $AbstractParser<MessageType extends $MessageLite> implements $Parser<(MessageType)> {

constructor()

public "parsePartialFrom"(arg0: (byte)[]): MessageType
public "parsePartialFrom"(arg0: (byte)[], arg1: integer, arg2: integer): MessageType
public "parsePartialFrom"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: $ExtensionRegistryLite$Type): MessageType
public "parsePartialFrom"(arg0: $InputStream$Type): MessageType
public "parsePartialFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
public "parsePartialFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): MessageType
public "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
public "parseDelimitedFrom"(arg0: $InputStream$Type): MessageType
public "parseFrom"(arg0: $CodedInputStream$Type): MessageType
public "parseFrom"(arg0: (byte)[]): MessageType
public "parseFrom"(arg0: $InputStream$Type): MessageType
public "parsePartialFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractParser$Type<MessageType> = ($AbstractParser<(MessageType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractParser_<MessageType> = $AbstractParser$Type<(MessageType)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$TextDecorationSerializer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TextDecorationSerializer {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextDecorationSerializer$Type = ($TextDecorationSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextDecorationSerializer_ = $TextDecorationSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeImpl1Client" {
import {$ClientHandshakeBuilder, $ClientHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshakeBuilder"
import {$HandshakedataImpl1, $HandshakedataImpl1$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakedataImpl1"

export class $HandshakeImpl1Client extends $HandshakedataImpl1 implements $ClientHandshakeBuilder {

constructor()

public "setResourceDescriptor"(arg0: string): void
public "getResourceDescriptor"(): string
set "resourceDescriptor"(value: string)
get "resourceDescriptor"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeImpl1Client$Type = ($HandshakeImpl1Client);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeImpl1Client_ = $HandshakeImpl1Client$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$MonkeyBars" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $MonkeyBars {


public static "addOne"<T>(oldList: $List$Type<(T)>, newElement: T): $List<(T)>
public static "enumSet"<E extends $Enum<(E)>>(type: $Class$Type<(E)>, ...constants: (E)[]): $Set<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MonkeyBars$Type = ($MonkeyBars);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MonkeyBars_ = $MonkeyBars$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/identity/$Identified" {
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"

export interface $Identified {

 "identity"(): $Identity

(): $Identity
}

export namespace $Identified {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Identified$Type = ($Identified);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Identified_ = $Identified$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Services0" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Services0 {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Services0$Type = ($Services0);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Services0_ = $Services0$Type;
}}
declare module "packages/me/lucko/spark/common/platform/$PlatformStatisticsProvider" {
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$GarbageCollectorStatistics, $GarbageCollectorStatistics$Type} from "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectorStatistics"

export class $PlatformStatisticsProvider {

constructor(arg0: $SparkPlatform$Type)

public "getPlatformStatistics"(arg0: $Map$Type<(string), ($GarbageCollectorStatistics$Type)>, arg1: boolean): $SparkProtos$PlatformStatistics
public "getSystemStatistics"(): $SparkProtos$SystemStatistics
public static "rollingAvgProto"(arg0: $DoubleAverageInfo$Type): $SparkProtos$RollingAverageValues
get "systemStatistics"(): $SparkProtos$SystemStatistics
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformStatisticsProvider$Type = ($PlatformStatisticsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformStatisticsProvider_ = $PlatformStatisticsProvider$Type;
}}
declare module "packages/me/lucko/spark/common/util/$MediaTypes" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MediaTypes extends $Enum<($MediaTypes)> {
static readonly "SPARK_SAMPLER_MEDIA_TYPE": string
static readonly "SPARK_HEAP_MEDIA_TYPE": string


public static "values"(): ($MediaTypes)[]
public static "valueOf"(arg0: string): $MediaTypes
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MediaTypes$Type = (never) | ($MediaTypes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MediaTypes_ = $MediaTypes$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/$Examiner" {
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $Examiner<R> {

 "examine"(values: (integer)[]): R
 "examine"(value: integer): R
 "examine"(values: (float)[]): R
 "examine"(value: float): R
 "examine"(values: (double)[]): R
 "examine"(value: string): R
 "examine"(values: (short)[]): R
 "examine"(value: short): R
 "examine"(values: (long)[]): R
 "examine"(value: long): R
 "examine"(values: (boolean)[]): R
 "examine"(value: boolean): R
 "examine"(value: any): R
 "examine"(name: string, properties: $Stream$Type<(any)>): R
 "examine"(examinable: $Examinable$Type): R
 "examine"(value: double): R
 "examine"(values: (character)[]): R
 "examine"(value: character): R
 "examine"(values: (byte)[]): R
 "examine"(value: byte): R
}

export namespace $Examiner {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Examiner$Type<R> = ($Examiner<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Examiner_<R> = $Examiner$Type<(R)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnsafeUtil" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UnsafeUtil {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnsafeUtil$Type = ($UnsafeUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnsafeUtil_ = $UnsafeUtil$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList" {
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/java/util/$AbstractList"

export class $AbstractProtobufList<E> extends $AbstractList<(E)> implements $Internal$ProtobufList<(E)> {


public "add"(arg0: integer, arg1: E): void
public "add"(arg0: E): boolean
public "remove"(arg0: any): boolean
public "remove"(arg0: integer): E
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clear"(): void
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: E): E
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "makeImmutable"(): void
public "isModifiable"(): boolean
public "mutableCopyWithCapacity"(arg0: integer): $Internal$ProtobufList<(E)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "modifiable"(): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractProtobufList$Type<E> = ($AbstractProtobufList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractProtobufList_<E> = $AbstractProtobufList$Type<(E)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ArrayDecoders$Registers" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $ArrayDecoders$Registers {
 "int1": integer
 "long1": long
 "object1": any
readonly "extensionRegistry": $ExtensionRegistryLite


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDecoders$Registers$Type = ($ArrayDecoders$Registers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDecoders$Registers_ = $ArrayDecoders$Registers$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"

export interface $StyleBuilderApplicable extends $ComponentBuilderApplicable {

 "styleApply"(style: $Style$Builder$Type): void
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void

(style: $Style$Builder$Type): void
}

export namespace $StyleBuilderApplicable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StyleBuilderApplicable$Type = ($StyleBuilderApplicable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StyleBuilderApplicable_ = $StyleBuilderApplicable$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode" {
import {$SparkSamplerProtos$StackTraceNodeOrBuilder, $SparkSamplerProtos$StackTraceNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNodeOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$StackTraceNode, $SparkSamplerProtos$StackTraceNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode"
import {$SparkSamplerProtos$ThreadNode$Builder, $SparkSamplerProtos$ThreadNode$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode$Builder"
import {$SparkSamplerProtos$ThreadNodeOrBuilder, $SparkSamplerProtos$ThreadNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNodeOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkSamplerProtos$ThreadNode extends $GeneratedMessageLite<($SparkSamplerProtos$ThreadNode), ($SparkSamplerProtos$ThreadNode$Builder)> implements $SparkSamplerProtos$ThreadNodeOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "CHILDREN_FIELD_NUMBER": integer
static readonly "TIMES_FIELD_NUMBER": integer
static readonly "CHILDREN_REFS_FIELD_NUMBER": integer


public "getTimesList"(): $List<(double)>
public "getChildrenList"(): $List<($SparkSamplerProtos$StackTraceNode)>
public "getChildrenRefs"(arg0: integer): integer
public "getTimesCount"(): integer
public "getName"(): string
public static "parser"(): $Parser<($SparkSamplerProtos$ThreadNode)>
public "getChildren"(arg0: integer): $SparkSamplerProtos$StackTraceNode
public static "newBuilder"(arg0: $SparkSamplerProtos$ThreadNode$Type): $SparkSamplerProtos$ThreadNode$Builder
public static "newBuilder"(): $SparkSamplerProtos$ThreadNode$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$ThreadNode
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "getDefaultInstance"(): $SparkSamplerProtos$ThreadNode
public "getTimes"(arg0: integer): double
public "getNameBytes"(): $ByteString
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$ThreadNode
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$ThreadNode
public "getChildrenCount"(): integer
public "getChildrenOrBuilder"(arg0: integer): $SparkSamplerProtos$StackTraceNodeOrBuilder
public "getChildrenRefsList"(): $List<(integer)>
public "getChildrenRefsCount"(): integer
public "getChildrenOrBuilderList"(): $List<(any)>
get "timesList"(): $List<(double)>
get "childrenList"(): $List<($SparkSamplerProtos$StackTraceNode)>
get "timesCount"(): integer
get "name"(): string
get "defaultInstance"(): $SparkSamplerProtos$ThreadNode
get "nameBytes"(): $ByteString
get "childrenCount"(): integer
get "childrenRefsList"(): $List<(integer)>
get "childrenRefsCount"(): integer
get "childrenOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$ThreadNode$Type = ($SparkSamplerProtos$ThreadNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$ThreadNode_ = $SparkSamplerProtos$ThreadNode$Type;
}}
declare module "packages/me/lucko/spark/common/platform/serverconfig/$ConfigParser" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ExcludedConfigFilter, $ExcludedConfigFilter$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ExcludedConfigFilter"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ConfigParser {

 "load"(arg0: string, arg1: $ExcludedConfigFilter$Type): $JsonElement
 "parse"(arg0: $Path$Type): $Map<(string), (any)>
 "parse"(arg0: $BufferedReader$Type): $Map<(string), (any)>
}

export namespace $ConfigParser {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConfigParser$Type = ($ConfigParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConfigParser_ = $ConfigParser$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Type" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkProtos$PlatformMetadata$Type extends $Enum<($SparkProtos$PlatformMetadata$Type)> implements $Internal$EnumLite {
static readonly "SERVER": $SparkProtos$PlatformMetadata$Type
static readonly "CLIENT": $SparkProtos$PlatformMetadata$Type
static readonly "PROXY": $SparkProtos$PlatformMetadata$Type
static readonly "UNRECOGNIZED": $SparkProtos$PlatformMetadata$Type
static readonly "SERVER_VALUE": integer
static readonly "CLIENT_VALUE": integer
static readonly "PROXY_VALUE": integer


public static "values"(): ($SparkProtos$PlatformMetadata$Type)[]
public static "valueOf"(arg0: string): $SparkProtos$PlatformMetadata$Type
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkProtos$PlatformMetadata$Type
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkProtos$PlatformMetadata$Type)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkProtos$PlatformMetadata$Type
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformMetadata$Type$Type = (("server") | ("proxy") | ("client") | ("unrecognized")) | ($SparkProtos$PlatformMetadata$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformMetadata$Type_ = $SparkProtos$PlatformMetadata$Type$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder extends $MessageLiteOrBuilder {

 "getPayloadId"(): string
 "getPayloadIdBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder$Type = ($SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder_ = $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder extends $MessageLiteOrBuilder {

 "getTotal"(): long
 "getUsed"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder$Type = ($SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder_ = $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Option" {
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$Any, $Any$Type} from "packages/me/lucko/spark/lib/protobuf/$Any"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Option extends $GeneratedMessageLite<($Option), ($Option$Builder)> implements $OptionOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "VALUE_FIELD_NUMBER": integer


public "getName"(): string
public "getValue"(): $Any
public static "parser"(): $Parser<($Option)>
public "hasValue"(): boolean
public static "newBuilder"(): $Option$Builder
public static "newBuilder"(arg0: $Option$Type): $Option$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Option
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Option
public static "getDefaultInstance"(): $Option
public "getNameBytes"(): $ByteString
public static "parseFrom"(arg0: $ByteBuffer$Type): $Option
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Option
public static "parseFrom"(arg0: $CodedInputStream$Type): $Option
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Option
public static "parseFrom"(arg0: (byte)[]): $Option
public static "parseFrom"(arg0: $InputStream$Type): $Option
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Option
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Option
public static "parseFrom"(arg0: $ByteString$Type): $Option
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Option
get "name"(): string
get "value"(): $Any
get "defaultInstance"(): $Option
get "nameBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Option$Type = ($Option);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Option_ = $Option$Type;
}}
declare module "packages/me/lucko/spark/lib/asyncprofiler/$AsyncProfilerMXBean" {
import {$Counter, $Counter$Type} from "packages/me/lucko/spark/lib/asyncprofiler/$Counter"

export interface $AsyncProfilerMXBean {

 "start"(arg0: string, arg1: long): void
 "execute"(arg0: string): string
 "resume"(arg0: string, arg1: long): void
 "stop"(): void
 "getVersion"(): string
 "getSamples"(): long
 "dumpTraces"(arg0: integer): string
 "dumpCollapsed"(arg0: $Counter$Type): string
 "dumpFlat"(arg0: integer): string
}

export namespace $AsyncProfilerMXBean {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncProfilerMXBean$Type = ($AsyncProfilerMXBean);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncProfilerMXBean_ = $AsyncProfilerMXBean$Type;
}}
declare module "packages/me/lucko/spark/common/$SparkPlatform" {
import {$PingStatistics, $PingStatistics$Type} from "packages/me/lucko/spark/common/monitor/ping/$PingStatistics"
import {$TickStatistics, $TickStatistics$Type} from "packages/me/lucko/spark/common/monitor/tick/$TickStatistics"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$BytesocksClient, $BytesocksClient$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient"
import {$SamplerContainer, $SamplerContainer$Type} from "packages/me/lucko/spark/common/sampler/$SamplerContainer"
import {$SparkPlugin, $SparkPlugin$Type} from "packages/me/lucko/spark/common/$SparkPlugin"
import {$PlatformStatisticsProvider, $PlatformStatisticsProvider$Type} from "packages/me/lucko/spark/common/platform/$PlatformStatisticsProvider"
import {$BackgroundSamplerManager, $BackgroundSamplerManager$Type} from "packages/me/lucko/spark/common/sampler/$BackgroundSamplerManager"
import {$Configuration, $Configuration$Type} from "packages/me/lucko/spark/common/util/$Configuration"
import {$TrustedKeyStore, $TrustedKeyStore$Type} from "packages/me/lucko/spark/common/ws/$TrustedKeyStore"
import {$ActivityLog, $ActivityLog$Type} from "packages/me/lucko/spark/common/activitylog/$ActivityLog"
import {$BytebinClient, $BytebinClient$Type} from "packages/me/lucko/spark/common/util/$BytebinClient"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClassSourceLookup, $ClassSourceLookup$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$TemporaryFiles, $TemporaryFiles$Type} from "packages/me/lucko/spark/common/util/$TemporaryFiles"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$GarbageCollectorStatistics, $GarbageCollectorStatistics$Type} from "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectorStatistics"

export class $SparkPlatform {

constructor(arg0: $SparkPlugin$Type)

public "enable"(): void
public "getActivityLog"(): $ActivityLog
public "getTickReporter"(): $TickReporter
public "getPingStatistics"(): $PingStatistics
public "resolveSaveFile"(arg0: string, arg1: string): $Path
public "getViewerUrl"(): string
public "getTickHook"(): $TickHook
public "getTickStatistics"(): $TickStatistics
public "getTemporaryFiles"(): $TemporaryFiles
public "getBytesocksClient"(): $BytesocksClient
public "getBytebinClient"(): $BytebinClient
public "getCommands"(): $List<($Command)>
public "tabCompleteCommand"(arg0: $CommandSender$Type, arg1: (string)[]): $List<(string)>
public "createClassSourceLookup"(): $ClassSourceLookup
public "getPlugin"(): $SparkPlugin
public "getStartupGcStatistics"(): $Map<(string), ($GarbageCollectorStatistics)>
public "getServerNormalOperationStartTime"(): long
public "shouldBroadcastResponse"(): boolean
public "getSamplerContainer"(): $SamplerContainer
public "getStatisticsProvider"(): $PlatformStatisticsProvider
public "getBackgroundSamplerManager"(): $BackgroundSamplerManager
public "hasPermissionForAnyCommand"(arg0: $CommandSender$Type): boolean
public "executeCommand"(arg0: $CommandSender$Type, arg1: (string)[]): void
public "disable"(): void
public "getConfiguration"(): $Configuration
public "getTrustedKeyStore"(): $TrustedKeyStore
get "activityLog"(): $ActivityLog
get "tickReporter"(): $TickReporter
get "pingStatistics"(): $PingStatistics
get "viewerUrl"(): string
get "tickHook"(): $TickHook
get "tickStatistics"(): $TickStatistics
get "temporaryFiles"(): $TemporaryFiles
get "bytesocksClient"(): $BytesocksClient
get "bytebinClient"(): $BytebinClient
get "commands"(): $List<($Command)>
get "plugin"(): $SparkPlugin
get "startupGcStatistics"(): $Map<(string), ($GarbageCollectorStatistics)>
get "serverNormalOperationStartTime"(): long
get "samplerContainer"(): $SamplerContainer
get "statisticsProvider"(): $PlatformStatisticsProvider
get "backgroundSamplerManager"(): $BackgroundSamplerManager
get "configuration"(): $Configuration
get "trustedKeyStore"(): $TrustedKeyStore
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkPlatform$Type = ($SparkPlatform);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkPlatform_ = $SparkPlatform$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType" {
import {$WireFormat$JavaType, $WireFormat$JavaType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$JavaType"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $WireFormat$FieldType extends $Enum<($WireFormat$FieldType)> {
static readonly "DOUBLE": $WireFormat$FieldType
static readonly "FLOAT": $WireFormat$FieldType
static readonly "INT64": $WireFormat$FieldType
static readonly "UINT64": $WireFormat$FieldType
static readonly "INT32": $WireFormat$FieldType
static readonly "FIXED64": $WireFormat$FieldType
static readonly "FIXED32": $WireFormat$FieldType
static readonly "BOOL": $WireFormat$FieldType
static readonly "STRING": $WireFormat$FieldType
static readonly "GROUP": $WireFormat$FieldType
static readonly "MESSAGE": $WireFormat$FieldType
static readonly "BYTES": $WireFormat$FieldType
static readonly "UINT32": $WireFormat$FieldType
static readonly "ENUM": $WireFormat$FieldType
static readonly "SFIXED32": $WireFormat$FieldType
static readonly "SFIXED64": $WireFormat$FieldType
static readonly "SINT32": $WireFormat$FieldType
static readonly "SINT64": $WireFormat$FieldType


public static "values"(): ($WireFormat$FieldType)[]
public static "valueOf"(arg0: string): $WireFormat$FieldType
public "getJavaType"(): $WireFormat$JavaType
public "getWireType"(): integer
public "isPackable"(): boolean
get "javaType"(): $WireFormat$JavaType
get "wireType"(): integer
get "packable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WireFormat$FieldType$Type = (("fixed64") | ("fixed32") | ("sint64") | ("sint32") | ("bool") | ("string") | ("sfixed64") | ("double") | ("float") | ("message") | ("enum") | ("int32") | ("int64") | ("bytes") | ("uint64") | ("sfixed32") | ("uint32") | ("group")) | ($WireFormat$FieldType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WireFormat$FieldType_ = $WireFormat$FieldType$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$MutableStyleSetter, $MutableStyleSetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$MutableStyleSetter"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Style$Builder extends $AbstractBuilder<($Style)>, $Buildable$Builder<($Style)>, $MutableStyleSetter<($Style$Builder)> {

 "apply"(applicable: $StyleBuilderApplicable$Type): $Style$Builder
 "merge"(that: $Style$Type, ...merges: ($Style$Merge$Type)[]): $Style$Builder
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type): $Style$Builder
 "merge"(that: $Style$Type): $Style$Builder
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, ...merges: ($Style$Merge$Type)[]): $Style$Builder
 "merge"(that: $Style$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style$Builder
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style$Builder
 "color"(color: $TextColor$Type): $Style$Builder
 "colorIfAbsent"(color: $TextColor$Type): $Style$Builder
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Style$Builder
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Style$Builder
 "decorate"(decoration: $TextDecoration$Type): $Style$Builder
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Style$Builder
 "insertion"(insertion: string): $Style$Builder
 "clickEvent"(event: $ClickEvent$Type): $Style$Builder
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Style$Builder
}

export namespace $Style$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $Style
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Style$Builder$Type = ($Style$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Style$Builder_ = $Style$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent" {
import {$BinaryTagHolder, $BinaryTagHolder$Type} from "packages/me/lucko/spark/lib/adventure/nbt/api/$BinaryTagHolder"
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$HoverEvent$ShowItem, $HoverEvent$ShowItem$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowItem"
import {$HoverEvent$Action, $HoverEvent$Action$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$Action"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$HoverEvent$ShowEntity, $HoverEvent$ShowEntity$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowEntity"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$ComponentRenderer, $ComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$ComponentRenderer"
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $HoverEvent<V> implements $Examinable, $HoverEventSource<(V)>, $StyleBuilderApplicable {


public "value"(value: V): $HoverEvent<(V)>
public "value"(): V
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "action"(): $HoverEvent$Action<(V)>
public "styleApply"(style: $Style$Builder$Type): void
public "asHoverEvent"(): $HoverEvent<(V)>
public "asHoverEvent"(op: $UnaryOperator$Type<(V)>): $HoverEvent<(V)>
public static "showText"(text: $ComponentLike$Type): $HoverEvent<($Component)>
public static "showText"(text: $Component$Type): $HoverEvent<($Component)>
public "examinableProperties"(): $Stream<(any)>
public static "showEntity"(type: $Key$Type, id: $UUID$Type): $HoverEvent<($HoverEvent$ShowEntity)>
public static "showEntity"(entity: $HoverEvent$ShowEntity$Type): $HoverEvent<($HoverEvent$ShowEntity)>
public static "showEntity"(type: $Keyed$Type, id: $UUID$Type, name: $Component$Type): $HoverEvent<($HoverEvent$ShowEntity)>
public static "showEntity"(type: $Key$Type, id: $UUID$Type, name: $Component$Type): $HoverEvent<($HoverEvent$ShowEntity)>
public static "showEntity"(type: $Keyed$Type, id: $UUID$Type): $HoverEvent<($HoverEvent$ShowEntity)>
public "withRenderedValue"<C>(renderer: $ComponentRenderer$Type<(C)>, context: C): $HoverEvent<(V)>
public static "showItem"(item: $Keyed$Type, count: integer): $HoverEvent<($HoverEvent$ShowItem)>
public static "showItem"(item: $Key$Type, count: integer): $HoverEvent<($HoverEvent$ShowItem)>
public static "showItem"(item: $HoverEvent$ShowItem$Type): $HoverEvent<($HoverEvent$ShowItem)>
public static "showItem"(item: $Keyed$Type, count: integer, nbt: $BinaryTagHolder$Type): $HoverEvent<($HoverEvent$ShowItem)>
public static "showItem"(item: $Key$Type, count: integer, nbt: $BinaryTagHolder$Type): $HoverEvent<($HoverEvent$ShowItem)>
public static "hoverEvent"<V>(action: $HoverEvent$Action$Type<(V)>, value: V): $HoverEvent<(V)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public static "unbox"<V>(source: $HoverEventSource$Type<(V)>): $HoverEvent<(V)>
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEvent$Type<V> = ($HoverEvent<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEvent_<V> = $HoverEvent$Type<(V)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$ModuleWriter" {
import {$ModuleVisitor, $ModuleVisitor$Type} from "packages/me/lucko/spark/lib/asm/$ModuleVisitor"

export class $ModuleWriter extends $ModuleVisitor {


public "visitEnd"(): void
public "visitMainClass"(arg0: string): void
public "visitPackage"(arg0: string): void
public "visitRequire"(arg0: string, arg1: integer, arg2: string): void
public "visitExport"(arg0: string, arg1: integer, ...arg2: (string)[]): void
public "visitOpen"(arg0: string, arg1: integer, ...arg2: (string)[]): void
public "visitUse"(arg0: string): void
public "visitProvide"(arg0: string, ...arg1: (string)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleWriter$Type = ($ModuleWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleWriter_ = $ModuleWriter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatisticsOrBuilder" {
import {$SparkProtos$PlatformStatistics$Tps, $SparkProtos$PlatformStatistics$Tps$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps"
import {$SparkProtos$PlatformStatistics$Mspt, $SparkProtos$PlatformStatistics$Mspt$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt"
import {$SparkProtos$PlatformStatistics$Gc, $SparkProtos$PlatformStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc"
import {$SparkProtos$PlatformStatistics$Memory, $SparkProtos$PlatformStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$WorldStatistics, $SparkProtos$WorldStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics"
import {$SparkProtos$PlatformStatistics$Ping, $SparkProtos$PlatformStatistics$Ping$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SparkProtos$PlatformStatisticsOrBuilder extends $MessageLiteOrBuilder {

 "getTps"(): $SparkProtos$PlatformStatistics$Tps
 "getUptime"(): long
 "getWorld"(): $SparkProtos$WorldStatistics
 "getMemory"(): $SparkProtos$PlatformStatistics$Memory
 "hasTps"(): boolean
 "getGcOrDefault"(arg0: string, arg1: $SparkProtos$PlatformStatistics$Gc$Type): $SparkProtos$PlatformStatistics$Gc
 "hasMemory"(): boolean
 "getGcCount"(): integer
 "getGcMap"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
 "hasMspt"(): boolean
 "getMspt"(): $SparkProtos$PlatformStatistics$Mspt
 "hasPing"(): boolean
 "getPing"(): $SparkProtos$PlatformStatistics$Ping
/**
 * 
 * @deprecated
 */
 "getGc"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
 "getGcOrThrow"(arg0: string): $SparkProtos$PlatformStatistics$Gc
 "containsGc"(arg0: string): boolean
 "getPlayerCount"(): long
 "hasWorld"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatisticsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatisticsOrBuilder$Type = ($SparkProtos$PlatformStatisticsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatisticsOrBuilder_ = $SparkProtos$PlatformStatisticsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Empty" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$Empty$Builder, $Empty$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Empty$Builder"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$EmptyOrBuilder, $EmptyOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EmptyOrBuilder"

export class $Empty extends $GeneratedMessageLite<($Empty), ($Empty$Builder)> implements $EmptyOrBuilder {


public static "parser"(): $Parser<($Empty)>
public static "newBuilder"(arg0: $Empty$Type): $Empty$Builder
public static "newBuilder"(): $Empty$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Empty
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Empty
public static "getDefaultInstance"(): $Empty
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Empty
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Empty
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Empty
public static "parseFrom"(arg0: (byte)[]): $Empty
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Empty
public static "parseFrom"(arg0: $ByteString$Type): $Empty
public static "parseFrom"(arg0: $CodedInputStream$Type): $Empty
public static "parseFrom"(arg0: $ByteBuffer$Type): $Empty
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Empty
public static "parseFrom"(arg0: $InputStream$Type): $Empty
get "defaultInstance"(): $Empty
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Empty$Type = ($Empty);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Empty_ = $Empty$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$NewInstanceSchemas" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $NewInstanceSchemas {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NewInstanceSchemas$Type = ($NewInstanceSchemas);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NewInstanceSchemas_ = $NewInstanceSchemas$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextColor" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$HSVLike, $HSVLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$HSVLike"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$RGBLike, $RGBLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$RGBLike"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$TextFormat, $TextFormat$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextFormat"

export interface $TextColor extends $Comparable<($TextColor)>, $Examinable, $RGBLike, $StyleBuilderApplicable, $TextFormat {

 "value"(): integer
 "compareTo"(that: $TextColor$Type): integer
 "red"(): integer
 "asHexString"(): string
 "styleApply"(style: $Style$Builder$Type): void
 "examinableProperties"(): $Stream<(any)>
 "blue"(): integer
 "green"(): integer
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHSV"(): $HSVLike
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void

(): integer
}

export namespace $TextColor {
function color(r: float, g: float, b: float): $TextColor
function color(value: integer): $TextColor
function color(rgb: $RGBLike$Type): $TextColor
function color(r: integer, g: integer, b: integer): $TextColor
function color(hsv: $HSVLike$Type): $TextColor
function fromCSSHexString(string: string): $TextColor
function fromHexString(string: string): $TextColor
function lerp(t: float, a: $RGBLike$Type, b: $RGBLike$Type): $TextColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextColor$Type = ($TextColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextColor_ = $TextColor$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/java/$JavaDataAggregator" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ThreadInfo, $ThreadInfo$Type} from "packages/java/lang/management/$ThreadInfo"
import {$ThreadGrouper, $ThreadGrouper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadGrouper"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"
import {$AbstractDataAggregator, $AbstractDataAggregator$Type} from "packages/me/lucko/spark/common/sampler/aggregator/$AbstractDataAggregator"

export class $JavaDataAggregator extends $AbstractDataAggregator {

constructor(arg0: $ExecutorService$Type, arg1: $ThreadGrouper$Type, arg2: integer, arg3: boolean, arg4: boolean)

public "exportData"(): $List<($ThreadNode)>
public "insertData"(arg0: $ThreadInfo$Type, arg1: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaDataAggregator$Type = ($JavaDataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaDataAggregator_ = $JavaDataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource" {
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"

export interface $HoverEventSource<V> {

 "asHoverEvent"(): $HoverEvent<(V)>
 "asHoverEvent"(op: $UnaryOperator$Type<(V)>): $HoverEvent<(V)>

(source: $HoverEventSource$Type<(V)>): $HoverEvent<(V)>
}

export namespace $HoverEventSource {
function unbox<V>(source: $HoverEventSource$Type<(V)>): $HoverEvent<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEventSource$Type<V> = ($HoverEventSource<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEventSource_<V> = $HoverEventSource$Type<(V)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Style$Merge$Strategy extends $Enum<($Style$Merge$Strategy)> {
static readonly "ALWAYS": $Style$Merge$Strategy
static readonly "NEVER": $Style$Merge$Strategy
static readonly "IF_ABSENT_ON_TARGET": $Style$Merge$Strategy


public static "values"(): ($Style$Merge$Strategy)[]
public static "valueOf"(name: string): $Style$Merge$Strategy
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Style$Merge$Strategy$Type = (("always") | ("never") | ("if_absent_on_target")) | ($Style$Merge$Strategy);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Style$Merge$Strategy_ = $Style$Merge$Strategy$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$LazyStringArrayList" {
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$LazyStringList, $LazyStringList$Type} from "packages/me/lucko/spark/lib/protobuf/$LazyStringList"

export class $LazyStringArrayList extends $AbstractProtobufList<(string)> implements $LazyStringList, $RandomAccess {
static readonly "EMPTY": $LazyStringList

constructor(arg0: $LazyStringList$Type)
constructor(arg0: $List$Type<(string)>)
constructor(arg0: integer)
constructor()

public "getUnderlyingElements"(): $List<(any)>
public "getUnmodifiableView"(): $LazyStringList
public "add"(arg0: $ByteString$Type): void
public "add"(arg0: (byte)[]): void
public "add"(arg0: integer, arg1: string): void
public "remove"(arg0: integer): string
public "clear"(): void
public "size"(): integer
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: (byte)[]): void
public "set"(arg0: integer, arg1: string): string
public "set"(arg0: integer, arg1: $ByteString$Type): void
public "getRaw"(arg0: integer): any
public "getByteArray"(arg0: integer): (byte)[]
public "mergeFrom"(arg0: $LazyStringList$Type): void
public "asByteStringList"(): $List<($ByteString)>
public "getByteString"(arg0: integer): $ByteString
public "asByteArrayList"(): $List<((byte)[])>
public "addAllByteString"(arg0: $Collection$Type<(any)>): boolean
public "addAllByteArray"(arg0: $Collection$Type<((byte)[])>): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(string)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string): $List<(string)>
public static "of"<E>(arg0: string): $List<(string)>
public static "of"<E>(): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string): $List<(string)>
public static "of"<E>(...arg0: (string)[]): $List<(string)>
public "contains"(arg0: any): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "underlyingElements"(): $List<(any)>
get "unmodifiableView"(): $LazyStringList
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyStringArrayList$Type = ($LazyStringArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyStringArrayList_ = $LazyStringArrayList$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing$Builder" {
import {$SparkWebSocketProtos$ClientPing, $SparkWebSocketProtos$ClientPing$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ClientPingOrBuilder, $SparkWebSocketProtos$ClientPingOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPingOrBuilder"

export class $SparkWebSocketProtos$ClientPing$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ClientPing), ($SparkWebSocketProtos$ClientPing$Builder)> implements $SparkWebSocketProtos$ClientPingOrBuilder {


public "getData"(): integer
public "setData"(arg0: integer): $SparkWebSocketProtos$ClientPing$Builder
public "clearData"(): $SparkWebSocketProtos$ClientPing$Builder
public "setOk"(arg0: boolean): $SparkWebSocketProtos$ClientPing$Builder
public "getOk"(): boolean
public "clearOk"(): $SparkWebSocketProtos$ClientPing$Builder
get "data"(): integer
set "data"(value: integer)
set "ok"(value: boolean)
get "ok"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientPing$Builder$Type = ($SparkWebSocketProtos$ClientPing$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientPing$Builder_ = $SparkWebSocketProtos$ClientPing$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MethodOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $MethodOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getSyntax"(): $Syntax
 "getOptions"(arg0: integer): $Option
 "getResponseTypeUrl"(): string
 "getRequestTypeUrl"(): string
 "getNameBytes"(): $ByteString
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "getSyntaxValue"(): integer
 "getResponseStreaming"(): boolean
 "getRequestTypeUrlBytes"(): $ByteString
 "getResponseTypeUrlBytes"(): $ByteString
 "getRequestStreaming"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $MethodOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodOrBuilder$Type = ($MethodOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodOrBuilder_ = $MethodOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$SymbolTable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SymbolTable {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SymbolTable$Type = ($SymbolTable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SymbolTable_ = $SymbolTable$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSetLiteSchema" {
import {$UnknownFieldSchema, $UnknownFieldSchema$Type} from "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSchema"
import {$UnknownFieldSetLite, $UnknownFieldSetLite$Type} from "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSetLite"

export class $UnknownFieldSetLiteSchema extends $UnknownFieldSchema<($UnknownFieldSetLite), ($UnknownFieldSetLite)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownFieldSetLiteSchema$Type = ($UnknownFieldSetLiteSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnknownFieldSetLiteSchema_ = $UnknownFieldSetLiteSchema$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$CustomSSLWebSocketServerFactory" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SSLContext, $SSLContext$Type} from "packages/javax/net/ssl/$SSLContext"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$DefaultSSLWebSocketServerFactory, $DefaultSSLWebSocketServerFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/server/$DefaultSSLWebSocketServerFactory"

export class $CustomSSLWebSocketServerFactory extends $DefaultSSLWebSocketServerFactory {

constructor(arg0: $SSLContext$Type, arg1: (string)[], arg2: (string)[])
constructor(arg0: $SSLContext$Type, arg1: $ExecutorService$Type, arg2: (string)[], arg3: (string)[])

public "wrapChannel"(arg0: $SocketChannel$Type, arg1: $SelectionKey$Type): $ByteChannel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CustomSSLWebSocketServerFactory$Type = ($CustomSSLWebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CustomSSLWebSocketServerFactory_ = $CustomSSLWebSocketServerFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake" {
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ServerHandshake extends $Handshakedata {

 "getHttpStatus"(): short
 "getHttpStatusMessage"(): string
 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $ServerHandshake {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerHandshake$Type = ($ServerHandshake);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerHandshake_ = $ServerHandshake$Type;
}}
declare module "packages/me/lucko/spark/common/util/$Compression" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Compression extends $Enum<($Compression)> {
static readonly "GZIP": $Compression


public static "values"(): ($Compression)[]
public "compress"(arg0: $Path$Type, arg1: $LongConsumer$Type): $Path
public static "valueOf"(arg0: string): $Compression
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Compression$Type = (("gzip")) | ($Compression);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Compression_ = $Compression$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapFieldSchema" {
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $MapFieldSchema {

 "getSerializedSize"(arg0: integer, arg1: any, arg2: any): integer
 "isImmutable"(arg0: any): boolean
 "toImmutable"(arg0: any): any
 "mergeFrom"(arg0: any, arg1: any): any
 "forMutableMapData"(arg0: any): $Map<(any), (any)>
 "newMapField"(arg0: any): any
 "forMapMetadata"(arg0: any): $MapEntryLite$Metadata<(any), (any)>
 "forMapData"(arg0: any): $Map<(any), (any)>
}

export namespace $MapFieldSchema {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapFieldSchema$Type = ($MapFieldSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapFieldSchema_ = $MapFieldSchema$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal" {
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $Internal {
static readonly "EMPTY_BYTE_ARRAY": (byte)[]
static readonly "EMPTY_BYTE_BUFFER": $ByteBuffer
static readonly "EMPTY_CODED_INPUT_STREAM": $CodedInputStream


public static "byteBufferDefaultValue"(arg0: string): $ByteBuffer
public static "byteArrayDefaultValue"(arg0: string): (byte)[]
public static "equals"(arg0: $List$Type<((byte)[])>, arg1: $List$Type<((byte)[])>): boolean
public static "hashCode"(arg0: (byte)[]): integer
public static "hashCode"(arg0: $List$Type<((byte)[])>): integer
public static "toByteArray"(arg0: string): (byte)[]
public static "stringDefaultValue"(arg0: string): string
public static "copyByteBuffer"(arg0: $ByteBuffer$Type): $ByteBuffer
public static "bytesDefaultValue"(arg0: string): $ByteString
public static "toStringUtf8"(arg0: (byte)[]): string
public static "hashEnum"(arg0: $Internal$EnumLite$Type): integer
public static "hashBoolean"(arg0: boolean): integer
public static "hashCodeByteBuffer"(arg0: $ByteBuffer$Type): integer
public static "hashCodeByteBuffer"(arg0: $List$Type<($ByteBuffer$Type)>): integer
public static "equalsByteBuffer"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): boolean
public static "equalsByteBuffer"(arg0: $List$Type<($ByteBuffer$Type)>, arg1: $List$Type<($ByteBuffer$Type)>): boolean
public static "hashEnumList"(arg0: $List$Type<(any)>): integer
public static "isValidUtf8"(arg0: $ByteString$Type): boolean
public static "isValidUtf8"(arg0: (byte)[]): boolean
public static "getDefaultInstance"<T extends $MessageLite>(arg0: $Class$Type<(T)>): T
public static "hashLong"(arg0: long): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$Type = ($Internal);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal_ = $Internal$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent" {
import {$ClickEvent$Action, $ClickEvent$Action$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent$Action"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$URL, $URL$Type} from "packages/java/net/$URL"

export class $ClickEvent implements $Examinable, $StyleBuilderApplicable {


public "value"(): string
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "action"(): $ClickEvent$Action
public static "changePage"(page: integer): $ClickEvent
public static "changePage"(page: string): $ClickEvent
public static "suggestCommand"(command: string): $ClickEvent
public static "openUrl"(url: $URL$Type): $ClickEvent
public static "openUrl"(url: string): $ClickEvent
public "styleApply"(style: $Style$Builder$Type): void
public "examinableProperties"(): $Stream<(any)>
public static "openFile"(file: string): $ClickEvent
public static "runCommand"(command: string): $ClickEvent
public static "copyToClipboard"(text: string): $ClickEvent
public static "clickEvent"(action: $ClickEvent$Action$Type, value: string): $ClickEvent
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClickEvent$Type = ($ClickEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClickEvent_ = $ClickEvent$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream" {
import {$LazyFieldLite, $LazyFieldLite$Type} from "packages/me/lucko/spark/lib/protobuf/$LazyFieldLite"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ByteOutput, $ByteOutput$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteOutput"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $CodedOutputStream extends $ByteOutput {
/**
 * 
 * @deprecated
 */
static readonly "LITTLE_ENDIAN_32_SIZE": integer
static readonly "DEFAULT_BUFFER_SIZE": integer


public "writeRawMessageSetExtension"(arg0: integer, arg1: $ByteString$Type): void
public static "computeRawMessageSetExtensionSize"(arg0: integer, arg1: $ByteString$Type): integer
public static "computeLazyFieldSizeNoTag"(arg0: $LazyFieldLite$Type): integer
public static "computeEnumSizeNoTag"(arg0: integer): integer
public static "computeInt64SizeNoTag"(arg0: long): integer
public static "computeInt32SizeNoTag"(arg0: integer): integer
public static "computeLazyFieldSize"(arg0: integer, arg1: $LazyFieldLite$Type): integer
public static "computeBytesSizeNoTag"(arg0: $ByteString$Type): integer
public static "computeSInt64SizeNoTag"(arg0: long): integer
public static "computeMessageSizeNoTag"(arg0: $MessageLite$Type): integer
public static "computeSInt32SizeNoTag"(arg0: integer): integer
public static "computeStringSizeNoTag"(arg0: string): integer
public static "computeUInt64SizeNoTag"(arg0: long): integer
public static "computeSFixed64Size"(arg0: integer, arg1: long): integer
public static "computeSFixed32Size"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "writeRawLittleEndian32"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "writeRawLittleEndian64"(arg0: long): void
/**
 * 
 * @deprecated
 */
public static "computeRawVarint32Size"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public static "computeRawVarint64Size"(arg0: long): integer
public "writeByteArray"(arg0: integer, arg1: (byte)[]): void
public "writeByteArray"(arg0: integer, arg1: (byte)[], arg2: integer, arg3: integer): void
public "useDeterministicSerialization"(): void
public "flush"(): void
public static "newInstance"(arg0: (byte)[], arg1: integer, arg2: integer): $CodedOutputStream
public static "newInstance"(arg0: $ByteBuffer$Type): $CodedOutputStream
/**
 * 
 * @deprecated
 */
public static "newInstance"(arg0: $ByteBuffer$Type, arg1: integer): $CodedOutputStream
public static "newInstance"(arg0: $OutputStream$Type): $CodedOutputStream
public static "newInstance"(arg0: $OutputStream$Type, arg1: integer): $CodedOutputStream
public static "newInstance"(arg0: (byte)[]): $CodedOutputStream
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "write"(arg0: $ByteBuffer$Type): void
public "write"(arg0: byte): void
public "writeBytes"(arg0: integer, arg1: $ByteString$Type): void
public "writeFloat"(arg0: integer, arg1: float): void
public "writeDouble"(arg0: integer, arg1: double): void
public "writeString"(arg0: integer, arg1: string): void
public "writeSInt64"(arg0: integer, arg1: long): void
public "writeMessage"(arg0: integer, arg1: $MessageLite$Type): void
public "writeUInt64"(arg0: integer, arg1: long): void
public "writeInt32"(arg0: integer, arg1: integer): void
public "writeInt64"(arg0: integer, arg1: long): void
public "writeFixed32"(arg0: integer, arg1: integer): void
public "writeUInt32"(arg0: integer, arg1: integer): void
public "writeSFixed32"(arg0: integer, arg1: integer): void
public "writeSFixed64"(arg0: integer, arg1: long): void
public "writeFixed64"(arg0: integer, arg1: long): void
public "writeSInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "writeGroup"(arg0: integer, arg1: $MessageLite$Type): void
public "writeBool"(arg0: integer, arg1: boolean): void
public static "computeTagSize"(arg0: integer): integer
public static "computeFixed32Size"(arg0: integer, arg1: integer): integer
public static "computeBytesSize"(arg0: integer, arg1: $ByteString$Type): integer
public static "computeUInt64Size"(arg0: integer, arg1: long): integer
public static "computeFixed64Size"(arg0: integer, arg1: long): integer
public "writeFixed64NoTag"(arg0: long): void
public "writeUInt64NoTag"(arg0: long): void
public "writeBytesNoTag"(arg0: $ByteString$Type): void
public "writeFixed32NoTag"(arg0: integer): void
public "writeUInt32NoTag"(arg0: integer): void
public "checkNoSpaceLeft"(): void
public "writeEnum"(arg0: integer, arg1: integer): void
public static "computeByteBufferSizeNoTag"(arg0: $ByteBuffer$Type): integer
public static "computeUInt32SizeNoTag"(arg0: integer): integer
public static "computeByteArraySize"(arg0: integer, arg1: (byte)[]): integer
public static "computeByteBufferSize"(arg0: integer, arg1: $ByteBuffer$Type): integer
public static "encodeZigZag32"(arg0: integer): integer
public static "encodeZigZag64"(arg0: long): long
public "spaceLeft"(): integer
public "writeTag"(arg0: integer, arg1: integer): void
public "writeRawBytes"(arg0: $ByteString$Type): void
public "writeRawBytes"(arg0: $ByteBuffer$Type): void
public "writeRawBytes"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "writeRawBytes"(arg0: (byte)[]): void
public "writeRawByte"(arg0: integer): void
public "writeRawByte"(arg0: byte): void
public "writeByteBuffer"(arg0: integer, arg1: $ByteBuffer$Type): void
/**
 * 
 * @deprecated
 */
public "writeRawVarint32"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "writeRawVarint64"(arg0: long): void
public "getTotalBytesWritten"(): integer
public static "computeMessageSize"(arg0: integer, arg1: $MessageLite$Type): integer
public static "computeBoolSize"(arg0: integer, arg1: boolean): integer
/**
 * 
 * @deprecated
 */
public static "computeGroupSize"(arg0: integer, arg1: $MessageLite$Type): integer
public static "computeSInt32Size"(arg0: integer, arg1: integer): integer
public static "computeFloatSize"(arg0: integer, arg1: float): integer
public static "computeInt32Size"(arg0: integer, arg1: integer): integer
public static "computeEnumSize"(arg0: integer, arg1: integer): integer
public static "computeStringSize"(arg0: integer, arg1: string): integer
public static "computeUInt32Size"(arg0: integer, arg1: integer): integer
public static "computeSInt64Size"(arg0: integer, arg1: long): integer
public static "computeInt64Size"(arg0: integer, arg1: long): integer
public static "computeDoubleSize"(arg0: integer, arg1: double): integer
public "writeLazy"(arg0: $ByteBuffer$Type): void
public "writeLazy"(arg0: (byte)[], arg1: integer, arg2: integer): void
public static "computeLazyFieldMessageSetExtensionSize"(arg0: integer, arg1: $LazyFieldLite$Type): integer
/**
 * 
 * @deprecated
 */
public "writeGroupNoTag"(arg0: $MessageLite$Type): void
public "writeSFixed32NoTag"(arg0: integer): void
public "writeFloatNoTag"(arg0: float): void
public "writeMessageNoTag"(arg0: $MessageLite$Type): void
public "writeSInt32NoTag"(arg0: integer): void
public "writeSInt64NoTag"(arg0: long): void
public "writeDoubleNoTag"(arg0: double): void
public "writeEnumNoTag"(arg0: integer): void
public "writeInt64NoTag"(arg0: long): void
public "writeInt32NoTag"(arg0: integer): void
public "writeBoolNoTag"(arg0: boolean): void
public "writeStringNoTag"(arg0: string): void
public "writeSFixed64NoTag"(arg0: long): void
public static "computeSFixed32SizeNoTag"(arg0: integer): integer
public static "computeSFixed64SizeNoTag"(arg0: long): integer
public static "computeByteArraySizeNoTag"(arg0: (byte)[]): integer
public static "computeFloatSizeNoTag"(arg0: float): integer
public "writeMessageSetExtension"(arg0: integer, arg1: $MessageLite$Type): void
public "writeByteArrayNoTag"(arg0: (byte)[]): void
public static "computeFixed64SizeNoTag"(arg0: long): integer
public static "computeFixed32SizeNoTag"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
public static "computeGroupSizeNoTag"(arg0: $MessageLite$Type): integer
public static "computeBoolSizeNoTag"(arg0: boolean): integer
public static "computeMessageSetExtensionSize"(arg0: integer, arg1: $MessageLite$Type): integer
public static "computeDoubleSizeNoTag"(arg0: double): integer
get "totalBytesWritten"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodedOutputStream$Type = ($CodedOutputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodedOutputStream_ = $CodedOutputStream$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$LongArrayList" {
import {$Internal$LongList, $Internal$LongList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$LongList"
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PrimitiveNonBoxingCollection, $PrimitiveNonBoxingCollection$Type} from "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"

export class $LongArrayList extends $AbstractProtobufList<(long)> implements $Internal$LongList, $RandomAccess, $PrimitiveNonBoxingCollection {


public "add"(arg0: long): boolean
public "add"(arg0: integer, arg1: long): void
public "remove"(arg0: integer): long
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "getLong"(arg0: integer): long
public "size"(): integer
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: long): long
public static "emptyList"(): $LongArrayList
public "setLong"(arg0: integer, arg1: long): long
public "addLong"(arg0: long): void
public "mutableCopyWithCapacity"(arg0: integer): $Internal$LongList
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(long)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long): $List<(long)>
public static "of"<E>(arg0: long): $List<(long)>
public static "of"<E>(): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
public static "of"<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
public static "of"<E>(...arg0: (long)[]): $List<(long)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongArrayList$Type = ($LongArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongArrayList_ = $LongArrayList$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int32Value" {
import {$Int32ValueOrBuilder, $Int32ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int32ValueOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$Int32Value$Builder, $Int32Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int32Value$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Int32Value extends $GeneratedMessageLite<($Int32Value), ($Int32Value$Builder)> implements $Int32ValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): integer
public static "of"(arg0: integer): $Int32Value
public static "parser"(): $Parser<($Int32Value)>
public static "newBuilder"(arg0: $Int32Value$Type): $Int32Value$Builder
public static "newBuilder"(): $Int32Value$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int32Value
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Int32Value
public static "getDefaultInstance"(): $Int32Value
public static "parseFrom"(arg0: $ByteString$Type): $Int32Value
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Int32Value
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Int32Value
public static "parseFrom"(arg0: $ByteBuffer$Type): $Int32Value
public static "parseFrom"(arg0: $CodedInputStream$Type): $Int32Value
public static "parseFrom"(arg0: $InputStream$Type): $Int32Value
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int32Value
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Int32Value
public static "parseFrom"(arg0: (byte)[]): $Int32Value
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int32Value
get "value"(): integer
get "defaultInstance"(): $Int32Value
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int32Value$Type = ($Int32Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int32Value_ = $Int32Value$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$Builder" {
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool"
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformStatistics$Memory, $SparkProtos$PlatformStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory"
import {$SparkProtos$PlatformStatistics$MemoryOrBuilder, $SparkProtos$PlatformStatistics$MemoryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MemoryOrBuilder"

export class $SparkProtos$PlatformStatistics$Memory$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Memory), ($SparkProtos$PlatformStatistics$Memory$Builder)> implements $SparkProtos$PlatformStatistics$MemoryOrBuilder {


public "hasHeap"(): boolean
public "getHeap"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public "clearHeap"(): $SparkProtos$PlatformStatistics$Memory$Builder
public "mergeHeap"(arg0: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type): $SparkProtos$PlatformStatistics$Memory$Builder
public "setHeap"(arg0: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type): $SparkProtos$PlatformStatistics$Memory$Builder
public "setHeap"(arg0: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type): $SparkProtos$PlatformStatistics$Memory$Builder
get "heap"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
set "heap"(value: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type)
set "heap"(value: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Memory$Builder$Type = ($SparkProtos$PlatformStatistics$Memory$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Memory$Builder_ = $SparkProtos$PlatformStatistics$Memory$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadataOrBuilder" {
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"

export interface $SparkHeapProtos$HeapMetadataOrBuilder extends $MessageLiteOrBuilder {

 "getCreator"(): $SparkProtos$CommandSenderMetadata
 "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
 "getSystemStatistics"(): $SparkProtos$SystemStatistics
 "hasPlatformMetadata"(): boolean
 "hasSystemStatistics"(): boolean
 "hasPlatformStatistics"(): boolean
 "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
 "hasCreator"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkHeapProtos$HeapMetadataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapMetadataOrBuilder$Type = ($SparkHeapProtos$HeapMetadataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapMetadataOrBuilder_ = $SparkHeapProtos$HeapMetadataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper extends $Enum<($SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper)> implements $Internal$EnumLite {
static readonly "BY_NAME": $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
static readonly "BY_POOL": $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
static readonly "AS_ONE": $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
static readonly "UNRECOGNIZED": $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
static readonly "BY_NAME_VALUE": integer
static readonly "BY_POOL_VALUE": integer
static readonly "AS_ONE_VALUE": integer


public static "values"(): ($SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper)[]
public static "valueOf"(arg0: string): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type = (("by_name") | ("by_pool") | ("unrecognized") | ("as_one")) | ($SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper_ = $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/string/$MultiLineStringExaminer" {
import {$StringExaminer, $StringExaminer$Type} from "packages/me/lucko/spark/lib/adventure/examination/string/$StringExaminer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$AbstractExaminer, $AbstractExaminer$Type} from "packages/me/lucko/spark/lib/adventure/examination/$AbstractExaminer"

export class $MultiLineStringExaminer extends $AbstractExaminer<($Stream<(string)>)> {

constructor(examiner: $StringExaminer$Type)

public "examine"(value: byte): $Stream<(string)>
public "examine"(value: float): $Stream<(string)>
public "examine"(value: character): $Stream<(string)>
public "examine"(value: double): $Stream<(string)>
public "examine"(value: long): $Stream<(string)>
public "examine"(value: short): $Stream<(string)>
public "examine"(value: integer): $Stream<(string)>
public static "simpleEscaping"(): $MultiLineStringExaminer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MultiLineStringExaminer$Type = ($MultiLineStringExaminer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MultiLineStringExaminer_ = $MultiLineStringExaminer$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$ShowItemSerializer" {
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$HoverEvent$ShowItem, $HoverEvent$ShowItem$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowItem"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"

export class $ShowItemSerializer extends $TypeAdapter<($HoverEvent$ShowItem)> {


public "write"(out: $JsonWriter$Type, value: $HoverEvent$ShowItem$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShowItemSerializer$Type = ($ShowItemSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShowItemSerializer_ = $ShowItemSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$RopeByteString" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ByteString$ByteIterator, $ByteString$ByteIterator$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString$ByteIterator"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $RopeByteString extends $ByteString {
static readonly "EMPTY": $ByteString


public "equals"(arg0: any): boolean
public "substring"(arg0: integer, arg1: integer): $ByteString
public "size"(): integer
public "iterator"(): $ByteString$ByteIterator
public "writeTo"(arg0: $OutputStream$Type): void
public "newCodedInput"(): $CodedInputStream
public "isValidUtf8"(): boolean
public "copyTo"(arg0: $ByteBuffer$Type): void
public "byteAt"(arg0: integer): byte
public "asReadOnlyByteBufferList"(): $List<($ByteBuffer)>
public "asReadOnlyByteBuffer"(): $ByteBuffer
public "newInput"(): $InputStream
get "validUtf8"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RopeByteString$Type = ($RopeByteString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RopeByteString_ = $RopeByteString$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Duration" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$DurationOrBuilder, $DurationOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$DurationOrBuilder"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Duration$Builder, $Duration$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Duration$Builder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Duration extends $GeneratedMessageLite<($Duration), ($Duration$Builder)> implements $DurationOrBuilder {
static readonly "SECONDS_FIELD_NUMBER": integer
static readonly "NANOS_FIELD_NUMBER": integer


public "getSeconds"(): long
public static "parser"(): $Parser<($Duration)>
public static "newBuilder"(): $Duration$Builder
public static "newBuilder"(arg0: $Duration$Type): $Duration$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Duration
public static "getDefaultInstance"(): $Duration
public "getNanos"(): integer
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseFrom"(arg0: $ByteBuffer$Type): $Duration
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseFrom"(arg0: (byte)[]): $Duration
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseFrom"(arg0: $InputStream$Type): $Duration
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Duration
public static "parseFrom"(arg0: $CodedInputStream$Type): $Duration
public static "parseFrom"(arg0: $ByteString$Type): $Duration
get "seconds"(): long
get "defaultInstance"(): $Duration
get "nanos"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Duration$Type = ($Duration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Duration_ = $Duration$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/$Examinable" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Examinable {

 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $Examinable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Examinable$Type = ($Examinable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Examinable_ = $Examinable$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$Action" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$HoverEvent$ShowItem, $HoverEvent$ShowItem$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowItem"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$HoverEvent$ShowEntity, $HoverEvent$ShowEntity$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowEntity"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $HoverEvent$Action<V> {
static readonly "SHOW_TEXT": $HoverEvent$Action<($Component)>
static readonly "SHOW_ITEM": $HoverEvent$Action<($HoverEvent$ShowItem)>
static readonly "SHOW_ENTITY": $HoverEvent$Action<($HoverEvent$ShowEntity)>
static readonly "NAMES": $Index<(string), ($HoverEvent$Action<(any)>)>


public "type"(): $Class<(V)>
public "toString"(): string
public "readable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEvent$Action$Type<V> = ($HoverEvent$Action<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEvent$Action_<V> = $HoverEvent$Action$Type<(V)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Option$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Any, $Any$Type} from "packages/me/lucko/spark/lib/protobuf/$Any"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$Any$Builder, $Any$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Any$Builder"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Option$Builder extends $GeneratedMessageLite$Builder<($Option), ($Option$Builder)> implements $OptionOrBuilder {


public "getName"(): string
public "getValue"(): $Any
public "setName"(arg0: string): $Option$Builder
public "setValue"(arg0: $Any$Type): $Option$Builder
public "setValue"(arg0: $Any$Builder$Type): $Option$Builder
public "mergeValue"(arg0: $Any$Type): $Option$Builder
public "hasValue"(): boolean
public "setNameBytes"(arg0: $ByteString$Type): $Option$Builder
public "clearValue"(): $Option$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Option$Builder
get "name"(): string
get "value"(): $Any
set "name"(value: string)
set "value"(value: $Any$Type)
set "value"(value: $Any$Builder$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Option$Builder$Type = ($Option$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Option$Builder_ = $Option$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCallByLine" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClassSourceLookup$MethodCallByLine {

constructor(arg0: string, arg1: string, arg2: integer)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getLineNumber"(): integer
public "getClassName"(): string
public "getMethodName"(): string
get "lineNumber"(): integer
get "className"(): string
get "methodName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassSourceLookup$MethodCallByLine$Type = ($ClassSourceLookup$MethodCallByLine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassSourceLookup$MethodCallByLine_ = $ClassSourceLookup$MethodCallByLine$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPingOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkWebSocketProtos$ClientPingOrBuilder extends $MessageLiteOrBuilder {

 "getData"(): integer
 "getOk"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ClientPingOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientPingOrBuilder$Type = ($SparkWebSocketProtos$ClientPingOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientPingOrBuilder_ = $SparkWebSocketProtos$ClientPingOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Ticks" {
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"

export interface $Ticks {

}

export namespace $Ticks {
const TICKS_PER_SECOND: integer
const SINGLE_TICK_DURATION_MS: long
function duration(ticks: long): $Duration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Ticks$Type = ($Ticks);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Ticks_ = $Ticks$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$BlockNBTComponentPosSerializer" {
import {$JsonReader, $JsonReader$Type} from "packages/com/google/gson/stream/$JsonReader"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"

export class $BlockNBTComponentPosSerializer extends $TypeAdapter<($BlockNBTComponent$Pos)> {


public "write"(out: $JsonWriter$Type, value: $BlockNBTComponent$Pos$Type): void
public "read"(arg0: $JsonReader$Type): $BlockNBTComponent$Pos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponentPosSerializer$Type = ($BlockNBTComponentPosSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponentPosSerializer_ = $BlockNBTComponentPosSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SourceContextOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SourceContextOrBuilder extends $MessageLiteOrBuilder {

 "getFileName"(): string
 "getFileNameBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SourceContextOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceContextOrBuilder$Type = ($SourceContextOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceContextOrBuilder_ = $SourceContextOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface" {
import {$SparkProtos$SystemStatistics$NetInterface$Builder, $SparkProtos$SystemStatistics$NetInterface$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$NetInterfaceOrBuilder, $SparkProtos$SystemStatistics$NetInterfaceOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterfaceOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$NetInterface extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$NetInterface), ($SparkProtos$SystemStatistics$NetInterface$Builder)> implements $SparkProtos$SystemStatistics$NetInterfaceOrBuilder {
static readonly "RX_BYTES_PER_SECOND_FIELD_NUMBER": integer
static readonly "TX_BYTES_PER_SECOND_FIELD_NUMBER": integer
static readonly "RX_PACKETS_PER_SECOND_FIELD_NUMBER": integer
static readonly "TX_PACKETS_PER_SECOND_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$NetInterface)>
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$NetInterface$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$NetInterface$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$NetInterface
public "hasTxBytesPerSecond"(): boolean
public "getTxBytesPerSecond"(): $SparkProtos$RollingAverageValues
public "hasRxBytesPerSecond"(): boolean
public "getRxBytesPerSecond"(): $SparkProtos$RollingAverageValues
public "hasRxPacketsPerSecond"(): boolean
public "getRxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
public "getTxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
public "hasTxPacketsPerSecond"(): boolean
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$NetInterface
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$NetInterface
get "defaultInstance"(): $SparkProtos$SystemStatistics$NetInterface
get "txBytesPerSecond"(): $SparkProtos$RollingAverageValues
get "rxBytesPerSecond"(): $SparkProtos$RollingAverageValues
get "rxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
get "txPacketsPerSecond"(): $SparkProtos$RollingAverageValues
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$NetInterface$Type = ($SparkProtos$SystemStatistics$NetInterface);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$NetInterface_ = $SparkProtos$SystemStatistics$NetInterface$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeServerConfigProvider" {
import {$ServerConfigProvider, $ServerConfigProvider$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ServerConfigProvider"

export class $ForgeServerConfigProvider extends $ServerConfigProvider {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeServerConfigProvider$Type = ($ForgeServerConfigProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeServerConfigProvider_ = $ForgeServerConfigProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$ChatType, $ChatType$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ChatType$Bound extends $Examinable {

 "name"(): $Component
 "type"(): $ChatType
 "target"(): $Component
 "examinableProperties"(): $Stream<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
}

export namespace $ChatType$Bound {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChatType$Bound$Type = ($ChatType$Bound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChatType$Bound_ = $ChatType$Bound$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Writer$FieldOrder" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Writer$FieldOrder extends $Enum<($Writer$FieldOrder)> {
static readonly "ASCENDING": $Writer$FieldOrder
static readonly "DESCENDING": $Writer$FieldOrder


public static "values"(): ($Writer$FieldOrder)[]
public static "valueOf"(arg0: string): $Writer$FieldOrder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Writer$FieldOrder$Type = (("ascending") | ("descending")) | ($Writer$FieldOrder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Writer$FieldOrder_ = $Writer$FieldOrder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues" {
import {$SparkProtos$RollingAverageValuesOrBuilder, $SparkProtos$RollingAverageValuesOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValuesOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$RollingAverageValues$Builder, $SparkProtos$RollingAverageValues$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$RollingAverageValues extends $GeneratedMessageLite<($SparkProtos$RollingAverageValues), ($SparkProtos$RollingAverageValues$Builder)> implements $SparkProtos$RollingAverageValuesOrBuilder {
static readonly "MEAN_FIELD_NUMBER": integer
static readonly "MAX_FIELD_NUMBER": integer
static readonly "MIN_FIELD_NUMBER": integer
static readonly "MEDIAN_FIELD_NUMBER": integer
static readonly "PERCENTILE95_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$RollingAverageValues)>
public "getMin"(): double
public "getMax"(): double
public static "newBuilder"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$RollingAverageValues$Builder
public static "newBuilder"(): $SparkProtos$RollingAverageValues$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$RollingAverageValues
public static "getDefaultInstance"(): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$RollingAverageValues
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$RollingAverageValues
public "getMean"(): double
public "getMedian"(): double
public "getPercentile95"(): double
get "min"(): double
get "max"(): double
get "defaultInstance"(): $SparkProtos$RollingAverageValues
get "mean"(): double
get "median"(): double
get "percentile95"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$RollingAverageValues$Type = ($SparkProtos$RollingAverageValues);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$RollingAverageValues_ = $SparkProtos$RollingAverageValues$Type;
}}
declare module "packages/me/lucko/spark/common/platform/serverconfig/$ServerConfigProvider" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ServerConfigProvider implements $MetadataProvider {


public "get"(): $Map<(string), ($JsonElement)>
public "export"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerConfigProvider$Type = ($ServerConfigProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerConfigProvider_ = $ServerConfigProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FloatArrayList" {
import {$Internal$FloatList, $Internal$FloatList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$FloatList"
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PrimitiveNonBoxingCollection, $PrimitiveNonBoxingCollection$Type} from "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"

export class $FloatArrayList extends $AbstractProtobufList<(float)> implements $Internal$FloatList, $RandomAccess, $PrimitiveNonBoxingCollection {


public "add"(arg0: float): boolean
public "add"(arg0: integer, arg1: float): void
public "remove"(arg0: integer): float
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "getFloat"(arg0: integer): float
public "size"(): integer
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: float): float
public static "emptyList"(): $FloatArrayList
public "setFloat"(arg0: integer, arg1: float): float
public "addFloat"(arg0: float): void
public "mutableCopyWithCapacity"(arg0: integer): $Internal$FloatList
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(float)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float): $List<(float)>
public static "of"<E>(arg0: float): $List<(float)>
public static "of"<E>(): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): $List<(float)>
public static "of"<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): $List<(float)>
public static "of"<E>(...arg0: (float)[]): $List<(float)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatArrayList$Type = ($FloatArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatArrayList_ = $FloatArrayList$Type;
}}
declare module "packages/me/lucko/spark/common/util/$TemporaryFiles" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$FileAttribute, $FileAttribute$Type} from "packages/java/nio/file/attribute/$FileAttribute"

export class $TemporaryFiles {
static readonly "OWNER_ONLY_FILE_PERMISSIONS": ($FileAttribute<(any)>)[]

constructor(arg0: $Path$Type)

public "register"(arg0: $Path$Type): $Path
public "create"(arg0: string, arg1: string): $Path
public "deleteTemporaryFiles"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TemporaryFiles$Type = ($TemporaryFiles);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TemporaryFiles_ = $TemporaryFiles$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$WorldOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$WorldStatistics$Region, $SparkProtos$WorldStatistics$Region$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region"

export interface $SparkProtos$WorldStatistics$WorldOrBuilder extends $MessageLiteOrBuilder {

 "getRegionsList"(): $List<($SparkProtos$WorldStatistics$Region)>
 "getRegionsCount"(): integer
 "getName"(): string
 "getNameBytes"(): $ByteString
 "getRegions"(arg0: integer): $SparkProtos$WorldStatistics$Region
 "getTotalEntities"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$WorldStatistics$WorldOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$WorldOrBuilder$Type = ($SparkProtos$WorldStatistics$WorldOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$WorldOrBuilder_ = $SparkProtos$WorldStatistics$WorldOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$CountMap" {
import {$AtomicInteger, $AtomicInteger$Type} from "packages/java/util/concurrent/atomic/$AtomicInteger"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $CountMap<T> {

 "add"(arg0: T, arg1: integer): void
 "increment"(arg0: T): void
 "total"(): $AtomicInteger
 "asMap"(): $Map<(T), ($AtomicInteger)>
}

export namespace $CountMap {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CountMap$Type<T> = ($CountMap<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CountMap_<T> = $CountMap$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Paginator" {
import {$ObjIntConsumer, $ObjIntConsumer$Type} from "packages/java/util/function/$ObjIntConsumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export interface $Paginator {

}

export namespace $Paginator {
function forEachPageEntry<T>(content: $Collection$Type<(any)>, pageSize: integer, page: integer, consumer: $ObjIntConsumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Paginator$Type = ($Paginator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Paginator_ = $Paginator$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Handler" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Handler {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Handler$Type = ($Handler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Handler_ = $Handler$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$WebSocketServer$WebSocketWorker" {
import {$WebSocketServer, $WebSocketServer$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/server/$WebSocketServer"
import {$WebSocketImpl, $WebSocketImpl$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl"
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"

export class $WebSocketServer$WebSocketWorker extends $Thread {
static readonly "MIN_PRIORITY": integer
static readonly "NORM_PRIORITY": integer
static readonly "MAX_PRIORITY": integer

constructor(arg0: $WebSocketServer$Type)

public "run"(): void
public "put"(arg0: $WebSocketImpl$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServer$WebSocketWorker$Type = ($WebSocketServer$WebSocketWorker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServer$WebSocketWorker_ = $WebSocketServer$WebSocketWorker$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/aggregator/$AbstractDataAggregator" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"
import {$DataAggregator, $DataAggregator$Type} from "packages/me/lucko/spark/common/sampler/aggregator/$DataAggregator"

export class $AbstractDataAggregator implements $DataAggregator {


public "pruneData"(arg0: $IntPredicate$Type): void
public "exportData"(): $List<($ThreadNode)>
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "metadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractDataAggregator$Type = ($AbstractDataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractDataAggregator_ = $AbstractDataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt32Value" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$UInt32Value$Builder, $UInt32Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt32Value$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$UInt32ValueOrBuilder, $UInt32ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt32ValueOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $UInt32Value extends $GeneratedMessageLite<($UInt32Value), ($UInt32Value$Builder)> implements $UInt32ValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): integer
public static "of"(arg0: integer): $UInt32Value
public static "parser"(): $Parser<($UInt32Value)>
public static "newBuilder"(arg0: $UInt32Value$Type): $UInt32Value$Builder
public static "newBuilder"(): $UInt32Value$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt32Value
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $UInt32Value
public static "getDefaultInstance"(): $UInt32Value
public static "parseFrom"(arg0: $ByteString$Type): $UInt32Value
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $UInt32Value
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $UInt32Value
public static "parseFrom"(arg0: $ByteBuffer$Type): $UInt32Value
public static "parseFrom"(arg0: $CodedInputStream$Type): $UInt32Value
public static "parseFrom"(arg0: $InputStream$Type): $UInt32Value
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt32Value
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $UInt32Value
public static "parseFrom"(arg0: (byte)[]): $UInt32Value
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt32Value
get "value"(): integer
get "defaultInstance"(): $UInt32Value
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt32Value$Type = ($UInt32Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt32Value_ = $UInt32Value$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$AbstractTickHook" {
import {$TickHook$Callback, $TickHook$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickHook$Callback"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"

export class $AbstractTickHook implements $TickHook {

constructor()

public "getCurrentTick"(): integer
public "removeCallback"(arg0: $TickHook$Callback$Type): void
public "addCallback"(arg0: $TickHook$Callback$Type): void
public "start"(): void
public "close"(): void
get "currentTick"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractTickHook$Type = ($AbstractTickHook);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractTickHook_ = $AbstractTickHook$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder extends $MessageLiteOrBuilder {

 "getTotal"(): long
 "getUsed"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder$Type = ($SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder_ = $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt$Builder" {
import {$SparkProtos$PlatformStatistics$Mspt, $SparkProtos$PlatformStatistics$Mspt$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$RollingAverageValues$Builder, $SparkProtos$RollingAverageValues$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues$Builder"
import {$SparkProtos$PlatformStatistics$MsptOrBuilder, $SparkProtos$PlatformStatistics$MsptOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MsptOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"

export class $SparkProtos$PlatformStatistics$Mspt$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Mspt), ($SparkProtos$PlatformStatistics$Mspt$Builder)> implements $SparkProtos$PlatformStatistics$MsptOrBuilder {


public "setLast1M"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public "setLast1M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public "setLast5M"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public "setLast5M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public "clearLast1M"(): $SparkProtos$PlatformStatistics$Mspt$Builder
public "clearLast5M"(): $SparkProtos$PlatformStatistics$Mspt$Builder
public "getLast5M"(): $SparkProtos$RollingAverageValues
public "getLast1M"(): $SparkProtos$RollingAverageValues
public "hasLast1M"(): boolean
public "mergeLast1M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public "hasLast5M"(): boolean
public "mergeLast5M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
set "last1M"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "last1M"(value: $SparkProtos$RollingAverageValues$Type)
set "last5M"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "last5M"(value: $SparkProtos$RollingAverageValues$Type)
get "last5M"(): $SparkProtos$RollingAverageValues
get "last1M"(): $SparkProtos$RollingAverageValues
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Mspt$Builder$Type = ($SparkProtos$PlatformStatistics$Mspt$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Mspt$Builder_ = $SparkProtos$PlatformStatistics$Mspt$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$SSLSession, $SSLSession$Type} from "packages/javax/net/ssl/$SSLSession"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IProtocol, $IProtocol$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ReadyState, $ReadyState$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$ReadyState"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export interface $WebSocket {

 "isOpen"(): boolean
 "close"(): void
 "close"(arg0: integer): void
 "close"(arg0: integer, arg1: string): void
 "getProtocol"(): $IProtocol
 "isClosed"(): boolean
 "getSSLSession"(): $SSLSession
 "getRemoteSocketAddress"(): $InetSocketAddress
 "getLocalSocketAddress"(): $InetSocketAddress
 "isClosing"(): boolean
 "send"(arg0: $ByteBuffer$Type): void
 "send"(arg0: (byte)[]): void
 "send"(arg0: string): void
 "setAttachment"<T>(arg0: T): void
 "closeConnection"(arg0: integer, arg1: string): void
 "sendFrame"(arg0: $Collection$Type<($Framedata$Type)>): void
 "sendFrame"(arg0: $Framedata$Type): void
 "sendFragmentedFrame"(arg0: $Opcode$Type, arg1: $ByteBuffer$Type, arg2: boolean): void
 "getResourceDescriptor"(): string
 "getAttachment"<T>(): T
 "sendPing"(): void
 "getDraft"(): $Draft
 "getReadyState"(): $ReadyState
 "hasSSLSupport"(): boolean
 "hasBufferedData"(): boolean
 "isFlushAndClose"(): boolean
}

export namespace $WebSocket {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocket$Type = ($WebSocket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocket_ = $WebSocket$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$BaseTickCounter" {
import {$WindowStatisticsCollector$TickCounter, $WindowStatisticsCollector$TickCounter$Type} from "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$TickCounter"

export class $WindowStatisticsCollector$BaseTickCounter implements $WindowStatisticsCollector$TickCounter {


public "stop"(): void
public "getTotalTicks"(): integer
public "getCountedTicksThisWindowAndReset"(): integer
get "totalTicks"(): integer
get "countedTicksThisWindowAndReset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowStatisticsCollector$BaseTickCounter$Type = ($WindowStatisticsCollector$BaseTickCounter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowStatisticsCollector$BaseTickCounter_ = $WindowStatisticsCollector$BaseTickCounter$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $TextComponent$Builder extends $ComponentBuilder<($TextComponent), ($TextComponent$Builder)> {

 "content"(): string
 "content"(content: string): $TextComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $TextComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $TextComponent$Builder
 "append"(...components: ($Component$Type)[]): $TextComponent$Builder
 "append"(component: $Component$Type): $TextComponent$Builder
 "append"(component: $ComponentLike$Type): $TextComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TextComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $TextComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $TextComponent$Builder
 "style"(style: $Style$Type): $TextComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $TextComponent$Builder
 "mergeStyle"(that: $Component$Type): $TextComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TextComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TextComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $TextComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $TextComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $TextComponent$Builder
 "resetStyle"(): $TextComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $TextComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TextComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $TextComponent$Builder
 "font"(font: $Key$Type): $TextComponent$Builder
 "appendSpace"(): $TextComponent$Builder
 "insertion"(insertion: string): $TextComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $TextComponent$Builder
}

export namespace $TextComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $TextComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponent$Builder$Type = ($TextComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponent$Builder_ = $TextComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyFormat" {
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"

export class $LegacyFormat implements $Examinable {


public "equals"(other: any): boolean
public "hashCode"(): integer
public "reset"(): boolean
public "color"(): $TextColor
public "examinableProperties"(): $Stream<(any)>
public "decoration"(): $TextDecoration
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyFormat$Type = ($LegacyFormat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyFormat_ = $LegacyFormat$Type;
}}
declare module "packages/me/lucko/spark/common/util/$BytebinClient$Content" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $BytebinClient$Content {


public "key"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytebinClient$Content$Type = ($BytebinClient$Content);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytebinClient$Content_ = $BytebinClient$Content$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Builder" {
import {$SparkProtos$WorldStatistics$World$Builder, $SparkProtos$WorldStatistics$World$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$WorldStatisticsOrBuilder, $SparkProtos$WorldStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatisticsOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkProtos$WorldStatistics, $SparkProtos$WorldStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$SparkProtos$WorldStatistics$World, $SparkProtos$WorldStatistics$World$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World"

export class $SparkProtos$WorldStatistics$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$WorldStatistics), ($SparkProtos$WorldStatistics$Builder)> implements $SparkProtos$WorldStatisticsOrBuilder {


public "putAllEntityCounts"(arg0: $Map$Type<(string), (integer)>): $SparkProtos$WorldStatistics$Builder
public "removeEntityCounts"(arg0: string): $SparkProtos$WorldStatistics$Builder
public "clearEntityCounts"(): $SparkProtos$WorldStatistics$Builder
public "containsEntityCounts"(arg0: string): boolean
public "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
public "getEntityCountsCount"(): integer
public "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
public "getEntityCounts"(): $Map<(string), (integer)>
public "setWorlds"(arg0: integer, arg1: $SparkProtos$WorldStatistics$World$Type): $SparkProtos$WorldStatistics$Builder
public "setWorlds"(arg0: integer, arg1: $SparkProtos$WorldStatistics$World$Builder$Type): $SparkProtos$WorldStatistics$Builder
public "getWorldsCount"(): integer
public "addAllWorlds"(arg0: $Iterable$Type<(any)>): $SparkProtos$WorldStatistics$Builder
public "getWorldsList"(): $List<($SparkProtos$WorldStatistics$World)>
public "getEntityCountsMap"(): $Map<(string), (integer)>
public "clearTotalEntities"(): $SparkProtos$WorldStatistics$Builder
public "clearWorlds"(): $SparkProtos$WorldStatistics$Builder
public "removeWorlds"(arg0: integer): $SparkProtos$WorldStatistics$Builder
public "getWorlds"(arg0: integer): $SparkProtos$WorldStatistics$World
public "setTotalEntities"(arg0: integer): $SparkProtos$WorldStatistics$Builder
public "putEntityCounts"(arg0: string, arg1: integer): $SparkProtos$WorldStatistics$Builder
public "getTotalEntities"(): integer
public "addWorlds"(arg0: $SparkProtos$WorldStatistics$World$Type): $SparkProtos$WorldStatistics$Builder
public "addWorlds"(arg0: integer, arg1: $SparkProtos$WorldStatistics$World$Type): $SparkProtos$WorldStatistics$Builder
public "addWorlds"(arg0: $SparkProtos$WorldStatistics$World$Builder$Type): $SparkProtos$WorldStatistics$Builder
public "addWorlds"(arg0: integer, arg1: $SparkProtos$WorldStatistics$World$Builder$Type): $SparkProtos$WorldStatistics$Builder
get "entityCountsCount"(): integer
get "entityCounts"(): $Map<(string), (integer)>
get "worldsCount"(): integer
get "worldsList"(): $List<($SparkProtos$WorldStatistics$World)>
get "entityCountsMap"(): $Map<(string), (integer)>
set "totalEntities"(value: integer)
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Builder$Type = ($SparkProtos$WorldStatistics$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$Builder_ = $SparkProtos$WorldStatistics$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DoubleValue$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$DoubleValue, $DoubleValue$Type} from "packages/me/lucko/spark/lib/protobuf/$DoubleValue"
import {$DoubleValueOrBuilder, $DoubleValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$DoubleValueOrBuilder"

export class $DoubleValue$Builder extends $GeneratedMessageLite$Builder<($DoubleValue), ($DoubleValue$Builder)> implements $DoubleValueOrBuilder {


public "getValue"(): double
public "setValue"(arg0: double): $DoubleValue$Builder
public "clearValue"(): $DoubleValue$Builder
get "value"(): double
set "value"(value: double)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleValue$Builder$Type = ($DoubleValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleValue$Builder_ = $DoubleValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/platform/$MetadataProvider" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $MetadataProvider {

 "get"(): $Map<(string), ($JsonElement)>
 "export"(): $Map<(string), (string)>

(): $Map<(string), ($JsonElement)>
}

export namespace $MetadataProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MetadataProvider$Type = ($MetadataProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MetadataProvider_ = $MetadataProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AnyProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $AnyProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyProto$Type = ($AnyProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnyProto_ = $AnyProto$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/internal/properties/$AdventureProperties" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AdventureProperties$Property, $AdventureProperties$Property$Type} from "packages/me/lucko/spark/lib/adventure/internal/properties/$AdventureProperties$Property"

export class $AdventureProperties {
static readonly "DEBUG": $AdventureProperties$Property<(boolean)>
static readonly "DEFAULT_TRANSLATION_LOCALE": $AdventureProperties$Property<(string)>
static readonly "SERVICE_LOAD_FAILURES_ARE_FATAL": $AdventureProperties$Property<(boolean)>
static readonly "TEXT_WARN_WHEN_LEGACY_FORMATTING_DETECTED": $AdventureProperties$Property<(boolean)>


public static "property"<T>(name: string, parser: $Function$Type<(string), (T)>, defaultValue: T): $AdventureProperties$Property<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdventureProperties$Type = ($AdventureProperties);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdventureProperties_ = $AdventureProperties$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$RecordComponentVisitor" {
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $RecordComponentVisitor {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $RecordComponentVisitor$Type)

public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
public "getDelegate"(): $RecordComponentVisitor
get "delegate"(): $RecordComponentVisitor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordComponentVisitor$Type = ($RecordComponentVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordComponentVisitor_ = $RecordComponentVisitor$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder" {
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder, $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder"

export class $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SamplerMetadata$ThreadDumper), ($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder)> implements $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder {


public "getIdsList"(): $List<(long)>
public "addAllPatterns"(arg0: $Iterable$Type<(string)>): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "getPatternsList"(): $List<(string)>
public "getPatternsBytes"(arg0: integer): $ByteString
public "setIds"(arg0: integer, arg1: long): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "addIds"(arg0: long): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "getIdsCount"(): integer
public "addPatterns"(arg0: string): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "addPatternsBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "clearPatterns"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "getPatternsCount"(): integer
public "clearIds"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "getType"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
public "setType"(arg0: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "addAllIds"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "getIds"(arg0: integer): long
public "getTypeValue"(): integer
public "getPatterns"(arg0: integer): string
public "setPatterns"(arg0: integer, arg1: string): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "clearType"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public "setTypeValue"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
get "idsList"(): $List<(long)>
get "patternsList"(): $List<(string)>
get "idsCount"(): integer
get "patternsCount"(): integer
get "type"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
set "type"(value: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type)
get "typeValue"(): integer
set "typeValue"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type = ($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder_ = $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory" {
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$PlatformStatistics$MemoryOrBuilder, $SparkProtos$PlatformStatistics$MemoryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MemoryOrBuilder"
import {$SparkProtos$PlatformStatistics$Memory$Builder, $SparkProtos$PlatformStatistics$Memory$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$Builder"

export class $SparkProtos$PlatformStatistics$Memory extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Memory), ($SparkProtos$PlatformStatistics$Memory$Builder)> implements $SparkProtos$PlatformStatistics$MemoryOrBuilder {
static readonly "HEAP_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Memory)>
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Memory$Builder
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Memory$Type): $SparkProtos$PlatformStatistics$Memory$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Memory
public "hasHeap"(): boolean
public "getHeap"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Memory
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Memory
get "heap"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Memory$Type = ($SparkProtos$PlatformStatistics$Memory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Memory_ = $SparkProtos$PlatformStatistics$Memory$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BoolValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $BoolValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $BoolValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoolValueOrBuilder$Type = ($BoolValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoolValueOrBuilder_ = $BoolValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FloatValue$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$FloatValue, $FloatValue$Type} from "packages/me/lucko/spark/lib/protobuf/$FloatValue"
import {$FloatValueOrBuilder, $FloatValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FloatValueOrBuilder"

export class $FloatValue$Builder extends $GeneratedMessageLite$Builder<($FloatValue), ($FloatValue$Builder)> implements $FloatValueOrBuilder {


public "getValue"(): float
public "setValue"(arg0: float): $FloatValue$Builder
public "clearValue"(): $FloatValue$Builder
get "value"(): float
set "value"(value: float)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatValue$Builder$Type = ($FloatValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatValue$Builder_ = $FloatValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/$StatisticWindow$MillisPerTick" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export class $StatisticWindow$MillisPerTick extends $Enum<($StatisticWindow$MillisPerTick)> implements $StatisticWindow {
static readonly "SECONDS_10": $StatisticWindow$MillisPerTick
static readonly "MINUTES_1": $StatisticWindow$MillisPerTick
static readonly "MINUTES_5": $StatisticWindow$MillisPerTick


public "length"(): $Duration
public static "values"(): ($StatisticWindow$MillisPerTick)[]
public static "valueOf"(arg0: string): $StatisticWindow$MillisPerTick
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatisticWindow$MillisPerTick$Type = (("minutes_5") | ("minutes_1") | ("seconds_10")) | ($StatisticWindow$MillisPerTick);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatisticWindow$MillisPerTick_ = $StatisticWindow$MillisPerTick$Type;
}}
declare module "packages/me/lucko/spark/common/command/tabcomplete/$TabCompleter" {
import {$CompletionSupplier, $CompletionSupplier$Type} from "packages/me/lucko/spark/common/command/tabcomplete/$CompletionSupplier"
import {$List, $List$Type} from "packages/java/util/$List"

export class $TabCompleter {


public "from"(arg0: integer, arg1: $CompletionSupplier$Type): $TabCompleter
public "at"(arg0: integer, arg1: $CompletionSupplier$Type): $TabCompleter
public static "create"(): $TabCompleter
public "complete"(arg0: $List$Type<(string)>): $List<(string)>
public static "completeForOpts"(arg0: $List$Type<(string)>, ...arg1: (string)[]): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TabCompleter$Type = ($TabCompleter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TabCompleter_ = $TabCompleter$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PatternReplacementResult extends $Enum<($PatternReplacementResult)> {
static readonly "REPLACE": $PatternReplacementResult
static readonly "CONTINUE": $PatternReplacementResult
static readonly "STOP": $PatternReplacementResult


public static "values"(): ($PatternReplacementResult)[]
public static "valueOf"(name: string): $PatternReplacementResult
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PatternReplacementResult$Type = (("stop") | ("continue") | ("replace")) | ($PatternReplacementResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PatternReplacementResult_ = $PatternReplacementResult$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidHandshakeException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$InvalidDataException, $InvalidDataException$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidDataException"

export class $InvalidHandshakeException extends $InvalidDataException {

constructor(arg0: $Throwable$Type)
constructor(arg0: string)
constructor(arg0: string, arg1: $Throwable$Type)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidHandshakeException$Type = ($InvalidHandshakeException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidHandshakeException_ = $InvalidHandshakeException$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $EntityNBTComponent$Builder extends $NBTComponentBuilder<($EntityNBTComponent), ($EntityNBTComponent$Builder)> {

 "selector"(selector: string): $EntityNBTComponent$Builder
 "separator"(separator: $ComponentLike$Type): $EntityNBTComponent$Builder
 "nbtPath"(nbtPath: string): $EntityNBTComponent$Builder
 "interpret"(interpret: boolean): $EntityNBTComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $EntityNBTComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $EntityNBTComponent$Builder
 "append"(...components: ($Component$Type)[]): $EntityNBTComponent$Builder
 "append"(component: $Component$Type): $EntityNBTComponent$Builder
 "append"(component: $ComponentLike$Type): $EntityNBTComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $EntityNBTComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $EntityNBTComponent$Builder
 "style"(style: $Style$Type): $EntityNBTComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $EntityNBTComponent$Builder
 "mergeStyle"(that: $Component$Type): $EntityNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $EntityNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $EntityNBTComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $EntityNBTComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $EntityNBTComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $EntityNBTComponent$Builder
 "resetStyle"(): $EntityNBTComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $EntityNBTComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $EntityNBTComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $EntityNBTComponent$Builder
 "font"(font: $Key$Type): $EntityNBTComponent$Builder
 "appendSpace"(): $EntityNBTComponent$Builder
 "insertion"(insertion: string): $EntityNBTComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $EntityNBTComponent$Builder
}

export namespace $EntityNBTComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityNBTComponent$Builder$Type = ($EntityNBTComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityNBTComponent$Builder_ = $EntityNBTComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Frame" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Frame {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Frame$Type = ($Frame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Frame_ = $Frame$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BytesValue" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$BytesValue$Builder, $BytesValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$BytesValue$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$BytesValueOrBuilder, $BytesValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$BytesValueOrBuilder"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $BytesValue extends $GeneratedMessageLite<($BytesValue), ($BytesValue$Builder)> implements $BytesValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): $ByteString
public static "of"(arg0: $ByteString$Type): $BytesValue
public static "parser"(): $Parser<($BytesValue)>
public static "newBuilder"(arg0: $BytesValue$Type): $BytesValue$Builder
public static "newBuilder"(): $BytesValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $BytesValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $BytesValue
public static "getDefaultInstance"(): $BytesValue
public static "parseFrom"(arg0: $ByteString$Type): $BytesValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $BytesValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $BytesValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $BytesValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $BytesValue
public static "parseFrom"(arg0: $InputStream$Type): $BytesValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $BytesValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $BytesValue
public static "parseFrom"(arg0: (byte)[]): $BytesValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $BytesValue
get "value"(): $ByteString
get "defaultInstance"(): $BytesValue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesValue$Type = ($BytesValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesValue_ = $BytesValue$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder, $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool, $SparkProtos$SystemStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool"

export class $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Memory$MemoryPool), ($SparkProtos$SystemStatistics$Memory$MemoryPool$Builder)> implements $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder {


public "getTotal"(): long
public "clearTotal"(): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
public "clearUsed"(): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
public "getUsed"(): long
public "setUsed"(arg0: long): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
public "setTotal"(arg0: long): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
get "total"(): long
get "used"(): long
set "used"(value: long)
set "total"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type = ($SparkProtos$SystemStatistics$Memory$MemoryPool$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder_ = $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$MutableStyleSetter" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$StyleSetter, $StyleSetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleSetter"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"

export interface $MutableStyleSetter<T extends $MutableStyleSetter<(any)>> extends $StyleSetter<(T)> {

 "decorate"(...decorations: ($TextDecoration$Type)[]): T
 "color"(color: $TextColor$Type): T
 "colorIfAbsent"(color: $TextColor$Type): T
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): T
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): T
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): T
 "decorate"(decoration: $TextDecoration$Type): T
 "font"(font: $Key$Type): T
 "insertion"(insertion: string): T
 "clickEvent"(event: $ClickEvent$Type): T
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): T
}

export namespace $MutableStyleSetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutableStyleSetter$Type<T> = ($MutableStyleSetter<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutableStyleSetter_<T> = $MutableStyleSetter$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent" {
import {$Instrumentation, $Instrumentation$Type} from "packages/java/lang/instrument/$Instrumentation"
import {$ByteBuddyAgent$AttachmentProvider, $ByteBuddyAgent$AttachmentProvider$Type} from "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider"
import {$File, $File$Type} from "packages/java/io/$File"
import {$ByteBuddyAgent$ProcessProvider, $ByteBuddyAgent$ProcessProvider$Type} from "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$ProcessProvider"

export class $ByteBuddyAgent {
static readonly "LATENT_RESOLVE": string


public static "attach"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type): void
public static "attach"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: string): void
public static "attach"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attach"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: string, arg3: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attach"(arg0: $File$Type, arg1: string): void
public static "attach"(arg0: $File$Type, arg1: string, arg2: string): void
public static "attach"(arg0: $File$Type, arg1: string, arg2: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attach"(arg0: $File$Type, arg1: string, arg2: string, arg3: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "install"(arg0: $ByteBuddyAgent$AttachmentProvider$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type): $Instrumentation
public static "install"(): $Instrumentation
public static "install"(arg0: $ByteBuddyAgent$AttachmentProvider$Type): $Instrumentation
public static "install"(arg0: $ByteBuddyAgent$ProcessProvider$Type): $Instrumentation
public static "attachNative"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: string): void
public static "attachNative"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type): void
public static "attachNative"(arg0: $File$Type, arg1: string): void
public static "attachNative"(arg0: $File$Type, arg1: string, arg2: string, arg3: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attachNative"(arg0: $File$Type, arg1: string, arg2: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attachNative"(arg0: $File$Type, arg1: string, arg2: string): void
public static "attachNative"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "attachNative"(arg0: $File$Type, arg1: $ByteBuddyAgent$ProcessProvider$Type, arg2: string, arg3: $ByteBuddyAgent$AttachmentProvider$Type): void
public static "getInstrumentation"(): $Instrumentation
get "instrumentation"(): $Instrumentation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBuddyAgent$Type = ($ByteBuddyAgent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBuddyAgent_ = $ByteBuddyAgent$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldMask" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$FieldMaskOrBuilder, $FieldMaskOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldMaskOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$FieldMask$Builder, $FieldMask$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldMask$Builder"

export class $FieldMask extends $GeneratedMessageLite<($FieldMask), ($FieldMask$Builder)> implements $FieldMaskOrBuilder {
static readonly "PATHS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($FieldMask)>
public static "newBuilder"(arg0: $FieldMask$Type): $FieldMask$Builder
public static "newBuilder"(): $FieldMask$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $FieldMask
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "getDefaultInstance"(): $FieldMask
public "getPaths"(arg0: integer): string
public "getPathsList"(): $List<(string)>
public "getPathsBytes"(arg0: integer): $ByteString
public "getPathsCount"(): integer
public static "parseFrom"(arg0: $InputStream$Type): $FieldMask
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "parseFrom"(arg0: $ByteString$Type): $FieldMask
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "parseFrom"(arg0: $ByteBuffer$Type): $FieldMask
public static "parseFrom"(arg0: $CodedInputStream$Type): $FieldMask
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $FieldMask
public static "parseFrom"(arg0: (byte)[]): $FieldMask
get "defaultInstance"(): $FieldMask
get "pathsList"(): $List<(string)>
get "pathsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldMask$Type = ($FieldMask);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldMask_ = $FieldMask$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StructuralMessageInfo" {
import {$FieldInfo, $FieldInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldInfo"
import {$ProtoSyntax, $ProtoSyntax$Type} from "packages/me/lucko/spark/lib/protobuf/$ProtoSyntax"
import {$StructuralMessageInfo$Builder, $StructuralMessageInfo$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$StructuralMessageInfo$Builder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$MessageInfo, $MessageInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageInfo"

export class $StructuralMessageInfo implements $MessageInfo {


public "isMessageSetWireFormat"(): boolean
public "getCheckInitialized"(): (integer)[]
public "getFields"(): ($FieldInfo)[]
public static "newBuilder"(arg0: integer): $StructuralMessageInfo$Builder
public static "newBuilder"(): $StructuralMessageInfo$Builder
public "getSyntax"(): $ProtoSyntax
public "getDefaultInstance"(): $MessageLite
get "messageSetWireFormat"(): boolean
get "checkInitialized"(): (integer)[]
get "fields"(): ($FieldInfo)[]
get "syntax"(): $ProtoSyntax
get "defaultInstance"(): $MessageLite
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructuralMessageInfo$Type = ($StructuralMessageInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructuralMessageInfo_ = $StructuralMessageInfo$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/$MonitoringExecutor" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$ScheduledExecutorService, $ScheduledExecutorService$Type} from "packages/java/util/concurrent/$ScheduledExecutorService"

export class $MonitoringExecutor extends $Enum<($MonitoringExecutor)> {
static readonly "INSTANCE": $ScheduledExecutorService


public static "values"(): ($MonitoringExecutor)[]
public static "valueOf"(arg0: string): $MonitoringExecutor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MonitoringExecutor$Type = (never) | ($MonitoringExecutor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MonitoringExecutor_ = $MonitoringExecutor$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ValueOrBuilder" {
import {$Struct, $Struct$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ListValue, $ListValue$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$NullValue, $NullValue$Type} from "packages/me/lucko/spark/lib/protobuf/$NullValue"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Value$KindCase, $Value$KindCase$Type} from "packages/me/lucko/spark/lib/protobuf/$Value$KindCase"

export interface $ValueOrBuilder extends $MessageLiteOrBuilder {

 "getStringValueBytes"(): $ByteString
 "hasStringValue"(): boolean
 "getStringValue"(): string
 "getNumberValue"(): double
 "hasStructValue"(): boolean
 "getNullValueValue"(): integer
 "hasNumberValue"(): boolean
 "getKindCase"(): $Value$KindCase
 "getStructValue"(): $Struct
 "hasBoolValue"(): boolean
 "hasListValue"(): boolean
 "getBoolValue"(): boolean
 "getNullValue"(): $NullValue
 "getListValue"(): $ListValue
 "hasNullValue"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $ValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ValueOrBuilder$Type = ($ValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ValueOrBuilder_ = $ValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Utf8" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Utf8 {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Utf8$Type = ($Utf8);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Utf8_ = $Utf8$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$IncompleteException" {
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $IncompleteException extends $Exception {

constructor(arg0: integer)

public "getPreferredSize"(): integer
get "preferredSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IncompleteException$Type = ($IncompleteException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IncompleteException_ = $IncompleteException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldMaskOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $FieldMaskOrBuilder extends $MessageLiteOrBuilder {

 "getPaths"(arg0: integer): string
 "getPathsList"(): $List<(string)>
 "getPathsBytes"(arg0: integer): $ByteString
 "getPathsCount"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $FieldMaskOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldMaskOrBuilder$Type = ($FieldMaskOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldMaskOrBuilder_ = $FieldMaskOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$NamedTextColor" {
import {$HSVLike, $HSVLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$HSVLike"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$RGBLike, $RGBLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$RGBLike"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"

export class $NamedTextColor implements $TextColor {
static readonly "BLACK": $NamedTextColor
static readonly "DARK_BLUE": $NamedTextColor
static readonly "DARK_GREEN": $NamedTextColor
static readonly "DARK_AQUA": $NamedTextColor
static readonly "DARK_RED": $NamedTextColor
static readonly "DARK_PURPLE": $NamedTextColor
static readonly "GOLD": $NamedTextColor
static readonly "GRAY": $NamedTextColor
static readonly "DARK_GRAY": $NamedTextColor
static readonly "BLUE": $NamedTextColor
static readonly "GREEN": $NamedTextColor
static readonly "AQUA": $NamedTextColor
static readonly "RED": $NamedTextColor
static readonly "LIGHT_PURPLE": $NamedTextColor
static readonly "YELLOW": $NamedTextColor
static readonly "WHITE": $NamedTextColor
static readonly "NAMES": $Index<(string), ($NamedTextColor)>


public "value"(): integer
public "toString"(): string
public "examinableProperties"(): $Stream<(any)>
/**
 * 
 * @deprecated
 */
public static "ofExact"(value: integer): $NamedTextColor
public static "nearestTo"(any: $TextColor$Type): $NamedTextColor
public static "namedColor"(value: integer): $NamedTextColor
public "asHSV"(): $HSVLike
public "compareTo"(that: $TextColor$Type): integer
public static "color"(r: float, g: float, b: float): $TextColor
public static "color"(value: integer): $TextColor
public static "color"(rgb: $RGBLike$Type): $TextColor
public static "color"(r: integer, g: integer, b: integer): $TextColor
public static "color"(hsv: $HSVLike$Type): $TextColor
public "red"(): integer
public static "fromCSSHexString"(string: string): $TextColor
public "asHexString"(): string
public static "fromHexString"(string: string): $TextColor
public "styleApply"(style: $Style$Builder$Type): void
public "blue"(): integer
public "green"(): integer
public static "lerp"(t: float, a: $RGBLike$Type, b: $RGBLike$Type): $TextColor
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedTextColor$Type = ($NamedTextColor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedTextColor_ = $NamedTextColor$Type;
}}
declare module "packages/me/lucko/spark/common/platform/$PlatformInfo" {
import {$PlatformInfo$Data, $PlatformInfo$Data$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo$Data"
import {$PlatformInfo$Type, $PlatformInfo$Type$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo$Type"

export interface $PlatformInfo {

 "getName"(): string
 "getType"(): $PlatformInfo$Type
 "getVersion"(): string
 "toData"(): $PlatformInfo$Data
 "getSparkVersion"(): integer
 "getMinecraftVersion"(): string
}

export namespace $PlatformInfo {
const DATA_VERSION: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformInfo$Type = ($PlatformInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformInfo_ = $PlatformInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$NBTComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $NBTComponentImpl<C extends $NBTComponent<(C), (B)>, B extends $NBTComponentBuilder<(C), (B)>> extends $AbstractComponent implements $NBTComponent<(C), (B)> {


public "equals"(other: any): boolean
public "hashCode"(): integer
public "nbtPath"(): string
public "interpret"(): boolean
public "separator"(): $Component
public "separator"(separator: $ComponentLike$Type): C
public "nbtPath"(nbtPath: string): C
public "examinableProperties"(): $Stream<(any)>
public "interpret"(interpret: boolean): C
public "toBuilder"(): B
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: B, consumer: $Consumer$Type<(any)>): C
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTComponentImpl$Type<C, B> = ($NBTComponentImpl<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTComponentImpl_<C, B> = $NBTComponentImpl$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Type$Builder" {
import {$SourceContext$Builder, $SourceContext$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$Type, $Type$Type} from "packages/me/lucko/spark/lib/protobuf/$Type"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Field, $Field$Type} from "packages/me/lucko/spark/lib/protobuf/$Field"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Field$Builder, $Field$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Builder"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"
import {$TypeOrBuilder, $TypeOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$TypeOrBuilder"

export class $Type$Builder extends $GeneratedMessageLite$Builder<($Type), ($Type$Builder)> implements $TypeOrBuilder {


public "setSourceContext"(arg0: $SourceContext$Builder$Type): $Type$Builder
public "setSourceContext"(arg0: $SourceContext$Type): $Type$Builder
public "mergeSourceContext"(arg0: $SourceContext$Type): $Type$Builder
public "clearSourceContext"(): $Type$Builder
public "getFieldsCount"(): integer
public "getOneofsList"(): $List<(string)>
public "getOneofsBytes"(arg0: integer): $ByteString
public "getOneofs"(arg0: integer): string
public "getFieldsList"(): $List<($Field)>
public "getOneofsCount"(): integer
public "getName"(): string
public "getFields"(arg0: integer): $Field
public "setName"(arg0: string): $Type$Builder
public "setFields"(arg0: integer, arg1: $Field$Builder$Type): $Type$Builder
public "setFields"(arg0: integer, arg1: $Field$Type): $Type$Builder
public "getSyntax"(): $Syntax
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: $Option$Builder$Type): $Type$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $Type$Builder
public "addOptions"(arg0: $Option$Type): $Type$Builder
public "addOptions"(arg0: integer, arg1: $Option$Type): $Type$Builder
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $Type$Builder
public "clearOptions"(): $Type$Builder
public "clearSyntax"(): $Type$Builder
public "removeOptions"(arg0: integer): $Type$Builder
public "setSyntaxValue"(arg0: integer): $Type$Builder
public "setSyntax"(arg0: $Syntax$Type): $Type$Builder
public "setNameBytes"(arg0: $ByteString$Type): $Type$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Type$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $Type$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $Type$Builder
public "addFields"(arg0: $Field$Type): $Type$Builder
public "addFields"(arg0: integer, arg1: $Field$Builder$Type): $Type$Builder
public "addFields"(arg0: $Field$Builder$Type): $Type$Builder
public "addFields"(arg0: integer, arg1: $Field$Type): $Type$Builder
public "getSourceContext"(): $SourceContext
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "hasSourceContext"(): boolean
public "getSyntaxValue"(): integer
public "addAllFields"(arg0: $Iterable$Type<(any)>): $Type$Builder
public "clearFields"(): $Type$Builder
public "clearOneofs"(): $Type$Builder
public "removeFields"(arg0: integer): $Type$Builder
public "addOneofsBytes"(arg0: $ByteString$Type): $Type$Builder
public "setOneofs"(arg0: integer, arg1: string): $Type$Builder
public "addAllOneofs"(arg0: $Iterable$Type<(string)>): $Type$Builder
public "addOneofs"(arg0: string): $Type$Builder
set "sourceContext"(value: $SourceContext$Builder$Type)
set "sourceContext"(value: $SourceContext$Type)
get "fieldsCount"(): integer
get "oneofsList"(): $List<(string)>
get "fieldsList"(): $List<($Field)>
get "oneofsCount"(): integer
get "name"(): string
set "name"(value: string)
get "syntax"(): $Syntax
set "syntaxValue"(value: integer)
set "syntax"(value: $Syntax$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "sourceContext"(): $SourceContext
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Type$Builder$Type = ($Type$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Type$Builder_ = $Type$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ArrayDecoders" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ArrayDecoders {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ArrayDecoders$Type = ($ArrayDecoders);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ArrayDecoders_ = $ArrayDecoders$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Enum$Builder" {
import {$SourceContext$Builder, $SourceContext$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext$Builder"
import {$EnumOrBuilder, $EnumOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Enum, $Enum$Type} from "packages/me/lucko/spark/lib/protobuf/$Enum"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$EnumValue, $EnumValue$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue"
import {$EnumValue$Builder, $EnumValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue$Builder"
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Enum$Builder extends $GeneratedMessageLite$Builder<($Enum), ($Enum$Builder)> implements $EnumOrBuilder {


public "clearEnumvalue"(): $Enum$Builder
public "setSourceContext"(arg0: $SourceContext$Type): $Enum$Builder
public "setSourceContext"(arg0: $SourceContext$Builder$Type): $Enum$Builder
public "addAllEnumvalue"(arg0: $Iterable$Type<(any)>): $Enum$Builder
public "removeEnumvalue"(arg0: integer): $Enum$Builder
public "mergeSourceContext"(arg0: $SourceContext$Type): $Enum$Builder
public "addEnumvalue"(arg0: integer, arg1: $EnumValue$Type): $Enum$Builder
public "addEnumvalue"(arg0: $EnumValue$Type): $Enum$Builder
public "addEnumvalue"(arg0: $EnumValue$Builder$Type): $Enum$Builder
public "addEnumvalue"(arg0: integer, arg1: $EnumValue$Builder$Type): $Enum$Builder
public "clearSourceContext"(): $Enum$Builder
public "setEnumvalue"(arg0: integer, arg1: $EnumValue$Type): $Enum$Builder
public "setEnumvalue"(arg0: integer, arg1: $EnumValue$Builder$Type): $Enum$Builder
public "getName"(): string
public "setName"(arg0: string): $Enum$Builder
public "getSyntax"(): $Syntax
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: $Option$Builder$Type): $Enum$Builder
public "addOptions"(arg0: integer, arg1: $Option$Type): $Enum$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $Enum$Builder
public "addOptions"(arg0: $Option$Type): $Enum$Builder
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $Enum$Builder
public "clearOptions"(): $Enum$Builder
public "clearSyntax"(): $Enum$Builder
public "removeOptions"(arg0: integer): $Enum$Builder
public "setSyntaxValue"(arg0: integer): $Enum$Builder
public "setSyntax"(arg0: $Syntax$Type): $Enum$Builder
public "setNameBytes"(arg0: $ByteString$Type): $Enum$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Enum$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $Enum$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $Enum$Builder
public "getSourceContext"(): $SourceContext
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "hasSourceContext"(): boolean
public "getSyntaxValue"(): integer
public "getEnumvalueCount"(): integer
public "getEnumvalue"(arg0: integer): $EnumValue
public "getEnumvalueList"(): $List<($EnumValue)>
set "sourceContext"(value: $SourceContext$Type)
set "sourceContext"(value: $SourceContext$Builder$Type)
get "name"(): string
set "name"(value: string)
get "syntax"(): $Syntax
set "syntaxValue"(value: integer)
set "syntax"(value: $Syntax$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "sourceContext"(): $SourceContext
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
get "enumvalueCount"(): integer
get "enumvalueList"(): $List<($EnumValue)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Enum$Builder$Type = ($Enum$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Enum$Builder_ = $Enum$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeImpl1Server" {
import {$ServerHandshakeBuilder, $ServerHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder"
import {$HandshakedataImpl1, $HandshakedataImpl1$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakedataImpl1"

export class $HandshakeImpl1Server extends $HandshakedataImpl1 implements $ServerHandshakeBuilder {

constructor()

public "setHttpStatus"(arg0: short): void
public "getHttpStatus"(): short
public "setHttpStatusMessage"(arg0: string): void
public "getHttpStatusMessage"(): string
set "httpStatus"(value: short)
get "httpStatus"(): short
set "httpStatusMessage"(value: string)
get "httpStatusMessage"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeImpl1Server$Type = ($HandshakeImpl1Server);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeImpl1Server_ = $HandshakeImpl1Server$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $ComponentIterator implements $Iterator<($Component)> {


public "hasNext"(): boolean
public "remove"(): void
public "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentIterator$Type = ($ComponentIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentIterator_ = $ComponentIterator$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldMask$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$FieldMask, $FieldMask$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldMask"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$FieldMaskOrBuilder, $FieldMaskOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldMaskOrBuilder"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $FieldMask$Builder extends $GeneratedMessageLite$Builder<($FieldMask), ($FieldMask$Builder)> implements $FieldMaskOrBuilder {


public "getPaths"(arg0: integer): string
public "getPathsList"(): $List<(string)>
public "getPathsBytes"(arg0: integer): $ByteString
public "getPathsCount"(): integer
public "addPaths"(arg0: string): $FieldMask$Builder
public "addAllPaths"(arg0: $Iterable$Type<(string)>): $FieldMask$Builder
public "clearPaths"(): $FieldMask$Builder
public "setPaths"(arg0: integer, arg1: string): $FieldMask$Builder
public "addPathsBytes"(arg0: $ByteString$Type): $FieldMask$Builder
get "pathsList"(): $List<(string)>
get "pathsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldMask$Builder$Type = ($FieldMask$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldMask$Builder_ = $FieldMask$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect$Builder" {
import {$SparkWebSocketProtos$ClientConnectOrBuilder, $SparkWebSocketProtos$ClientConnectOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnectOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkWebSocketProtos$ClientConnect, $SparkWebSocketProtos$ClientConnect$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect"

export class $SparkWebSocketProtos$ClientConnect$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ClientConnect), ($SparkWebSocketProtos$ClientConnect$Builder)> implements $SparkWebSocketProtos$ClientConnectOrBuilder {


public "getDescription"(): string
public "setDescription"(arg0: string): $SparkWebSocketProtos$ClientConnect$Builder
public "getClientId"(): string
public "setClientId"(arg0: string): $SparkWebSocketProtos$ClientConnect$Builder
public "clearClientId"(): $SparkWebSocketProtos$ClientConnect$Builder
public "setClientIdBytes"(arg0: $ByteString$Type): $SparkWebSocketProtos$ClientConnect$Builder
public "clearDescription"(): $SparkWebSocketProtos$ClientConnect$Builder
public "getClientIdBytes"(): $ByteString
public "getDescriptionBytes"(): $ByteString
public "setDescriptionBytes"(arg0: $ByteString$Type): $SparkWebSocketProtos$ClientConnect$Builder
get "description"(): string
set "description"(value: string)
get "clientId"(): string
set "clientId"(value: string)
set "clientIdBytes"(value: $ByteString$Type)
get "clientIdBytes"(): $ByteString
get "descriptionBytes"(): $ByteString
set "descriptionBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientConnect$Builder$Type = ($SparkWebSocketProtos$ClientConnect$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientConnect$Builder_ = $SparkWebSocketProtos$ClientConnect$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$NewInstanceSchema" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $NewInstanceSchema {

 "newInstance"(arg0: any): any

(arg0: any): any
}

export namespace $NewInstanceSchema {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NewInstanceSchema$Type = ($NewInstanceSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NewInstanceSchema_ = $NewInstanceSchema$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$ThreadDumper" {
import {$ThreadInfo, $ThreadInfo$Type} from "packages/java/lang/management/$ThreadInfo"
import {$ThreadMXBean, $ThreadMXBean$Type} from "packages/java/lang/management/$ThreadMXBean"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper"

export interface $ThreadDumper {

 "dumpThreads"(arg0: $ThreadMXBean$Type): ($ThreadInfo)[]
 "isThreadIncluded"(arg0: long, arg1: string): boolean
 "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
}

export namespace $ThreadDumper {
const ALL: $ThreadDumper
function parseConfigSetting(arg0: string): $ThreadDumper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadDumper$Type = ($ThreadDumper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadDumper_ = $ThreadDumper$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder, $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder"

export class $SparkSamplerProtos$SamplerMetadata$SourceMetadata extends $GeneratedMessageLite<($SparkSamplerProtos$SamplerMetadata$SourceMetadata), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder)> implements $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "VERSION_FIELD_NUMBER": integer


public "getName"(): string
public static "parser"(): $Parser<($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
public "getVersion"(): string
public static "newBuilder"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public static "newBuilder"(arg0: $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "getDefaultInstance"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public "getNameBytes"(): $ByteString
public "getVersionBytes"(): $ByteString
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
get "name"(): string
get "version"(): string
get "defaultInstance"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
get "nameBytes"(): $ByteString
get "versionBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type = ($SparkSamplerProtos$SamplerMetadata$SourceMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadata_ = $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$AnnotationVisitor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AnnotationVisitor {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $AnnotationVisitor$Type)

public "visit"(arg0: string, arg1: any): void
public "visitAnnotation"(arg0: string, arg1: string): $AnnotationVisitor
public "visitEnd"(): void
public "visitEnum"(arg0: string, arg1: string, arg2: string): void
public "visitArray"(arg0: string): $AnnotationVisitor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnnotationVisitor$Type = ($AnnotationVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnnotationVisitor_ = $AnnotationVisitor$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$SoundStop" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Sound$Type, $Sound$Type$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $SoundStop extends $Examinable {

 "source"(): $Sound$Source
 "sound"(): $Key
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $SoundStop {
function namedOnSource(sound: $Sound$Type$Type, source: $Sound$Source$Type): $SoundStop
function namedOnSource(sound: $Supplier$Type<(any)>, source: $Sound$Source$Type): $SoundStop
function namedOnSource(sound: $Key$Type, source: $Sound$Source$Type): $SoundStop
function source(source: $Sound$Source$Type): $SoundStop
function all(): $SoundStop
function named(sound: $Supplier$Type<(any)>): $SoundStop
function named(sound: $Key$Type): $SoundStop
function named(sound: $Sound$Type$Type): $SoundStop
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundStop$Type = ($SoundStop);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundStop_ = $SoundStop$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc" {
import {$SparkProtos$SystemStatistics$GcOrBuilder, $SparkProtos$SystemStatistics$GcOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$GcOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Gc$Builder, $SparkProtos$SystemStatistics$Gc$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Gc extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Gc), ($SparkProtos$SystemStatistics$Gc$Builder)> implements $SparkProtos$SystemStatistics$GcOrBuilder {
static readonly "TOTAL_FIELD_NUMBER": integer
static readonly "AVG_TIME_FIELD_NUMBER": integer
static readonly "AVG_FREQUENCY_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Gc)>
public static "newBuilder"(): $SparkProtos$SystemStatistics$Gc$Builder
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Gc$Type): $SparkProtos$SystemStatistics$Gc$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Gc
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Gc
public "getTotal"(): long
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Gc
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Gc
public "getAvgFrequency"(): double
public "getAvgTime"(): double
get "defaultInstance"(): $SparkProtos$SystemStatistics$Gc
get "total"(): long
get "avgFrequency"(): double
get "avgTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Gc$Type = ($SparkProtos$SystemStatistics$Gc);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Gc_ = $SparkProtos$SystemStatistics$Gc$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$MethodRef" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $JfrReader$MethodRef {
readonly "cls": long
readonly "name": long
readonly "sig": long

constructor(arg0: long, arg1: long, arg2: long)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$MethodRef$Type = ($JfrReader$MethodRef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$MethodRef_ = $JfrReader$MethodRef$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/$LinuxProc" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$List, $List$Type} from "packages/java/util/$List"

export class $LinuxProc extends $Enum<($LinuxProc)> {
static readonly "CPUINFO": $LinuxProc
static readonly "MEMINFO": $LinuxProc
static readonly "NET_DEV": $LinuxProc
static readonly "OSINFO": $LinuxProc


public static "values"(): ($LinuxProc)[]
public static "valueOf"(arg0: string): $LinuxProc
public "read"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinuxProc$Type = (("meminfo") | ("net_dev") | ("osinfo") | ("cpuinfo")) | ($LinuxProc);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LinuxProc_ = $LinuxProc$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ApiOrBuilder" {
import {$Mixin, $Mixin$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$Method, $Method$Type} from "packages/me/lucko/spark/lib/protobuf/$Method"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $ApiOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getMethods"(arg0: integer): $Method
 "getVersion"(): string
 "getSyntax"(): $Syntax
 "getOptions"(arg0: integer): $Option
 "getNameBytes"(): $ByteString
 "getMixins"(arg0: integer): $Mixin
 "getMethodsCount"(): integer
 "getSourceContext"(): $SourceContext
 "getMethodsList"(): $List<($Method)>
 "getMixinsList"(): $List<($Mixin)>
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "getVersionBytes"(): $ByteString
 "hasSourceContext"(): boolean
 "getMixinsCount"(): integer
 "getSyntaxValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $ApiOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApiOrBuilder$Type = ($ApiOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApiOrBuilder_ = $ApiOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerAccess$ProfilingEvent" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $AsyncProfilerAccess$ProfilingEvent extends $Enum<($AsyncProfilerAccess$ProfilingEvent)> {
static readonly "CPU": $AsyncProfilerAccess$ProfilingEvent
static readonly "WALL": $AsyncProfilerAccess$ProfilingEvent
static readonly "ALLOC": $AsyncProfilerAccess$ProfilingEvent


public "toString"(): string
public static "values"(): ($AsyncProfilerAccess$ProfilingEvent)[]
public static "valueOf"(arg0: string): $AsyncProfilerAccess$ProfilingEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncProfilerAccess$ProfilingEvent$Type = (("cpu") | ("alloc") | ("wall")) | ($AsyncProfilerAccess$ProfilingEvent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncProfilerAccess$ProfilingEvent_ = $AsyncProfilerAccess$ProfilingEvent$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidEncodingException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$UnsupportedEncodingException, $UnsupportedEncodingException$Type} from "packages/java/io/$UnsupportedEncodingException"

export class $InvalidEncodingException extends $RuntimeException {

constructor(arg0: $UnsupportedEncodingException$Type)

public "getEncodingException"(): $UnsupportedEncodingException
get "encodingException"(): $UnsupportedEncodingException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidEncodingException$Type = ($InvalidEncodingException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidEncodingException_ = $InvalidEncodingException$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os" {
import {$SparkProtos$SystemStatistics$Os$Builder, $SparkProtos$SystemStatistics$Os$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$OsOrBuilder, $SparkProtos$SystemStatistics$OsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$OsOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Os extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Os), ($SparkProtos$SystemStatistics$Os$Builder)> implements $SparkProtos$SystemStatistics$OsOrBuilder {
static readonly "ARCH_FIELD_NUMBER": integer
static readonly "NAME_FIELD_NUMBER": integer
static readonly "VERSION_FIELD_NUMBER": integer


public "getName"(): string
public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Os)>
public "getVersion"(): string
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Os$Type): $SparkProtos$SystemStatistics$Os$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$Os$Builder
public "getArch"(): string
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Os
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Os
public "getNameBytes"(): $ByteString
public "getVersionBytes"(): $ByteString
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Os
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Os
public "getArchBytes"(): $ByteString
get "name"(): string
get "version"(): string
get "arch"(): string
get "defaultInstance"(): $SparkProtos$SystemStatistics$Os
get "nameBytes"(): $ByteString
get "versionBytes"(): $ByteString
get "archBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Os$Type = ($SparkProtos$SystemStatistics$Os);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Os_ = $SparkProtos$SystemStatistics$Os$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$JoinConfigurationImpl" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$JoinConfiguration$Builder, $JoinConfiguration$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $JoinConfigurationImpl implements $JoinConfiguration {


public "toString"(): string
public "prefix"(): $Component
public "suffix"(): $Component
public "separator"(): $Component
public "predicate"(): $Predicate<($ComponentLike)>
public "examinableProperties"(): $Stream<(any)>
public "toBuilder"(): $JoinConfiguration$Builder
public "lastSeparatorIfSerial"(): $Component
public "lastSeparator"(): $Component
public "parentStyle"(): $Style
public "convertor"(): $Function<($ComponentLike), ($Component)>
public static "builder"(): $JoinConfiguration$Builder
public static "separator"(separator: $ComponentLike$Type): $JoinConfiguration
public static "newlines"(): $JoinConfiguration
public static "separators"(separator: $ComponentLike$Type, lastSeparator: $ComponentLike$Type): $JoinConfiguration
public static "arrayLike"(): $JoinConfiguration
public static "commas"(spaces: boolean): $JoinConfiguration
public static "noSeparators"(): $JoinConfiguration
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $JoinConfiguration$Builder$Type, consumer: $Consumer$Type<(any)>): $JoinConfiguration
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JoinConfigurationImpl$Type = ($JoinConfigurationImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JoinConfigurationImpl_ = $JoinConfigurationImpl$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/ping/$PingStatistics" {
import {$PingStatistics$PlayerPing, $PingStatistics$PlayerPing$Type} from "packages/me/lucko/spark/common/monitor/ping/$PingStatistics$PlayerPing"
import {$PingSummary, $PingSummary$Type} from "packages/me/lucko/spark/common/monitor/ping/$PingSummary"
import {$PlayerPingProvider, $PlayerPingProvider$Type} from "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$RollingAverage, $RollingAverage$Type} from "packages/me/lucko/spark/common/util/$RollingAverage"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $PingStatistics implements $Runnable, $AutoCloseable {

constructor(arg0: $PlayerPingProvider$Type)

public "run"(): void
public "start"(): void
public "close"(): void
public "query"(arg0: string): $PingStatistics$PlayerPing
public "currentSummary"(): $PingSummary
public "getPingAverage"(): $RollingAverage
get "pingAverage"(): $RollingAverage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PingStatistics$Type = ($PingStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PingStatistics_ = $PingStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ScoreComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $ScoreComponentImpl extends $AbstractComponent implements $ScoreComponent {


public "name"(): string
public "name"(name: string): $ScoreComponent
/**
 * 
 * @deprecated
 */
public "value"(value: string): $ScoreComponent
/**
 * 
 * @deprecated
 */
public "value"(): string
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "objective"(): string
public "objective"(objective: string): $ScoreComponent
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $ScoreComponent
public "append"(like: $ComponentLike$Type): $ScoreComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $ScoreComponent
public "color"(color: $TextColor$Type): $ScoreComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $ScoreComponent
public "style"(style: $Style$Builder$Type): $ScoreComponent
public "mergeStyle"(that: $Component$Type): $ScoreComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $ScoreComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $ScoreComponent
public "colorIfAbsent"(color: $TextColor$Type): $ScoreComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $ScoreComponent
public "clickEvent"(event: $ClickEvent$Type): $ScoreComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $ScoreComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $ScoreComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScoreComponentImpl$Type = ($ScoreComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScoreComponentImpl_ = $ScoreComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakedataImpl1" {
import {$HandshakeBuilder, $HandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $HandshakedataImpl1 implements $HandshakeBuilder {

constructor()

public "put"(arg0: string, arg1: string): void
public "getContent"(): (byte)[]
public "setContent"(arg0: (byte)[]): void
public "getFieldValue"(arg0: string): string
public "iterateHttpFields"(): $Iterator<(string)>
public "hasFieldValue"(arg0: string): boolean
get "content"(): (byte)[]
set "content"(value: (byte)[])
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakedataImpl1$Type = ($HandshakedataImpl1);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakedataImpl1_ = $HandshakedataImpl1$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Protobuf" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"

export class $Protobuf {


public "registerSchemaOverride"(arg0: $Class$Type<(any)>, arg1: $Schema$Type<(any)>): $Schema<(any)>
public static "getInstance"(): $Protobuf
public "writeTo"<T>(arg0: T, arg1: $Writer$Type): void
public "makeImmutable"<T>(arg0: T): void
public "registerSchema"(arg0: $Class$Type<(any)>, arg1: $Schema$Type<(any)>): $Schema<(any)>
public "schemaFor"<T>(arg0: $Class$Type<(T)>): $Schema<(T)>
public "schemaFor"<T>(arg0: T): $Schema<(T)>
public "mergeFrom"<T>(arg0: T, arg1: $Reader$Type, arg2: $ExtensionRegistryLite$Type): void
public "mergeFrom"<T>(arg0: T, arg1: $Reader$Type): void
get "instance"(): $Protobuf
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Protobuf$Type = ($Protobuf);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Protobuf_ = $Protobuf$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/internal/$Internals" {
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $Internals {


public static "toString"(examinable: $Examinable$Type): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internals$Type = ($Internals);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internals_ = $Internals$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StructuralMessageInfo$Builder" {
import {$FieldInfo, $FieldInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldInfo"
import {$StructuralMessageInfo, $StructuralMessageInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$StructuralMessageInfo"
import {$ProtoSyntax, $ProtoSyntax$Type} from "packages/me/lucko/spark/lib/protobuf/$ProtoSyntax"

export class $StructuralMessageInfo$Builder {

constructor()
constructor(arg0: integer)

public "build"(): $StructuralMessageInfo
public "withDefaultInstance"(arg0: any): void
public "withMessageSetWireFormat"(arg0: boolean): void
public "withCheckInitialized"(arg0: (integer)[]): void
public "withField"(arg0: $FieldInfo$Type): void
public "withSyntax"(arg0: $ProtoSyntax$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructuralMessageInfo$Builder$Type = ($StructuralMessageInfo$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructuralMessageInfo$Builder_ = $StructuralMessageInfo$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkWebSocketProtos$ServerConnectResponse, $SparkWebSocketProtos$ServerConnectResponse$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse"
import {$SparkWebSocketProtos$ServerPong, $SparkWebSocketProtos$ServerPong$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkWebSocketProtos$PacketWrapper$PacketCase, $SparkWebSocketProtos$PacketWrapper$PacketCase$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$PacketCase"
import {$SparkWebSocketProtos$PacketWrapper$Builder, $SparkWebSocketProtos$PacketWrapper$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$Builder"
import {$SparkWebSocketProtos$ClientPing, $SparkWebSocketProtos$ClientPing$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing"
import {$SparkWebSocketProtos$ServerUpdateSamplerData, $SparkWebSocketProtos$ServerUpdateSamplerData$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData"
import {$SparkWebSocketProtos$ServerUpdateStatistics, $SparkWebSocketProtos$ServerUpdateStatistics$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkWebSocketProtos$PacketWrapperOrBuilder, $SparkWebSocketProtos$PacketWrapperOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapperOrBuilder"
import {$SparkWebSocketProtos$ClientConnect, $SparkWebSocketProtos$ClientConnect$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect"

export class $SparkWebSocketProtos$PacketWrapper extends $GeneratedMessageLite<($SparkWebSocketProtos$PacketWrapper), ($SparkWebSocketProtos$PacketWrapper$Builder)> implements $SparkWebSocketProtos$PacketWrapperOrBuilder {
static readonly "SERVER_PONG_FIELD_NUMBER": integer
static readonly "SERVER_CONNECT_RESPONSE_FIELD_NUMBER": integer
static readonly "SERVER_UPDATE_SAMPLER_FIELD_NUMBER": integer
static readonly "SERVER_UPDATE_STATISTICS_FIELD_NUMBER": integer
static readonly "CLIENT_PING_FIELD_NUMBER": integer
static readonly "CLIENT_CONNECT_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$PacketWrapper)>
public static "newBuilder"(arg0: $SparkWebSocketProtos$PacketWrapper$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public static "newBuilder"(): $SparkWebSocketProtos$PacketWrapper$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$PacketWrapper
public static "getDefaultInstance"(): $SparkWebSocketProtos$PacketWrapper
public "getPacketCase"(): $SparkWebSocketProtos$PacketWrapper$PacketCase
public "getClientPing"(): $SparkWebSocketProtos$ClientPing
public "getClientConnect"(): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$PacketWrapper
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$PacketWrapper
public "hasServerPong"(): boolean
public "getServerPong"(): $SparkWebSocketProtos$ServerPong
public "hasClientPing"(): boolean
public "hasClientConnect"(): boolean
public "getServerConnectResponse"(): $SparkWebSocketProtos$ServerConnectResponse
public "getServerUpdateStatistics"(): $SparkWebSocketProtos$ServerUpdateStatistics
public "hasServerConnectResponse"(): boolean
public "hasServerUpdateStatistics"(): boolean
public "hasServerUpdateSampler"(): boolean
public "getServerUpdateSampler"(): $SparkWebSocketProtos$ServerUpdateSamplerData
get "defaultInstance"(): $SparkWebSocketProtos$PacketWrapper
get "packetCase"(): $SparkWebSocketProtos$PacketWrapper$PacketCase
get "clientPing"(): $SparkWebSocketProtos$ClientPing
get "clientConnect"(): $SparkWebSocketProtos$ClientConnect
get "serverPong"(): $SparkWebSocketProtos$ServerPong
get "serverConnectResponse"(): $SparkWebSocketProtos$ServerConnectResponse
get "serverUpdateStatistics"(): $SparkWebSocketProtos$ServerUpdateStatistics
get "serverUpdateSampler"(): $SparkWebSocketProtos$ServerUpdateSamplerData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$PacketWrapper$Type = ($SparkWebSocketProtos$PacketWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$PacketWrapper_ = $SparkWebSocketProtos$PacketWrapper$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatisticsOrBuilder" {
import {$SparkProtos$SystemStatistics$Memory, $SparkProtos$SystemStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory"
import {$SparkProtos$SystemStatistics$Os, $SparkProtos$SystemStatistics$Os$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os"
import {$SparkProtos$SystemStatistics$Disk, $SparkProtos$SystemStatistics$Disk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk"
import {$SparkProtos$SystemStatistics$Java, $SparkProtos$SystemStatistics$Java$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java"
import {$SparkProtos$SystemStatistics$NetInterface, $SparkProtos$SystemStatistics$NetInterface$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$SystemStatistics$Gc, $SparkProtos$SystemStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$SystemStatistics$Cpu, $SparkProtos$SystemStatistics$Cpu$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SparkProtos$SystemStatisticsOrBuilder extends $MessageLiteOrBuilder {

 "getOs"(): $SparkProtos$SystemStatistics$Os
 "getUptime"(): long
 "getMemory"(): $SparkProtos$SystemStatistics$Memory
 "getGcOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$Gc$Type): $SparkProtos$SystemStatistics$Gc
 "hasMemory"(): boolean
 "getGcCount"(): integer
 "getGcMap"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
/**
 * 
 * @deprecated
 */
 "getGc"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
 "getGcOrThrow"(arg0: string): $SparkProtos$SystemStatistics$Gc
 "containsGc"(arg0: string): boolean
 "hasJava"(): boolean
/**
 * 
 * @deprecated
 */
 "getNet"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
 "containsNet"(arg0: string): boolean
 "getNetMap"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
 "getCpu"(): $SparkProtos$SystemStatistics$Cpu
 "hasDisk"(): boolean
 "getJava"(): $SparkProtos$SystemStatistics$Java
 "hasCpu"(): boolean
 "hasOs"(): boolean
 "getNetCount"(): integer
 "getDisk"(): $SparkProtos$SystemStatistics$Disk
 "getNetOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$NetInterface$Type): $SparkProtos$SystemStatistics$NetInterface
 "getNetOrThrow"(arg0: string): $SparkProtos$SystemStatistics$NetInterface
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatisticsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatisticsOrBuilder$Type = ($SparkProtos$SystemStatisticsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatisticsOrBuilder_ = $SparkProtos$SystemStatisticsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EnumOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$EnumValue, $EnumValue$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $EnumOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getSyntax"(): $Syntax
 "getOptions"(arg0: integer): $Option
 "getNameBytes"(): $ByteString
 "getSourceContext"(): $SourceContext
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "hasSourceContext"(): boolean
 "getSyntaxValue"(): integer
 "getEnumvalueCount"(): integer
 "getEnumvalue"(arg0: integer): $EnumValue
 "getEnumvalueList"(): $List<($EnumValue)>
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $EnumOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumOrBuilder$Type = ($EnumOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumOrBuilder_ = $EnumOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $DoubleAverageInfo {

 "min"(): double
 "max"(): double
 "mean"(): double
 "percentile95th"(): double
 "median"(): double
 "percentile"(arg0: double): double
}

export namespace $DoubleAverageInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleAverageInfo$Type = ($DoubleAverageInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleAverageInfo_ = $DoubleAverageInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ProtobufArrayList" {
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"

export class $ProtobufArrayList<E> extends $AbstractProtobufList<(E)> implements $RandomAccess {


public "add"(arg0: E): boolean
public "add"(arg0: integer, arg1: E): void
public "remove"(arg0: integer): E
public "get"(arg0: integer): E
public "size"(): integer
public "set"(arg0: integer, arg1: E): E
public static "emptyList"<E>(): $ProtobufArrayList<(E)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E): $List<(E)>
public static "of"<E>(arg0: E): $List<(E)>
public static "of"<E>(): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public static "of"<E>(...arg0: (E)[]): $List<(E)>
public "contains"(arg0: any): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtobufArrayList$Type<E> = ($ProtobufArrayList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtobufArrayList_<E> = $ProtobufArrayList$Type<(E)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pagination$Renderer, $Pagination$Renderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer"
import {$Pagination, $Pagination$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination"
import {$Pagination$PageCommandFunction, $Pagination$PageCommandFunction$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$PageCommandFunction"
import {$Pagination$Renderer$RowRenderer, $Pagination$Renderer$RowRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer$RowRenderer"
import {$Pagination$Builder$CharacterAndStyle, $Pagination$Builder$CharacterAndStyle$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder$CharacterAndStyle"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Pagination$Builder {

 "line"(line: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
 "build"<T>(title: $Component$Type, rowRenderer: $Pagination$Renderer$RowRenderer$Type<(T)>, pageCommand: $Pagination$PageCommandFunction$Type): $Pagination<(T)>
 "width"(width: integer): $Pagination$Builder
 "resultsPerPage"(resultsPerPage: integer): $Pagination$Builder
 "previousButton"(previousButton: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
 "nextButton"(nextButton: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
 "renderer"(renderer: $Pagination$Renderer$Type): $Pagination$Builder
}

export namespace $Pagination$Builder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$Builder$Type = ($Pagination$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination$Builder_ = $Pagination$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfoOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkSamplerProtos$SocketChannelInfoOrBuilder extends $MessageLiteOrBuilder {

 "getPublicKey"(): $ByteString
 "getChannelId"(): string
 "getChannelIdBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SocketChannelInfoOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SocketChannelInfoOrBuilder$Type = ($SparkSamplerProtos$SocketChannelInfoOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SocketChannelInfoOrBuilder_ = $SparkSamplerProtos$SocketChannelInfoOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$TickReporter" {
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$TickReporter$Callback, $TickReporter$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickReporter$Callback"

export interface $TickReporter extends $AutoCloseable {

 "start"(): void
 "close"(): void
 "removeCallback"(arg0: $TickReporter$Callback$Type): void
 "addCallback"(arg0: $TickReporter$Callback$Type): void
}

export namespace $TickReporter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickReporter$Type = ($TickReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickReporter_ = $TickReporter$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerAccess" {
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$AsyncProfilerJob, $AsyncProfilerJob$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerJob"
import {$AsyncProfilerAccess$ProfilingEvent, $AsyncProfilerAccess$ProfilingEvent$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerAccess$ProfilingEvent"

export class $AsyncProfilerAccess {


public "checkAllocationProfilingSupported"(arg0: $SparkPlatform$Type): boolean
public "startNewProfilerJob"(): $AsyncProfilerJob
public "getAllocationProfilingEvent"(): $AsyncProfilerAccess$ProfilingEvent
public static "getInstance"(arg0: $SparkPlatform$Type): $AsyncProfilerAccess
public "checkSupported"(arg0: $SparkPlatform$Type): boolean
public "getProfilingEvent"(): $AsyncProfilerAccess$ProfilingEvent
get "allocationProfilingEvent"(): $AsyncProfilerAccess$ProfilingEvent
get "profilingEvent"(): $AsyncProfilerAccess$ProfilingEvent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncProfilerAccess$Type = ($AsyncProfilerAccess);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncProfilerAccess_ = $AsyncProfilerAccess$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $EntityNBTComponent extends $NBTComponent<($EntityNBTComponent), ($EntityNBTComponent$Builder)>, $ScopedComponent<($EntityNBTComponent)> {

 "selector"(): string
 "selector"(selector: string): $EntityNBTComponent
 "examinableProperties"(): $Stream<(any)>
 "separator"(): $Component
 "separator"(separator: $ComponentLike$Type): $EntityNBTComponent
 "nbtPath"(nbtPath: string): $EntityNBTComponent
 "nbtPath"(): string
 "interpret"(): boolean
 "interpret"(interpret: boolean): $EntityNBTComponent
 "append"(component: $Component$Type): $EntityNBTComponent
 "append"(like: $ComponentLike$Type): $EntityNBTComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $EntityNBTComponent
 "color"(color: $TextColor$Type): $EntityNBTComponent
 "style"(style: $Style$Type): $EntityNBTComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $EntityNBTComponent
 "style"(style: $Style$Builder$Type): $EntityNBTComponent
 "children"(children: $List$Type<(any)>): $EntityNBTComponent
 "mergeStyle"(that: $Component$Type): $EntityNBTComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $EntityNBTComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $EntityNBTComponent
 "colorIfAbsent"(color: $TextColor$Type): $EntityNBTComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $EntityNBTComponent
 "clickEvent"(event: $ClickEvent$Type): $EntityNBTComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $EntityNBTComponent
 "toBuilder"(): $EntityNBTComponent$Builder
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $EntityNBTComponent {
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function configureAndBuild<R, B>(builder: $EntityNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityNBTComponent$Type = ($EntityNBTComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityNBTComponent_ = $EntityNBTComponent$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$ClassRef" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $JfrReader$ClassRef {
readonly "name": long

constructor(arg0: long)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$ClassRef$Type = ($JfrReader$ClassRef);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$ClassRef_ = $JfrReader$ClassRef$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionSchema" {
import {$FieldSet$FieldDescriptorLite, $FieldSet$FieldDescriptorLite$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet$FieldDescriptorLite"

export class $ExtensionSchema<T extends $FieldSet$FieldDescriptorLite<(T)>> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionSchema$Type<T> = ($ExtensionSchema<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionSchema_<T> = $ExtensionSchema$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite" {
import {$ExtensionLite, $ExtensionLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionLite"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$GeneratedMessageLite$GeneratedExtension, $GeneratedMessageLite$GeneratedExtension$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$GeneratedExtension"

export class $ExtensionRegistryLite {


public "add"(arg0: $ExtensionLite$Type<(any), (any)>): void
public "add"(arg0: $GeneratedMessageLite$GeneratedExtension$Type<(any), (any)>): void
public static "newInstance"(): $ExtensionRegistryLite
public static "getEmptyRegistry"(): $ExtensionRegistryLite
public "getUnmodifiable"(): $ExtensionRegistryLite
public static "setEagerlyParseMessageSets"(arg0: boolean): void
public "findLiteExtensionByNumber"<ContainingType extends $MessageLite>(arg0: ContainingType, arg1: integer): $GeneratedMessageLite$GeneratedExtension<(ContainingType), (any)>
public static "isEagerlyParseMessageSets"(): boolean
get "emptyRegistry"(): $ExtensionRegistryLite
get "unmodifiable"(): $ExtensionRegistryLite
set "eagerlyParseMessageSets"(value: boolean)
get "eagerlyParseMessageSets"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionRegistryLite$Type = ($ExtensionRegistryLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionRegistryLite_ = $ExtensionRegistryLite$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$DefaultSSLWebSocketServerFactory" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$WebSocketServerFactory, $WebSocketServerFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketServerFactory"
import {$SSLContext, $SSLContext$Type} from "packages/javax/net/ssl/$SSLContext"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"

export class $DefaultSSLWebSocketServerFactory implements $WebSocketServerFactory {

constructor(arg0: $SSLContext$Type)
constructor(arg0: $SSLContext$Type, arg1: $ExecutorService$Type)

public "close"(): void
public "wrapChannel"(arg0: $SocketChannel$Type, arg1: $SelectionKey$Type): $ByteChannel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultSSLWebSocketServerFactory$Type = ($DefaultSSLWebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultSSLWebSocketServerFactory_ = $DefaultSSLWebSocketServerFactory$Type;
}}
declare module "packages/me/lucko/spark/common/command/tabcomplete/$CompletionSupplier" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"

export interface $CompletionSupplier {

 "supplyCompletions"(arg0: string): $List<(string)>

(arg0: string): $List<(string)>
}

export namespace $CompletionSupplier {
const EMPTY: $CompletionSupplier
function startsWith(arg0: $Collection$Type<(string)>): $CompletionSupplier
function startsWithIgnoreCasePredicate(arg0: string): $Predicate<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompletionSupplier$Type = ($CompletionSupplier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompletionSupplier_ = $CompletionSupplier$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/$StatisticWindow$CpuUsage" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export class $StatisticWindow$CpuUsage extends $Enum<($StatisticWindow$CpuUsage)> implements $StatisticWindow {
static readonly "SECONDS_10": $StatisticWindow$CpuUsage
static readonly "MINUTES_1": $StatisticWindow$CpuUsage
static readonly "MINUTES_15": $StatisticWindow$CpuUsage


public "length"(): $Duration
public static "values"(): ($StatisticWindow$CpuUsage)[]
public static "valueOf"(arg0: string): $StatisticWindow$CpuUsage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatisticWindow$CpuUsage$Type = (("minutes_1") | ("minutes_15") | ("seconds_10")) | ($StatisticWindow$CpuUsage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatisticWindow$CpuUsage_ = $StatisticWindow$CpuUsage$Type;
}}
declare module "packages/me/lucko/spark/common/api/$GarbageCollectorInfo" {
import {$GarbageCollector, $GarbageCollector$Type} from "packages/me/lucko/spark/api/gc/$GarbageCollector"
import {$GarbageCollectorStatistics, $GarbageCollectorStatistics$Type} from "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectorStatistics"

export class $GarbageCollectorInfo implements $GarbageCollector {

constructor(arg0: string, arg1: $GarbageCollectorStatistics$Type, arg2: long)

public "avgFrequency"(): long
public "totalCollections"(): long
public "avgTime"(): double
public "name"(): string
public "totalTime"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GarbageCollectorInfo$Type = ($GarbageCollectorInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GarbageCollectorInfo_ = $GarbageCollectorInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/util/$Charsetfunctions" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Charsetfunctions {


public static "asciiBytes"(arg0: string): (byte)[]
public static "isValidUTF8"(arg0: $ByteBuffer$Type, arg1: integer): boolean
public static "isValidUTF8"(arg0: $ByteBuffer$Type): boolean
public static "stringUtf8"(arg0: (byte)[]): string
public static "stringUtf8"(arg0: $ByteBuffer$Type): string
public static "stringAscii"(arg0: (byte)[], arg1: integer, arg2: integer): string
public static "stringAscii"(arg0: (byte)[]): string
public static "utf8Bytes"(arg0: string): (byte)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Charsetfunctions$Type = ($Charsetfunctions);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Charsetfunctions_ = $Charsetfunctions$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate" {
import {$BlockNBTComponent$WorldPos$Coordinate$Type, $BlockNBTComponent$WorldPos$Coordinate$Type$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate$Type"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $BlockNBTComponent$WorldPos$Coordinate extends $Examinable {

 "type"(): $BlockNBTComponent$WorldPos$Coordinate$Type
 "value"(): integer
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $BlockNBTComponent$WorldPos$Coordinate {
function of(value: integer, type: $BlockNBTComponent$WorldPos$Coordinate$Type$Type): $BlockNBTComponent$WorldPos$Coordinate
function absolute(value: integer): $BlockNBTComponent$WorldPos$Coordinate
function relative(value: integer): $BlockNBTComponent$WorldPos$Coordinate
function coordinate(value: integer, type: $BlockNBTComponent$WorldPos$Coordinate$Type$Type): $BlockNBTComponent$WorldPos$Coordinate
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponent$WorldPos$Coordinate$Type = ($BlockNBTComponent$WorldPos$Coordinate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponent$WorldPos$Coordinate_ = $BlockNBTComponent$WorldPos$Coordinate$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$LazyFieldLite" {
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $LazyFieldLite {

constructor(arg0: $ExtensionRegistryLite$Type, arg1: $ByteString$Type)
constructor()

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clear"(): void
public "getValue"(arg0: $MessageLite$Type): $MessageLite
public "merge"(arg0: $LazyFieldLite$Type): void
public "set"(arg0: $LazyFieldLite$Type): void
public "setValue"(arg0: $MessageLite$Type): $MessageLite
public "getSerializedSize"(): integer
public "setByteString"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): void
public static "fromValue"(arg0: $MessageLite$Type): $LazyFieldLite
public "mergeFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): void
public "toByteString"(): $ByteString
public "containsDefaultInstance"(): boolean
set "value"(value: $MessageLite$Type)
get "serializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyFieldLite$Type = ($LazyFieldLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyFieldLite_ = $LazyFieldLite$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int64ValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $Int64ValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $Int64ValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int64ValueOrBuilder$Type = ($Int64ValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int64ValueOrBuilder_ = $Int64ValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$Translatable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Translatable {

 "translationKey"(): string

(): string
}

export namespace $Translatable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Translatable$Type = ($Translatable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Translatable_ = $Translatable$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ListValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $ListValueOrBuilder extends $MessageLiteOrBuilder {

 "getValuesCount"(): integer
 "getValuesList"(): $List<($Value)>
 "getValues"(arg0: integer): $Value
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $ListValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListValueOrBuilder$Type = ($ListValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListValueOrBuilder_ = $ListValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/ws/$ViewerSocketConnection$Listener" {
import {$PublicKey, $PublicKey$Type} from "packages/java/security/$PublicKey"
import {$SparkWebSocketProtos$PacketWrapper, $SparkWebSocketProtos$PacketWrapper$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper"

export interface $ViewerSocketConnection$Listener {

 "onPacket"(arg0: $SparkWebSocketProtos$PacketWrapper$Type, arg1: boolean, arg2: $PublicKey$Type): void
 "isKeyTrusted"(arg0: $PublicKey$Type): boolean
}

export namespace $ViewerSocketConnection$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewerSocketConnection$Listener$Type = ($ViewerSocketConnection$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewerSocketConnection$Listener_ = $ViewerSocketConnection$Listener$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration$Builder" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $JoinConfiguration$Builder extends $AbstractBuilder<($JoinConfiguration)>, $Buildable$Builder<($JoinConfiguration)> {

 "prefix"(prefix: $ComponentLike$Type): $JoinConfiguration$Builder
 "suffix"(suffix: $ComponentLike$Type): $JoinConfiguration$Builder
 "separator"(separator: $ComponentLike$Type): $JoinConfiguration$Builder
 "predicate"(predicate: $Predicate$Type<($ComponentLike$Type)>): $JoinConfiguration$Builder
 "lastSeparatorIfSerial"(lastSeparatorIfSerial: $ComponentLike$Type): $JoinConfiguration$Builder
 "lastSeparator"(lastSeparator: $ComponentLike$Type): $JoinConfiguration$Builder
 "parentStyle"(parentStyle: $Style$Type): $JoinConfiguration$Builder
 "convertor"(convertor: $Function$Type<($ComponentLike$Type), ($Component$Type)>): $JoinConfiguration$Builder
 "build"(): $JoinConfiguration
}

export namespace $JoinConfiguration$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $JoinConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JoinConfiguration$Builder$Type = ($JoinConfiguration$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JoinConfiguration$Builder_ = $JoinConfiguration$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$AnnotationWriter" {
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"

export class $AnnotationWriter extends $AnnotationVisitor {


public "visit"(arg0: string, arg1: any): void
public "visitAnnotation"(arg0: string, arg1: string): $AnnotationVisitor
public "visitEnd"(): void
public "visitEnum"(arg0: string, arg1: string, arg2: string): void
public "visitArray"(arg0: string): $AnnotationVisitor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnnotationWriter$Type = ($AnnotationWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnnotationWriter_ = $AnnotationWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$RawMessageInfo" {
import {$ProtoSyntax, $ProtoSyntax$Type} from "packages/me/lucko/spark/lib/protobuf/$ProtoSyntax"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$MessageInfo, $MessageInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageInfo"

export class $RawMessageInfo implements $MessageInfo {


public "isMessageSetWireFormat"(): boolean
public "getSyntax"(): $ProtoSyntax
public "getDefaultInstance"(): $MessageLite
get "messageSetWireFormat"(): boolean
get "syntax"(): $ProtoSyntax
get "defaultInstance"(): $MessageLite
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RawMessageInfo$Type = ($RawMessageInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RawMessageInfo_ = $RawMessageInfo$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$SamplerMode" {
import {$SparkSamplerProtos$SamplerMetadata$SamplerMode, $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SamplerMode"
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SamplerMode extends $Enum<($SamplerMode)> {
static readonly "EXECUTION": $SamplerMode
static readonly "ALLOCATION": $SamplerMode


public static "values"(): ($SamplerMode)[]
public static "valueOf"(arg0: string): $SamplerMode
public "asProto"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
public "valueTransformer"(): $LongToDoubleFunction
public "defaultInterval"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SamplerMode$Type = (("execution") | ("allocation")) | ($SamplerMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SamplerMode_ = $SamplerMode$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$UTF8ResourceBundleControl" {
import {$ResourceBundle$Control, $ResourceBundle$Control$Type} from "packages/java/util/$ResourceBundle$Control"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ClassLoader, $ClassLoader$Type} from "packages/java/lang/$ClassLoader"
import {$ResourceBundle, $ResourceBundle$Type} from "packages/java/util/$ResourceBundle"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $UTF8ResourceBundleControl extends $ResourceBundle$Control {
static readonly "FORMAT_DEFAULT": $List<(string)>
static readonly "FORMAT_CLASS": $List<(string)>
static readonly "FORMAT_PROPERTIES": $List<(string)>
static readonly "TTL_DONT_CACHE": long
static readonly "TTL_NO_EXPIRATION_CONTROL": long

constructor()

public static "get"(): $ResourceBundle$Control
public "newBundle"(baseName: string, locale: $Locale$Type, format: string, loader: $ClassLoader$Type, reload: boolean): $ResourceBundle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UTF8ResourceBundleControl$Type = ($UTF8ResourceBundleControl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UTF8ResourceBundleControl_ = $UTF8ResourceBundleControl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$OsOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$OsOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getVersion"(): string
 "getArch"(): string
 "getNameBytes"(): $ByteString
 "getVersionBytes"(): $ByteString
 "getArchBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$OsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$OsOrBuilder$Type = ($SparkProtos$SystemStatistics$OsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$OsOrBuilder_ = $SparkProtos$SystemStatistics$OsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"

export class $MapEntryLite$Metadata<K, V> {
readonly "keyType": $WireFormat$FieldType
readonly "defaultKey": K
readonly "valueType": $WireFormat$FieldType
readonly "defaultValue": V

constructor(arg0: $WireFormat$FieldType$Type, arg1: K, arg2: $WireFormat$FieldType$Type, arg3: V)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapEntryLite$Metadata$Type<K, V> = ($MapEntryLite$Metadata<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapEntryLite$Metadata_<K, V> = $MapEntryLite$Metadata$Type<(K), (V)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/identity/$IdentityImpl" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $IdentityImpl implements $Examinable, $Identity {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "uuid"(): $UUID
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "examinableProperties"(): $Stream<(any)>
public static "identity"(uuid: $UUID$Type): $Identity
public static "nil"(): $Identity
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IdentityImpl$Type = ($IdentityImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IdentityImpl_ = $IdentityImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$SoundStopImpl" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Sound$Type, $Sound$Type$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export class $SoundStopImpl implements $SoundStop {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "source"(): $Sound$Source
public "examinableProperties"(): $Stream<(any)>
public static "namedOnSource"(sound: $Sound$Type$Type, source: $Sound$Source$Type): $SoundStop
public static "namedOnSource"(sound: $Supplier$Type<(any)>, source: $Sound$Source$Type): $SoundStop
public static "namedOnSource"(sound: $Key$Type, source: $Sound$Source$Type): $SoundStop
public static "source"(source: $Sound$Source$Type): $SoundStop
public static "all"(): $SoundStop
public static "named"(sound: $Supplier$Type<(any)>): $SoundStop
public static "named"(sound: $Key$Type): $SoundStop
public static "named"(sound: $Sound$Type$Type): $SoundStop
public "sound"(): $Key
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundStopImpl$Type = ($SoundStopImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundStopImpl_ = $SoundStopImpl$Type;
}}
declare module "packages/me/lucko/spark/common/command/modules/$GcMonitoringModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"

export class $GcMonitoringModule implements $CommandModule {

constructor()

public "close"(): void
public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GcMonitoringModule$Type = ($GcMonitoringModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GcMonitoringModule_ = $GcMonitoringModule$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$PlatformAPI" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $PlatformAPI extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $PlatformAPI {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformAPI$Type = ($PlatformAPI);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformAPI_ = $PlatformAPI$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$ComponentSerializerImpl" {
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $ComponentSerializerImpl extends $TypeAdapter<($Component)> {


public "write"(out: $JsonWriter$Type, value: $Component$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentSerializerImpl$Type = ($ComponentSerializerImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentSerializerImpl_ = $ComponentSerializerImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$PongFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$ControlFrame"
import {$PingFrame, $PingFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$PingFrame"

export class $PongFrame extends $ControlFrame {

constructor()
constructor(arg0: $PingFrame$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PongFrame$Type = ($PongFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PongFrame_ = $PongFrame$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Empty$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$EmptyOrBuilder, $EmptyOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EmptyOrBuilder"
import {$Empty, $Empty$Type} from "packages/me/lucko/spark/lib/protobuf/$Empty"

export class $Empty$Builder extends $GeneratedMessageLite$Builder<($Empty), ($Empty$Builder)> implements $EmptyOrBuilder {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Empty$Builder$Type = ($Empty$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Empty$Builder_ = $Empty$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$AbstractSampler" {
import {$ViewerSocket, $ViewerSocket$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocket"
import {$Sampler, $Sampler$Type} from "packages/me/lucko/spark/common/sampler/$Sampler"
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Sampler$ExportProps, $Sampler$ExportProps$Type} from "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps"
import {$SparkSamplerProtos$SamplerData, $SparkSamplerProtos$SamplerData$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData"

export class $AbstractSampler implements $Sampler {


public "start"(): void
public "stop"(arg0: boolean): void
public "getFuture"(): $CompletableFuture<($Sampler)>
public "getAttachedSockets"(): $Collection<($ViewerSocket)>
public "getAutoEndTime"(): long
public "attachSocket"(arg0: $ViewerSocket$Type): void
public "isRunningInBackground"(): boolean
public "getStartTime"(): long
public "toProto"(arg0: $SparkPlatform$Type, arg1: $Sampler$ExportProps$Type): $SparkSamplerProtos$SamplerData
public "getMode"(): $SamplerMode
get "future"(): $CompletableFuture<($Sampler)>
get "attachedSockets"(): $Collection<($ViewerSocket)>
get "autoEndTime"(): long
get "runningInBackground"(): boolean
get "startTime"(): long
get "mode"(): $SamplerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractSampler$Type = ($AbstractSampler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractSampler_ = $AbstractSampler$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Arguments" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$List, $List$Type} from "packages/java/util/$List"

export class $Arguments {

constructor(arg0: $List$Type<(string)>, arg1: boolean)

public "raw"(): $List<(string)>
public "subCommand"(): string
public "doubleFlag"(arg0: string): double
public "intFlag"(arg0: string): integer
public "stringFlag"(arg0: string): $Set<(string)>
public "boolFlag"(arg0: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Arguments$Type = ($Arguments);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Arguments_ = $Arguments$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CodedOutputStreamWriter" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$Writer$FieldOrder, $Writer$FieldOrder$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer$FieldOrder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CodedOutputStreamWriter implements $Writer {


public "writeMessageSetItem"(arg0: integer, arg1: any): void
public "writeBytes"(arg0: integer, arg1: $ByteString$Type): void
public "writeFloat"(arg0: integer, arg1: float): void
public "writeDouble"(arg0: integer, arg1: double): void
public "writeString"(arg0: integer, arg1: string): void
public static "forCodedOutput"(arg0: $CodedOutputStream$Type): $CodedOutputStreamWriter
public "writeSInt64"(arg0: integer, arg1: long): void
public "writeMessage"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
public "writeMessage"(arg0: integer, arg1: any): void
public "writeUInt64"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
public "writeStartGroup"(arg0: integer): void
public "writeInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "writeEndGroup"(arg0: integer): void
public "writeInt64"(arg0: integer, arg1: long): void
public "writeFixed32"(arg0: integer, arg1: integer): void
public "writeUInt32"(arg0: integer, arg1: integer): void
public "writeSFixed32"(arg0: integer, arg1: integer): void
public "writeSFixed64"(arg0: integer, arg1: long): void
public "writeFixed64"(arg0: integer, arg1: long): void
public "writeSInt32"(arg0: integer, arg1: integer): void
public "writeGroup"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "writeGroup"(arg0: integer, arg1: any): void
public "writeBool"(arg0: integer, arg1: boolean): void
public "writeUInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeFloatList"(arg0: integer, arg1: $List$Type<(float)>, arg2: boolean): void
public "writeDoubleList"(arg0: integer, arg1: $List$Type<(double)>, arg2: boolean): void
public "writeUInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeSFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeBoolList"(arg0: integer, arg1: $List$Type<(boolean)>, arg2: boolean): void
public "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>): void
public "writeSFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeSInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeBytesList"(arg0: integer, arg1: $List$Type<($ByteString$Type)>): void
public "writeStringList"(arg0: integer, arg1: $List$Type<(string)>): void
public "writeInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
public "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>): void
public "writeSInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeEnumList"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeEnum"(arg0: integer, arg1: integer): void
public "fieldOrder"(): $Writer$FieldOrder
public "writeMap"<K, V>(arg0: integer, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $Map$Type<(K), (V)>): void
public "getTotalBytesWritten"(): integer
get "totalBytesWritten"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodedOutputStreamWriter$Type = ($CodedOutputStreamWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodedOutputStreamWriter_ = $CodedOutputStreamWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattenerImpl" {
import {$FlattenerListener, $FlattenerListener$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$FlattenerListener"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ComponentFlattener$Builder, $ComponentFlattener$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener$Builder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$ComponentFlattener, $ComponentFlattener$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $ComponentFlattenerImpl implements $ComponentFlattener {


public "flatten"(input: $Component$Type, listener: $FlattenerListener$Type): void
public "toBuilder"(): $ComponentFlattener$Builder
public static "textOnly"(): $ComponentFlattener
public static "builder"(): $ComponentFlattener$Builder
public static "basic"(): $ComponentFlattener
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $ComponentFlattener$Builder$Type, consumer: $Consumer$Type<(any)>): $ComponentFlattener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFlattenerImpl$Type = ($ComponentFlattenerImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentFlattenerImpl_ = $ComponentFlattenerImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getVersion"(): string
 "getNameBytes"(): $ByteString
 "getVersionBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder$Type = ($SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder_ = $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/disk/$DiskUsage" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $DiskUsage extends $Enum<($DiskUsage)> {


public static "values"(): ($DiskUsage)[]
public static "valueOf"(arg0: string): $DiskUsage
public static "getTotal"(): long
public static "getUsed"(): long
get "total"(): long
get "used"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DiskUsage$Type = (never) | ($DiskUsage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DiskUsage_ = $DiskUsage$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$SignedMessageImpl" {
import {$SignedMessage, $SignedMessage$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage"
import {$Instant, $Instant$Type} from "packages/java/time/$Instant"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$SignedMessage$Signature, $SignedMessage$Signature$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $SignedMessageImpl implements $SignedMessage {


public "signature"(): $SignedMessage$Signature
public "identity"(): $Identity
public "message"(): string
public "timestamp"(): $Instant
public "unsignedContent"(): $Component
public "salt"(): long
public static "signature"(signature: (byte)[]): $SignedMessage$Signature
public static "system"(message: string, unsignedContent: $ComponentLike$Type): $SignedMessage
public "isSystem"(): boolean
public "examinableProperties"(): $Stream<(any)>
public "canDelete"(): boolean
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignedMessageImpl$Type = ($SignedMessageImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignedMessageImpl_ = $SignedMessageImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source$Provider" {
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"

export interface $Sound$Source$Provider {

 "soundSource"(): $Sound$Source

(): $Sound$Source
}

export namespace $Sound$Source$Provider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Source$Provider$Type = ($Sound$Source$Provider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound$Source$Provider_ = $Sound$Source$Provider$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer$RowRenderer" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Pagination$Renderer$RowRenderer<T> {

 "renderRow"(value: T, index: integer): $Collection<($Component)>

(value: T, index: integer): $Collection<($Component)>
}

export namespace $Pagination$Renderer$RowRenderer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$Renderer$RowRenderer$Type<T> = ($Pagination$Renderer$RowRenderer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination$Renderer$RowRenderer_<T> = $Pagination$Renderer$RowRenderer$Type<(T)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder" {
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder extends $MessageLiteOrBuilder {

 "getIdsList"(): $List<(long)>
 "getPatternsList"(): $List<(string)>
 "getPatternsBytes"(arg0: integer): $ByteString
 "getIdsCount"(): integer
 "getPatternsCount"(): integer
 "getType"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
 "getIds"(arg0: integer): long
 "getTypeValue"(): integer
 "getPatterns"(arg0: integer): string
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder$Type = ($SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder_ = $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatisticsOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$SparkProtos$WorldStatistics$World, $SparkProtos$WorldStatistics$World$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World"

export interface $SparkProtos$WorldStatisticsOrBuilder extends $MessageLiteOrBuilder {

 "containsEntityCounts"(arg0: string): boolean
 "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
 "getEntityCountsCount"(): integer
 "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
 "getEntityCounts"(): $Map<(string), (integer)>
 "getWorldsCount"(): integer
 "getWorldsList"(): $List<($SparkProtos$WorldStatistics$World)>
 "getEntityCountsMap"(): $Map<(string), (integer)>
 "getWorlds"(arg0: integer): $SparkProtos$WorldStatistics$World
 "getTotalEntities"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$WorldStatisticsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatisticsOrBuilder$Type = ($SparkProtos$WorldStatisticsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatisticsOrBuilder_ = $SparkProtos$WorldStatisticsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Attribute" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Attribute {
readonly "type": string


public "isUnknown"(): boolean
public "isCodeAttribute"(): boolean
get "unknown"(): boolean
get "codeAttribute"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Attribute$Type = ($Attribute);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Attribute_ = $Attribute$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$HoverEventActionSerializer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $HoverEventActionSerializer {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEventActionSerializer$Type = ($HoverEventActionSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEventActionSerializer_ = $HoverEventActionSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$ModuleVisitor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ModuleVisitor {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $ModuleVisitor$Type)

public "visitEnd"(): void
public "visitMainClass"(arg0: string): void
public "visitPackage"(arg0: string): void
public "visitRequire"(arg0: string, arg1: integer, arg2: string): void
public "visitExport"(arg0: string, arg1: integer, ...arg2: (string)[]): void
public "visitOpen"(arg0: string, arg1: integer, ...arg2: (string)[]): void
public "visitUse"(arg0: string): void
public "visitProvide"(arg0: string, ...arg1: (string)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ModuleVisitor$Type = ($ModuleVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ModuleVisitor_ = $ModuleVisitor$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Api$Builder" {
import {$SourceContext$Builder, $SourceContext$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ApiOrBuilder, $ApiOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ApiOrBuilder"
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$Mixin, $Mixin$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin"
import {$Mixin$Builder, $Mixin$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin$Builder"
import {$Method, $Method$Type} from "packages/me/lucko/spark/lib/protobuf/$Method"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Method$Builder, $Method$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Method$Builder"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Api, $Api$Type} from "packages/me/lucko/spark/lib/protobuf/$Api"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Api$Builder extends $GeneratedMessageLite$Builder<($Api), ($Api$Builder)> implements $ApiOrBuilder {


public "setSourceContext"(arg0: $SourceContext$Builder$Type): $Api$Builder
public "setSourceContext"(arg0: $SourceContext$Type): $Api$Builder
public "mergeSourceContext"(arg0: $SourceContext$Type): $Api$Builder
public "clearSourceContext"(): $Api$Builder
public "getName"(): string
public "getMethods"(arg0: integer): $Method
public "setName"(arg0: string): $Api$Builder
public "getVersion"(): string
public "setVersion"(arg0: string): $Api$Builder
public "getSyntax"(): $Syntax
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: $Option$Type): $Api$Builder
public "addOptions"(arg0: integer, arg1: $Option$Type): $Api$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $Api$Builder
public "addOptions"(arg0: $Option$Builder$Type): $Api$Builder
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $Api$Builder
public "clearOptions"(): $Api$Builder
public "clearSyntax"(): $Api$Builder
public "removeOptions"(arg0: integer): $Api$Builder
public "setSyntaxValue"(arg0: integer): $Api$Builder
public "setSyntax"(arg0: $Syntax$Type): $Api$Builder
public "setNameBytes"(arg0: $ByteString$Type): $Api$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Api$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $Api$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $Api$Builder
public "getMixins"(arg0: integer): $Mixin
public "getMethodsCount"(): integer
public "getSourceContext"(): $SourceContext
public "getMethodsList"(): $List<($Method)>
public "getMixinsList"(): $List<($Mixin)>
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getVersionBytes"(): $ByteString
public "hasSourceContext"(): boolean
public "getMixinsCount"(): integer
public "getSyntaxValue"(): integer
public "clearMethods"(): $Api$Builder
public "removeMethods"(arg0: integer): $Api$Builder
public "clearVersion"(): $Api$Builder
public "addMethods"(arg0: $Method$Builder$Type): $Api$Builder
public "addMethods"(arg0: $Method$Type): $Api$Builder
public "addMethods"(arg0: integer, arg1: $Method$Builder$Type): $Api$Builder
public "addMethods"(arg0: integer, arg1: $Method$Type): $Api$Builder
public "addAllMethods"(arg0: $Iterable$Type<(any)>): $Api$Builder
public "setMethods"(arg0: integer, arg1: $Method$Type): $Api$Builder
public "setMethods"(arg0: integer, arg1: $Method$Builder$Type): $Api$Builder
public "addAllMixins"(arg0: $Iterable$Type<(any)>): $Api$Builder
public "removeMixins"(arg0: integer): $Api$Builder
public "setMixins"(arg0: integer, arg1: $Mixin$Type): $Api$Builder
public "setMixins"(arg0: integer, arg1: $Mixin$Builder$Type): $Api$Builder
public "addMixins"(arg0: $Mixin$Builder$Type): $Api$Builder
public "addMixins"(arg0: $Mixin$Type): $Api$Builder
public "addMixins"(arg0: integer, arg1: $Mixin$Builder$Type): $Api$Builder
public "addMixins"(arg0: integer, arg1: $Mixin$Type): $Api$Builder
public "clearMixins"(): $Api$Builder
public "setVersionBytes"(arg0: $ByteString$Type): $Api$Builder
set "sourceContext"(value: $SourceContext$Builder$Type)
set "sourceContext"(value: $SourceContext$Type)
get "name"(): string
set "name"(value: string)
get "version"(): string
set "version"(value: string)
get "syntax"(): $Syntax
set "syntaxValue"(value: integer)
set "syntax"(value: $Syntax$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "methodsCount"(): integer
get "sourceContext"(): $SourceContext
get "methodsList"(): $List<($Method)>
get "mixinsList"(): $List<($Mixin)>
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "versionBytes"(): $ByteString
get "mixinsCount"(): integer
get "syntaxValue"(): integer
set "versionBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Api$Builder$Type = ($Api$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Api$Builder_ = $Api$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Listener" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$BossBar$Color, $BossBar$Color$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Color"
import {$BossBar$Flag, $BossBar$Flag$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Flag"
import {$BossBar$Overlay, $BossBar$Overlay$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Overlay"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $BossBar$Listener {

 "bossBarNameChanged"(bar: $BossBar$Type, oldName: $Component$Type, newName: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "bossBarPercentChanged"(bar: $BossBar$Type, oldProgress: float, newProgress: float): void
 "bossBarProgressChanged"(bar: $BossBar$Type, oldProgress: float, newProgress: float): void
 "bossBarFlagsChanged"(bar: $BossBar$Type, flagsAdded: $Set$Type<($BossBar$Flag$Type)>, flagsRemoved: $Set$Type<($BossBar$Flag$Type)>): void
 "bossBarOverlayChanged"(bar: $BossBar$Type, oldOverlay: $BossBar$Overlay$Type, newOverlay: $BossBar$Overlay$Type): void
 "bossBarColorChanged"(bar: $BossBar$Type, oldColor: $BossBar$Color$Type, newColor: $BossBar$Color$Type): void
}

export namespace $BossBar$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBar$Listener$Type = ($BossBar$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBar$Listener_ = $BossBar$Listener$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$PingFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$ControlFrame"

export class $PingFrame extends $ControlFrame {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PingFrame$Type = ($PingFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PingFrame_ = $PingFrame$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$ForwardingAudienceOverrideNotRequired" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ForwardingAudienceOverrideNotRequired extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ForwardingAudienceOverrideNotRequired {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForwardingAudienceOverrideNotRequired$Type = ($ForwardingAudienceOverrideNotRequired);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForwardingAudienceOverrideNotRequired_ = $ForwardingAudienceOverrideNotRequired$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$BackgroundSamplerManager" {
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$Configuration, $Configuration$Type} from "packages/me/lucko/spark/common/util/$Configuration"

export class $BackgroundSamplerManager {

constructor(arg0: $SparkPlatform$Type, arg1: $Configuration$Type)

public "restartBackgroundSampler"(): boolean
public "initialise"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BackgroundSamplerManager$Type = ($BackgroundSamplerManager);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BackgroundSamplerManager_ = $BackgroundSamplerManager$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/aggregator/$DataAggregator" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"

export interface $DataAggregator {

 "pruneData"(arg0: $IntPredicate$Type): void
 "exportData"(): $List<($ThreadNode)>
 "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
}

export namespace $DataAggregator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataAggregator$Type = ($DataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataAggregator_ = $DataAggregator$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeWorldInfoProvider" {
import {$WorldInfoProvider$ChunksResult, $WorldInfoProvider$ChunksResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$ChunksResult"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$WorldInfoProvider$CountsResult, $WorldInfoProvider$CountsResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$CountsResult"

export class $ForgeWorldInfoProvider implements $WorldInfoProvider {

constructor()

public "mustCallSync"(): boolean
public "pollCounts"(): $WorldInfoProvider$CountsResult
public "pollChunks"(): $WorldInfoProvider$ChunksResult<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeWorldInfoProvider$Type = ($ForgeWorldInfoProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeWorldInfoProvider_ = $ForgeWorldInfoProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfigImpl" {
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $TextReplacementConfigImpl implements $TextReplacementConfig {


public "toString"(): string
public "examinableProperties"(): $Stream<(any)>
public "matchPattern"(): $Pattern
public static "builder"(): $TextReplacementConfig$Builder
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $TextReplacementConfig$Builder$Type, consumer: $Consumer$Type<(any)>): $TextReplacementConfig
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementConfigImpl$Type = ($TextReplacementConfigImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementConfigImpl_ = $TextReplacementConfigImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os$Builder" {
import {$SparkProtos$SystemStatistics$Os, $SparkProtos$SystemStatistics$Os$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$OsOrBuilder, $SparkProtos$SystemStatistics$OsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$OsOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkProtos$SystemStatistics$Os$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Os), ($SparkProtos$SystemStatistics$Os$Builder)> implements $SparkProtos$SystemStatistics$OsOrBuilder {


public "getName"(): string
public "setName"(arg0: string): $SparkProtos$SystemStatistics$Os$Builder
public "getVersion"(): string
public "setVersion"(arg0: string): $SparkProtos$SystemStatistics$Os$Builder
public "getArch"(): string
public "setNameBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Os$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkProtos$SystemStatistics$Os$Builder
public "getVersionBytes"(): $ByteString
public "setArch"(arg0: string): $SparkProtos$SystemStatistics$Os$Builder
public "clearVersion"(): $SparkProtos$SystemStatistics$Os$Builder
public "setVersionBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Os$Builder
public "setArchBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Os$Builder
public "getArchBytes"(): $ByteString
public "clearArch"(): $SparkProtos$SystemStatistics$Os$Builder
get "name"(): string
set "name"(value: string)
get "version"(): string
set "version"(value: string)
get "arch"(): string
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "versionBytes"(): $ByteString
set "arch"(value: string)
set "versionBytes"(value: $ByteString$Type)
set "archBytes"(value: $ByteString$Type)
get "archBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Os$Builder$Type = ($SparkProtos$SystemStatistics$Os$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Os$Builder_ = $SparkProtos$SystemStatistics$Os$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$ControlFrame" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$FramedataImpl1, $FramedataImpl1$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$FramedataImpl1"

export class $ControlFrame extends $FramedataImpl1 {

constructor(arg0: $Opcode$Type)

public "isValid"(): void
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ControlFrame$Type = ($ControlFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ControlFrame_ = $ControlFrame$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$PageCommandFunction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Pagination$PageCommandFunction {

 "pageCommand"(page: integer): string

(page: integer): string
}

export namespace $Pagination$PageCommandFunction {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$PageCommandFunction$Type = ($Pagination$PageCommandFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination$PageCommandFunction_ = $Pagination$PageCommandFunction$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Type" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkProtos$CommandSenderMetadata$Type extends $Enum<($SparkProtos$CommandSenderMetadata$Type)> implements $Internal$EnumLite {
static readonly "OTHER": $SparkProtos$CommandSenderMetadata$Type
static readonly "PLAYER": $SparkProtos$CommandSenderMetadata$Type
static readonly "UNRECOGNIZED": $SparkProtos$CommandSenderMetadata$Type
static readonly "OTHER_VALUE": integer
static readonly "PLAYER_VALUE": integer


public static "values"(): ($SparkProtos$CommandSenderMetadata$Type)[]
public static "valueOf"(arg0: string): $SparkProtos$CommandSenderMetadata$Type
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkProtos$CommandSenderMetadata$Type
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkProtos$CommandSenderMetadata$Type)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkProtos$CommandSenderMetadata$Type
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$CommandSenderMetadata$Type$Type = (("other") | ("unrecognized") | ("player")) | ($SparkProtos$CommandSenderMetadata$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$CommandSenderMetadata$Type_ = $SparkProtos$CommandSenderMetadata$Type$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$LongList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$LongList extends $Internal$ProtobufList<(long)> {

 "getLong"(arg0: integer): long
 "setLong"(arg0: integer, arg1: long): long
 "addLong"(arg0: long): void
 "mutableCopyWithCapacity"(arg0: integer): $Internal$LongList
 "makeImmutable"(): void
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: long): void
 "add"(arg0: long): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): long
 "get"(arg0: integer): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(long)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(long)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(long)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(long)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: long): long
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(long)>
 "listIterator"(): $ListIterator<(long)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(long)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(long)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$LongList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
function of<E>(arg0: long, arg1: long): $List<(long)>
function of<E>(arg0: long): $List<(long)>
function of<E>(): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
function of<E>(...arg0: (long)[]): $List<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$LongList$Type = ($Internal$LongList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$LongList_ = $Internal$LongList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentCompaction" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ComponentCompaction {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentCompaction$Type = ($ComponentCompaction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentCompaction_ = $ComponentCompaction$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$TimestampOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $TimestampOrBuilder extends $MessageLiteOrBuilder {

 "getSeconds"(): long
 "getNanos"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $TimestampOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimestampOrBuilder$Type = ($TimestampOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimestampOrBuilder_ = $TimestampOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IProtocol {

 "acceptProvidedProtocol"(arg0: string): boolean
 "getProvidedProtocol"(): string
 "toString"(): string
 "copyInstance"(): $IProtocol
}

export namespace $IProtocol {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IProtocol$Type = ($IProtocol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IProtocol_ = $IProtocol$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $Framedata {

 "append"(arg0: $Framedata$Type): void
 "getOpcode"(): $Opcode
 "isRSV2"(): boolean
 "isFin"(): boolean
 "isRSV3"(): boolean
 "isRSV1"(): boolean
 "getTransfereMasked"(): boolean
 "getPayloadData"(): $ByteBuffer
}

export namespace $Framedata {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Framedata$Type = ($Framedata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Framedata_ = $Framedata$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$ForwardingIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $ForwardingIterator<T> implements $Iterable<(T)> {

constructor(iterator: $Supplier$Type<($Iterator$Type<(T)>)>, spliterator: $Supplier$Type<($Spliterator$Type<(T)>)>)

public "iterator"(): $Iterator<(T)>
public "spliterator"(): $Spliterator<(T)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
[Symbol.iterator](): IterableIterator<T>;
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForwardingIterator$Type<T> = ($ForwardingIterator<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForwardingIterator_<T> = $ForwardingIterator$Type<(T)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkWebSocketProtos$ServerConnectResponse$Settings, $SparkWebSocketProtos$ServerConnectResponse$Settings$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkWebSocketProtos$ServerConnectResponseOrBuilder, $SparkWebSocketProtos$ServerConnectResponseOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponseOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkWebSocketProtos$ServerConnectResponse$Builder, $SparkWebSocketProtos$ServerConnectResponse$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Builder"
import {$SparkWebSocketProtos$ServerConnectResponse$State, $SparkWebSocketProtos$ServerConnectResponse$State$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$State"

export class $SparkWebSocketProtos$ServerConnectResponse extends $GeneratedMessageLite<($SparkWebSocketProtos$ServerConnectResponse), ($SparkWebSocketProtos$ServerConnectResponse$Builder)> implements $SparkWebSocketProtos$ServerConnectResponseOrBuilder {
static readonly "CLIENT_ID_FIELD_NUMBER": integer
static readonly "STATE_FIELD_NUMBER": integer
static readonly "SETTINGS_FIELD_NUMBER": integer
static readonly "LAST_PAYLOAD_ID_FIELD_NUMBER": integer


public "getState"(): $SparkWebSocketProtos$ServerConnectResponse$State
public static "parser"(): $Parser<($SparkWebSocketProtos$ServerConnectResponse)>
public static "newBuilder"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public static "newBuilder"(): $SparkWebSocketProtos$ServerConnectResponse$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "getDefaultInstance"(): $SparkWebSocketProtos$ServerConnectResponse
public "getClientId"(): string
public "getSettings"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerConnectResponse
public "getClientIdBytes"(): $ByteString
public "hasSettings"(): boolean
public "getStateValue"(): integer
public "getLastPayloadId"(): string
public "getLastPayloadIdBytes"(): $ByteString
get "state"(): $SparkWebSocketProtos$ServerConnectResponse$State
get "defaultInstance"(): $SparkWebSocketProtos$ServerConnectResponse
get "clientId"(): string
get "settings"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
get "clientIdBytes"(): $ByteString
get "stateValue"(): integer
get "lastPayloadId"(): string
get "lastPayloadIdBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$Type = ($SparkWebSocketProtos$ServerConnectResponse);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse_ = $SparkWebSocketProtos$ServerConnectResponse$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Reader" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Reader {

 "shouldDiscardUnknownFields"(): boolean
 "readStringRequireUtf8"(): string
 "readStringListRequireUtf8"(arg0: $List$Type<(string)>): void
/**
 * 
 * @deprecated
 */
 "readGroupBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
 "readMessageBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
 "readBytes"(): $ByteString
 "readFloat"(): float
 "readDouble"(): double
 "readString"(): string
 "getTag"(): integer
 "getFieldNumber"(): integer
 "skipField"(): boolean
 "readUInt64"(): long
 "readInt64"(): long
/**
 * 
 * @deprecated
 */
 "readGroup"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
 "readSFixed64"(): long
 "readFloatList"(arg0: $List$Type<(float)>): void
 "readBoolList"(arg0: $List$Type<(boolean)>): void
 "readMessage"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
 "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
 "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
 "readBool"(): boolean
 "readFixed32"(): integer
 "readDoubleList"(arg0: $List$Type<(double)>): void
 "readUInt32"(): integer
 "readSInt64"(): long
 "mergeGroupField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
 "readInt64List"(arg0: $List$Type<(long)>): void
 "readFixed64List"(arg0: $List$Type<(long)>): void
 "readInt32List"(arg0: $List$Type<(integer)>): void
 "readFixed64"(): long
 "readSFixed32"(): integer
 "readSInt32"(): integer
 "readFixed32List"(arg0: $List$Type<(integer)>): void
 "readStringList"(arg0: $List$Type<(string)>): void
 "readUInt64List"(arg0: $List$Type<(long)>): void
 "readInt32"(): integer
 "mergeMessageField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
 "readSInt64List"(arg0: $List$Type<(long)>): void
 "readBytesList"(arg0: $List$Type<($ByteString$Type)>): void
 "readSInt32List"(arg0: $List$Type<(integer)>): void
 "readSFixed32List"(arg0: $List$Type<(integer)>): void
/**
 * 
 * @deprecated
 */
 "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
/**
 * 
 * @deprecated
 */
 "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
 "readEnumList"(arg0: $List$Type<(integer)>): void
 "readSFixed64List"(arg0: $List$Type<(long)>): void
 "readUInt32List"(arg0: $List$Type<(integer)>): void
 "readEnum"(): integer
 "readMap"<K, V>(arg0: $Map$Type<(K), (V)>, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $ExtensionRegistryLite$Type): void
}

export namespace $Reader {
const READ_DONE: integer
const TAG_UNKNOWN: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reader$Type = ($Reader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reader_ = $Reader$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$JfrClass" {
import {$JfrReader$Element, $JfrReader$Element$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Element"

export class $JfrReader$JfrClass extends $JfrReader$Element {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$JfrClass$Type = ($JfrReader$JfrClass);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$JfrClass_ = $JfrReader$JfrClass$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$MethodWriter" {
import {$MethodVisitor, $MethodVisitor$Type} from "packages/me/lucko/spark/lib/asm/$MethodVisitor"
import {$Handle, $Handle$Type} from "packages/me/lucko/spark/lib/asm/$Handle"
import {$Label, $Label$Type} from "packages/me/lucko/spark/lib/asm/$Label"
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $MethodWriter extends $MethodVisitor {


public "visitFrame"(arg0: integer, arg1: integer, arg2: (any)[], arg3: integer, arg4: (any)[]): void
public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitCode"(): void
public "visitFieldInsn"(arg0: integer, arg1: string, arg2: string, arg3: string): void
public "visitInsn"(arg0: integer): void
public "visitMaxs"(arg0: integer, arg1: integer): void
public "visitVarInsn"(arg0: integer, arg1: integer): void
public "visitMethodInsn"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: boolean): void
public "visitTypeInsn"(arg0: integer, arg1: string): void
public "visitIntInsn"(arg0: integer, arg1: integer): void
public "visitLdcInsn"(arg0: any): void
public "visitParameter"(arg0: string, arg1: integer): void
public "visitAnnotationDefault"(): $AnnotationVisitor
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAnnotableParameterCount"(arg0: integer, arg1: boolean): void
public "visitParameterAnnotation"(arg0: integer, arg1: string, arg2: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
public "visitInvokeDynamicInsn"(arg0: string, arg1: string, arg2: $Handle$Type, ...arg3: (any)[]): void
public "visitJumpInsn"(arg0: integer, arg1: $Label$Type): void
public "visitLabel"(arg0: $Label$Type): void
public "visitIincInsn"(arg0: integer, arg1: integer): void
public "visitTableSwitchInsn"(arg0: integer, arg1: integer, arg2: $Label$Type, ...arg3: ($Label$Type)[]): void
public "visitLookupSwitchInsn"(arg0: $Label$Type, arg1: (integer)[], arg2: ($Label$Type)[]): void
public "visitMultiANewArrayInsn"(arg0: string, arg1: integer): void
public "visitInsnAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitTryCatchBlock"(arg0: $Label$Type, arg1: $Label$Type, arg2: $Label$Type, arg3: string): void
public "visitTryCatchAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitLocalVariable"(arg0: string, arg1: string, arg2: string, arg3: $Label$Type, arg4: $Label$Type, arg5: integer): void
public "visitLocalVariableAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: ($Label$Type)[], arg3: ($Label$Type)[], arg4: (integer)[], arg5: string, arg6: boolean): $AnnotationVisitor
public "visitLineNumber"(arg0: integer, arg1: $Label$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodWriter$Type = ($MethodWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodWriter_ = $MethodWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$RecordComponentWriter" {
import {$RecordComponentVisitor, $RecordComponentVisitor$Type} from "packages/me/lucko/spark/lib/asm/$RecordComponentVisitor"
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $RecordComponentWriter extends $RecordComponentVisitor {


public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RecordComponentWriter$Type = ($RecordComponentWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RecordComponentWriter_ = $RecordComponentWriter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode" {
import {$SparkSamplerProtos$StackTraceNodeOrBuilder, $SparkSamplerProtos$StackTraceNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNodeOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$StackTraceNode$Builder, $SparkSamplerProtos$StackTraceNode$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode$Builder"

export class $SparkSamplerProtos$StackTraceNode extends $GeneratedMessageLite<($SparkSamplerProtos$StackTraceNode), ($SparkSamplerProtos$StackTraceNode$Builder)> implements $SparkSamplerProtos$StackTraceNodeOrBuilder {
static readonly "CLASS_NAME_FIELD_NUMBER": integer
static readonly "METHOD_NAME_FIELD_NUMBER": integer
static readonly "PARENT_LINE_NUMBER_FIELD_NUMBER": integer
static readonly "LINE_NUMBER_FIELD_NUMBER": integer
static readonly "METHOD_DESC_FIELD_NUMBER": integer
static readonly "TIMES_FIELD_NUMBER": integer
static readonly "CHILDREN_REFS_FIELD_NUMBER": integer


public "getTimesList"(): $List<(double)>
public "getChildrenRefs"(arg0: integer): integer
public "getTimesCount"(): integer
public "getLineNumber"(): integer
public "getClassName"(): string
public "getMethodName"(): string
public static "parser"(): $Parser<($SparkSamplerProtos$StackTraceNode)>
public static "newBuilder"(arg0: $SparkSamplerProtos$StackTraceNode$Type): $SparkSamplerProtos$StackTraceNode$Builder
public static "newBuilder"(): $SparkSamplerProtos$StackTraceNode$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$StackTraceNode
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public static "getDefaultInstance"(): $SparkSamplerProtos$StackTraceNode
public "getTimes"(arg0: integer): double
public "getMethodDesc"(): string
public "getParentLineNumber"(): integer
public "getClassNameBytes"(): $ByteString
public "getMethodNameBytes"(): $ByteString
public "getMethodDescBytes"(): $ByteString
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$StackTraceNode
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$StackTraceNode
public "getChildrenRefsList"(): $List<(integer)>
public "getChildrenRefsCount"(): integer
get "timesList"(): $List<(double)>
get "timesCount"(): integer
get "lineNumber"(): integer
get "className"(): string
get "methodName"(): string
get "defaultInstance"(): $SparkSamplerProtos$StackTraceNode
get "methodDesc"(): string
get "parentLineNumber"(): integer
get "classNameBytes"(): $ByteString
get "methodNameBytes"(): $ByteString
get "methodDescBytes"(): $ByteString
get "childrenRefsList"(): $List<(integer)>
get "childrenRefsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$StackTraceNode$Type = ($SparkSamplerProtos$StackTraceNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$StackTraceNode_ = $SparkSamplerProtos$StackTraceNode$Type;
}}
declare module "packages/me/lucko/spark/common/platform/$PlatformInfo$Type" {
import {$SparkProtos$PlatformMetadata$Type, $SparkProtos$PlatformMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Type"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $PlatformInfo$Type extends $Enum<($PlatformInfo$Type)> {
static readonly "SERVER": $PlatformInfo$Type
static readonly "CLIENT": $PlatformInfo$Type
static readonly "PROXY": $PlatformInfo$Type


public static "values"(): ($PlatformInfo$Type)[]
public static "valueOf"(arg0: string): $PlatformInfo$Type
public "toProto"(): $SparkProtos$PlatformMetadata$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformInfo$Type$Type = (("server") | ("proxy") | ("client")) | ($PlatformInfo$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformInfo$Type_ = $PlatformInfo$Type$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$IndexedSerializer" {
import {$JsonReader, $JsonReader$Type} from "packages/com/google/gson/stream/$JsonReader"
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"

export class $IndexedSerializer<E> extends $TypeAdapter<(E)> {


public "write"(out: $JsonWriter$Type, value: E): void
public "read"(arg0: $JsonReader$Type): E
public static "strict"<E>(name: string, map: $Index$Type<(string), (E)>): $TypeAdapter<(E)>
public static "lenient"<E>(name: string, map: $Index$Type<(string), (E)>): $TypeAdapter<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IndexedSerializer$Type<E> = ($IndexedSerializer<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IndexedSerializer_<E> = $IndexedSerializer$Type<(E)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder, $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper, $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type"

export class $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SamplerMetadata$DataAggregator), ($SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder)> implements $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder {


public "setNumberOfIncludedTicks"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "setTickLengthThreshold"(arg0: long): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "getType"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
public "setType"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "setThreadGrouper"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "getTypeValue"(): integer
public "getThreadGrouperValue"(): integer
public "setThreadGrouperValue"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "getTickLengthThreshold"(): long
public "clearTickLengthThreshold"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "getNumberOfIncludedTicks"(): integer
public "clearNumberOfIncludedTicks"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "clearType"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "getThreadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
public "setTypeValue"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public "clearThreadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
set "numberOfIncludedTicks"(value: integer)
set "tickLengthThreshold"(value: long)
get "type"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
set "type"(value: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type)
set "threadGrouper"(value: $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type)
get "typeValue"(): integer
get "threadGrouperValue"(): integer
set "threadGrouperValue"(value: integer)
get "tickLengthThreshold"(): long
get "numberOfIncludedTicks"(): integer
get "threadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
set "typeValue"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type = ($SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder_ = $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ScoreComponent extends $BuildableComponent<($ScoreComponent), ($ScoreComponent$Builder)>, $ScopedComponent<($ScoreComponent)> {

 "name"(): string
 "name"(name: string): $ScoreComponent
/**
 * 
 * @deprecated
 */
 "value"(): string
/**
 * 
 * @deprecated
 */
 "value"(value: string): $ScoreComponent
 "examinableProperties"(): $Stream<(any)>
 "objective"(): string
 "objective"(objective: string): $ScoreComponent
 "toBuilder"(): $ScoreComponent$Builder
 "append"(component: $Component$Type): $ScoreComponent
 "append"(like: $ComponentLike$Type): $ScoreComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $ScoreComponent
 "color"(color: $TextColor$Type): $ScoreComponent
 "style"(style: $Style$Type): $ScoreComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $ScoreComponent
 "style"(style: $Style$Builder$Type): $ScoreComponent
 "children"(children: $List$Type<(any)>): $ScoreComponent
 "mergeStyle"(that: $Component$Type): $ScoreComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $ScoreComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $ScoreComponent
 "colorIfAbsent"(color: $TextColor$Type): $ScoreComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $ScoreComponent
 "clickEvent"(event: $ClickEvent$Type): $ScoreComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $ScoreComponent
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $ScoreComponent {
function configureAndBuild<R, B>(builder: $ScoreComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $ScoreComponent
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScoreComponent$Type = ($ScoreComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScoreComponent_ = $ScoreComponent$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$TickHook" {
import {$TickHook$Callback, $TickHook$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickHook$Callback"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"

export interface $TickHook extends $AutoCloseable {

 "start"(): void
 "close"(): void
 "getCurrentTick"(): integer
 "removeCallback"(arg0: $TickHook$Callback$Type): void
 "addCallback"(arg0: $TickHook$Callback$Type): void
}

export namespace $TickHook {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickHook$Type = ($TickHook);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickHook_ = $TickHook$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$SSLParametersWebSocketServerFactory" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SSLContext, $SSLContext$Type} from "packages/javax/net/ssl/$SSLContext"
import {$SSLParameters, $SSLParameters$Type} from "packages/javax/net/ssl/$SSLParameters"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$DefaultSSLWebSocketServerFactory, $DefaultSSLWebSocketServerFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/server/$DefaultSSLWebSocketServerFactory"

export class $SSLParametersWebSocketServerFactory extends $DefaultSSLWebSocketServerFactory {

constructor(arg0: $SSLContext$Type, arg1: $SSLParameters$Type)
constructor(arg0: $SSLContext$Type, arg1: $ExecutorService$Type, arg2: $SSLParameters$Type)

public "wrapChannel"(arg0: $SocketChannel$Type, arg1: $SelectionKey$Type): $ByteChannel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SSLParametersWebSocketServerFactory$Type = ($SSLParametersWebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SSLParametersWebSocketServerFactory_ = $SSLParametersWebSocketServerFactory$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$WorldStatistics$ChunkOrBuilder, $SparkProtos$WorldStatistics$ChunkOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$ChunkOrBuilder"
import {$SparkProtos$WorldStatistics$Chunk, $SparkProtos$WorldStatistics$Chunk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$WorldStatistics$Chunk$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$WorldStatistics$Chunk), ($SparkProtos$WorldStatistics$Chunk$Builder)> implements $SparkProtos$WorldStatistics$ChunkOrBuilder {


public "putAllEntityCounts"(arg0: $Map$Type<(string), (integer)>): $SparkProtos$WorldStatistics$Chunk$Builder
public "removeEntityCounts"(arg0: string): $SparkProtos$WorldStatistics$Chunk$Builder
public "clearEntityCounts"(): $SparkProtos$WorldStatistics$Chunk$Builder
public "setX"(arg0: integer): $SparkProtos$WorldStatistics$Chunk$Builder
public "getZ"(): integer
public "setZ"(arg0: integer): $SparkProtos$WorldStatistics$Chunk$Builder
public "getX"(): integer
public "containsEntityCounts"(arg0: string): boolean
public "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
public "getEntityCountsCount"(): integer
public "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
public "getEntityCounts"(): $Map<(string), (integer)>
public "getEntityCountsMap"(): $Map<(string), (integer)>
public "clearTotalEntities"(): $SparkProtos$WorldStatistics$Chunk$Builder
public "clearX"(): $SparkProtos$WorldStatistics$Chunk$Builder
public "clearZ"(): $SparkProtos$WorldStatistics$Chunk$Builder
public "setTotalEntities"(arg0: integer): $SparkProtos$WorldStatistics$Chunk$Builder
public "putEntityCounts"(arg0: string, arg1: integer): $SparkProtos$WorldStatistics$Chunk$Builder
public "getTotalEntities"(): integer
set "x"(value: integer)
get "z"(): integer
set "z"(value: integer)
get "x"(): integer
get "entityCountsCount"(): integer
get "entityCounts"(): $Map<(string), (integer)>
get "entityCountsMap"(): $Map<(string), (integer)>
set "totalEntities"(value: integer)
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Chunk$Builder$Type = ($SparkProtos$WorldStatistics$Chunk$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$Chunk$Builder_ = $SparkProtos$WorldStatistics$Chunk$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ComponentIteratorFlag extends $Enum<($ComponentIteratorFlag)> {
static readonly "INCLUDE_HOVER_SHOW_ENTITY_NAME": $ComponentIteratorFlag
static readonly "INCLUDE_HOVER_SHOW_TEXT_COMPONENT": $ComponentIteratorFlag
static readonly "INCLUDE_TRANSLATABLE_COMPONENT_ARGUMENTS": $ComponentIteratorFlag


public static "values"(): ($ComponentIteratorFlag)[]
public static "valueOf"(name: string): $ComponentIteratorFlag
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentIteratorFlag$Type = (("include_translatable_component_arguments") | ("include_hover_show_entity_name") | ("include_hover_show_text_component")) | ($ComponentIteratorFlag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentIteratorFlag_ = $ComponentIteratorFlag$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SchemaUtil" {
import {$UnknownFieldSchema, $UnknownFieldSchema$Type} from "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSchema"
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$FieldInfo, $FieldInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldInfo"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"

export class $SchemaUtil {


public static "unknownFieldSetLiteSchema"(): $UnknownFieldSchema<(any), (any)>
public static "requireGeneratedMessage"(arg0: $Class$Type<(any)>): void
public static "proto2UnknownFieldSetSchema"(): $UnknownFieldSchema<(any), (any)>
public static "proto3UnknownFieldSetSchema"(): $UnknownFieldSchema<(any), (any)>
public static "shouldUseTableSwitch"(arg0: ($FieldInfo$Type)[]): boolean
public static "shouldUseTableSwitch"(arg0: integer, arg1: integer, arg2: integer): boolean
public static "writeBytes"(arg0: integer, arg1: $ByteString$Type, arg2: $Writer$Type): void
public static "writeFloat"(arg0: integer, arg1: float, arg2: $Writer$Type): void
public static "writeDouble"(arg0: integer, arg1: double, arg2: $Writer$Type): void
public static "writeString"(arg0: integer, arg1: any, arg2: $Writer$Type): void
public static "writeLazyFieldList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Writer$Type): void
public static "writeSInt64"(arg0: integer, arg1: long, arg2: $Writer$Type): void
public static "writeMessage"(arg0: integer, arg1: any, arg2: $Writer$Type): void
public static "writeUInt64"(arg0: integer, arg1: long, arg2: $Writer$Type): void
public static "writeInt32"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
public static "writeInt64"(arg0: integer, arg1: long, arg2: $Writer$Type): void
public static "writeFixed32"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
public static "writeUInt32"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
public static "writeSFixed32"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
public static "writeSFixed64"(arg0: integer, arg1: long, arg2: $Writer$Type): void
public static "writeFixed64"(arg0: integer, arg1: long, arg2: $Writer$Type): void
public static "writeSInt32"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
public static "writeBool"(arg0: integer, arg1: boolean, arg2: $Writer$Type): void
public static "writeUInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeFloatList"(arg0: integer, arg1: $List$Type<(float)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeDoubleList"(arg0: integer, arg1: $List$Type<(double)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeUInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeSFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeBoolList"(arg0: integer, arg1: $List$Type<(boolean)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Writer$Type, arg3: $Schema$Type<(any)>): void
public static "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Writer$Type): void
public static "writeSFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeSInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeBytesList"(arg0: integer, arg1: $List$Type<($ByteString$Type)>, arg2: $Writer$Type): void
public static "writeStringList"(arg0: integer, arg1: $List$Type<(string)>, arg2: $Writer$Type): void
public static "writeInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Writer$Type, arg3: $Schema$Type<(any)>): void
public static "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Writer$Type): void
public static "writeSInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeEnumList"(arg0: integer, arg1: $List$Type<(integer)>, arg2: $Writer$Type, arg3: boolean): void
public static "writeEnum"(arg0: integer, arg1: integer, arg2: $Writer$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchemaUtil$Type = ($SchemaUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchemaUtil_ = $SchemaUtil$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$AbstractWrappedByteChannel" {
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$WrappedByteChannel, $WrappedByteChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WrappedByteChannel"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

/**
 * 
 * @deprecated
 */
export class $AbstractWrappedByteChannel implements $WrappedByteChannel {

/**
 * 
 * @deprecated
 */
constructor(arg0: $ByteChannel$Type)
/**
 * 
 * @deprecated
 */
constructor(arg0: $WrappedByteChannel$Type)

public "isOpen"(): boolean
public "write"(arg0: $ByteBuffer$Type): integer
public "read"(arg0: $ByteBuffer$Type): integer
public "close"(): void
public "isBlocking"(): boolean
public "isNeedWrite"(): boolean
public "writeMore"(): void
public "isNeedRead"(): boolean
public "readMore"(arg0: $ByteBuffer$Type): integer
get "open"(): boolean
get "blocking"(): boolean
get "needWrite"(): boolean
get "needRead"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractWrappedByteChannel$Type = ($AbstractWrappedByteChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractWrappedByteChannel_ = $AbstractWrappedByteChannel$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Codec$Decoder" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $Codec$Decoder<D, E, X extends $Throwable> {

 "decode"(encoded: E): D

(encoded: E): D
}

export namespace $Codec$Decoder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Codec$Decoder$Type<D, E, X> = ($Codec$Decoder<(D), (E), (X)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Codec$Decoder_<D, E, X> = $Codec$Decoder$Type<(D), (E), (X)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$OneofInfo" {
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"

export class $OneofInfo {

constructor(arg0: integer, arg1: $Field$Type, arg2: $Field$Type)

public "getId"(): integer
public "getValueField"(): $Field
public "getCaseField"(): $Field
get "id"(): integer
get "valueField"(): $Field
get "caseField"(): $Field
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OneofInfo$Type = ($OneofInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OneofInfo_ = $OneofInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

/**
 * 
 * @deprecated
 */
export class $AbstractComponent implements $Component {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "style"(): $Style
public "children"(): $List<($Component)>
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $Component
public "append"(like: $ComponentLike$Type): $Component
public "append"(component: $Component$Type): $Component
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
public "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
public "contains"(that: $Component$Type): boolean
public "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
public "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
public "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
public static "empty"(): $TextComponent
public "color"(color: $TextColor$Type): $Component
public "color"(): $TextColor
public "compact"(): $Component
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public "style"(style: $Style$Type): $Component
public "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Component
public "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
public "style"(style: $Style$Builder$Type): $Component
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public "children"(children: $List$Type<(any)>): $Component
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public "appendNewline"(): $Component
public "mergeStyle"(that: $Component$Type): $Component
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $Component
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $Component
/**
 * 
 * @deprecated
 */
public "detectCycle"(that: $Component$Type): void
public "applyFallbackStyle"(style: $Style$Type): $Component
public "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
public "colorIfAbsent"(color: $TextColor$Type): $Component
public "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
public "hasStyling"(): boolean
public "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
public "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
public "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
public "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
public "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
public "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public "examinableProperties"(): $Stream<(any)>
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public "asComponent"(): $Component
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Component
public "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
public "decorate"(decoration: $TextDecoration$Type): $Component
public "hasDecoration"(decoration: $TextDecoration$Type): boolean
public "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
public "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
public "font"(): $Key
public "appendSpace"(): $Component
public "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
public "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
public "insertion"(): string
public "clickEvent"(event: $ClickEvent$Type): $Component
public "clickEvent"(): $ClickEvent
public "hoverEvent"(): $HoverEvent<(any)>
public "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Component
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
public "asHoverEvent"(): $HoverEvent<($Component)>
public "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
public "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractComponent$Type = ($AbstractComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractComponent_ = $AbstractComponent$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$CpuOrBuilder" {
import {$SparkProtos$SystemStatistics$Cpu$Usage, $SparkProtos$SystemStatistics$Cpu$Usage$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$CpuOrBuilder extends $MessageLiteOrBuilder {

 "getThreads"(): integer
 "getModelName"(): string
 "hasProcessUsage"(): boolean
 "getProcessUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
 "hasSystemUsage"(): boolean
 "getSystemUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
 "getModelNameBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$CpuOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$CpuOrBuilder$Type = ($SparkProtos$SystemStatistics$CpuOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$CpuOrBuilder_ = $SparkProtos$SystemStatistics$CpuOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$Keyed" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"

export interface $Keyed {

 "key"(): $Key

(): $Key
}

export namespace $Keyed {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Keyed$Type = ($Keyed);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Keyed_ = $Keyed$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$ShadyPines" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ShadyPines {


public static "equals"(a: float, b: float): boolean
public static "equals"(a: double, b: double): boolean
/**
 * 
 * @deprecated
 */
public static "enumSet"<E extends $Enum<(E)>>(type: $Class$Type<(E)>, ...constants: (E)[]): $Set<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShadyPines$Type = ($ShadyPines);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShadyPines_ = $ShadyPines$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$LegacyHoverEventSerializer" {
import {$HoverEvent$ShowItem, $HoverEvent$ShowItem$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowItem"
import {$Codec$Encoder, $Codec$Encoder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec$Encoder"
import {$HoverEvent$ShowEntity, $HoverEvent$ShowEntity$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowEntity"
import {$Codec$Decoder, $Codec$Decoder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec$Decoder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $LegacyHoverEventSerializer {

 "serializeShowItem"(input: $HoverEvent$ShowItem$Type): $Component
 "deserializeShowItem"(input: $Component$Type): $HoverEvent$ShowItem
 "deserializeShowEntity"(input: $Component$Type, componentDecoder: $Codec$Decoder$Type<($Component$Type), (string), (any)>): $HoverEvent$ShowEntity
 "serializeShowEntity"(input: $HoverEvent$ShowEntity$Type, componentEncoder: $Codec$Encoder$Type<($Component$Type), (string), (any)>): $Component
}

export namespace $LegacyHoverEventSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyHoverEventSerializer$Type = ($LegacyHoverEventSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyHoverEventSerializer_ = $LegacyHoverEventSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$JavaType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $JavaType extends $Enum<($JavaType)> {
static readonly "VOID": $JavaType
static readonly "INT": $JavaType
static readonly "LONG": $JavaType
static readonly "FLOAT": $JavaType
static readonly "DOUBLE": $JavaType
static readonly "BOOLEAN": $JavaType
static readonly "STRING": $JavaType
static readonly "BYTE_STRING": $JavaType
static readonly "ENUM": $JavaType
static readonly "MESSAGE": $JavaType


public static "values"(): ($JavaType)[]
public static "valueOf"(arg0: string): $JavaType
public "getType"(): $Class<(any)>
public "getDefaultDefault"(): any
public "getBoxedType"(): $Class<(any)>
public "isValidType"(arg0: $Class$Type<(any)>): boolean
get "type"(): $Class<(any)>
get "defaultDefault"(): any
get "boxedType"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaType$Type = (("void") | ("boolean") | ("string") | ("double") | ("byte_string") | ("float") | ("message") | ("int") | ("long") | ("enum")) | ($JavaType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaType_ = $JavaType$Type;
}}
declare module "packages/me/lucko/spark/common/ws/$TrustedKeyStore" {
import {$PublicKey, $PublicKey$Type} from "packages/java/security/$PublicKey"
import {$PrivateKey, $PrivateKey$Type} from "packages/java/security/$PrivateKey"
import {$Configuration, $Configuration$Type} from "packages/me/lucko/spark/common/util/$Configuration"

export class $TrustedKeyStore {

constructor(arg0: $Configuration$Type)

public "getLocalPublicKey"(): $PublicKey
public "trustPendingKey"(arg0: string): boolean
public "getLocalPrivateKey"(): $PrivateKey
public "isKeyTrusted"(arg0: $PublicKey$Type): boolean
public "addPendingKey"(arg0: string, arg1: $PublicKey$Type): void
get "localPublicKey"(): $PublicKey
get "localPrivateKey"(): $PrivateKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TrustedKeyStore$Type = ($TrustedKeyStore);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TrustedKeyStore_ = $TrustedKeyStore$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$SparkProtos$SystemStatistics$DiskOrBuilder, $SparkProtos$SystemStatistics$DiskOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$DiskOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$SystemStatistics$Disk$Builder, $SparkProtos$SystemStatistics$Disk$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk$Builder"

export class $SparkProtos$SystemStatistics$Disk extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Disk), ($SparkProtos$SystemStatistics$Disk$Builder)> implements $SparkProtos$SystemStatistics$DiskOrBuilder {
static readonly "USED_FIELD_NUMBER": integer
static readonly "TOTAL_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Disk)>
public static "newBuilder"(): $SparkProtos$SystemStatistics$Disk$Builder
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Disk$Type): $SparkProtos$SystemStatistics$Disk$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Disk
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Disk
public "getTotal"(): long
public "getUsed"(): long
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Disk
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Disk
get "defaultInstance"(): $SparkProtos$SystemStatistics$Disk
get "total"(): long
get "used"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Disk$Type = ($SparkProtos$SystemStatistics$Disk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Disk_ = $SparkProtos$SystemStatistics$Disk$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SmallSortedMap" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$AbstractMap, $AbstractMap$Type} from "packages/java/util/$AbstractMap"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SmallSortedMap<K extends $Comparable<(K)>, V> extends $AbstractMap<(K), (V)> {


public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clear"(): void
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<(K), (V)>)>
public "containsKey"(arg0: any): boolean
public "makeImmutable"(): void
public "isImmutable"(): boolean
public "getNumArrayEntries"(): integer
public "getOverflowEntries"(): $Iterable<($Map$Entry<(K), (V)>)>
public "getArrayEntryAt"(arg0: integer): $Map$Entry<(K), (V)>
public "getNumOverflowEntries"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
get "immutable"(): boolean
get "numArrayEntries"(): integer
get "overflowEntries"(): $Iterable<($Map$Entry<(K), (V)>)>
get "numOverflowEntries"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SmallSortedMap$Type<K, V> = ($SmallSortedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SmallSortedMap_<K, V> = $SmallSortedMap$Type<(K), (V)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DurationOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $DurationOrBuilder extends $MessageLiteOrBuilder {

 "getSeconds"(): long
 "getNanos"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $DurationOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DurationOrBuilder$Type = ($DurationOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DurationOrBuilder_ = $DurationOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldSet$Builder" {
import {$FieldSet$FieldDescriptorLite, $FieldSet$FieldDescriptorLite$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet$FieldDescriptorLite"
import {$FieldSet, $FieldSet$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FieldSet$Builder<T extends $FieldSet$FieldDescriptorLite<(T)>> {


public "getField"(arg0: T): any
public "build"(): $FieldSet<(T)>
public "buildPartial"(): $FieldSet<(T)>
public "hasField"(arg0: T): boolean
public "setField"(arg0: T, arg1: any): void
public "getAllFields"(): $Map<(T), (any)>
public "isInitialized"(): boolean
public "mergeFrom"(arg0: $FieldSet$Type<(T)>): void
public "getRepeatedField"(arg0: T, arg1: integer): any
public "setRepeatedField"(arg0: T, arg1: integer, arg2: any): void
public "clearField"(arg0: T): void
public "addRepeatedField"(arg0: T, arg1: any): void
public "getRepeatedFieldCount"(arg0: T): integer
public static "fromFieldSet"<T extends $FieldSet$FieldDescriptorLite<(T)>>(arg0: $FieldSet$Type<(T)>): $FieldSet$Builder<(T)>
get "allFields"(): $Map<(T), (any)>
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldSet$Builder$Type<T> = ($FieldSet$Builder<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldSet$Builder_<T> = $FieldSet$Builder$Type<(T)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SamplerMode" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkSamplerProtos$SamplerMetadata$SamplerMode extends $Enum<($SparkSamplerProtos$SamplerMetadata$SamplerMode)> implements $Internal$EnumLite {
static readonly "EXECUTION": $SparkSamplerProtos$SamplerMetadata$SamplerMode
static readonly "ALLOCATION": $SparkSamplerProtos$SamplerMetadata$SamplerMode
static readonly "UNRECOGNIZED": $SparkSamplerProtos$SamplerMetadata$SamplerMode
static readonly "EXECUTION_VALUE": integer
static readonly "ALLOCATION_VALUE": integer


public static "values"(): ($SparkSamplerProtos$SamplerMetadata$SamplerMode)[]
public static "valueOf"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SamplerMode
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$SamplerMode
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkSamplerProtos$SamplerMetadata$SamplerMode)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$SamplerMode
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type = (("execution") | ("allocation") | ("unrecognized")) | ($SparkSamplerProtos$SamplerMetadata$SamplerMode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$SamplerMode_ = $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/util/$NamedThreadFactory" {
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"
import {$ThreadFactory, $ThreadFactory$Type} from "packages/java/util/concurrent/$ThreadFactory"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $NamedThreadFactory implements $ThreadFactory {

constructor(arg0: string)

public "newThread"(arg0: $Runnable$Type): $Thread
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NamedThreadFactory$Type = ($NamedThreadFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NamedThreadFactory_ = $NamedThreadFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/client/$WebSocketClient" {
import {$Proxy, $Proxy$Type} from "packages/java/net/$Proxy"
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$SSLSession, $SSLSession$Type} from "packages/javax/net/ssl/$SSLSession"
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Socket, $Socket$Type} from "packages/java/net/$Socket"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ReadyState, $ReadyState$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$ReadyState"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$DnsResolver, $DnsResolver$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/client/$DnsResolver"
import {$SocketFactory, $SocketFactory$Type} from "packages/javax/net/$SocketFactory"
import {$AbstractWebSocket, $AbstractWebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$AbstractWebSocket"
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$IProtocol, $IProtocol$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketClient extends $AbstractWebSocket implements $Runnable, $WebSocket {

constructor(arg0: $URI$Type, arg1: $Draft$Type, arg2: $Map$Type<(string), (string)>, arg3: integer)
constructor(arg0: $URI$Type, arg1: $Draft$Type, arg2: $Map$Type<(string), (string)>)
constructor(arg0: $URI$Type, arg1: $Map$Type<(string), (string)>)
constructor(arg0: $URI$Type, arg1: $Draft$Type)
constructor(arg0: $URI$Type)

public "run"(): void
public "isOpen"(): boolean
public "connect"(): void
public "close"(arg0: integer): void
public "close"(arg0: integer, arg1: string): void
public "close"(): void
public "getProtocol"(): $IProtocol
public "onClose"(arg0: integer, arg1: string, arg2: boolean): void
public "getConnection"(): $WebSocket
public "getURI"(): $URI
public "isClosed"(): boolean
public "getSSLSession"(): $SSLSession
public "getRemoteSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "getRemoteSocketAddress"(): $InetSocketAddress
public "getLocalSocketAddress"(): $InetSocketAddress
public "getLocalSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "isClosing"(): boolean
public "getSocket"(): $Socket
public "onMessage"(arg0: $ByteBuffer$Type): void
public "onMessage"(arg0: string): void
public "onOpen"(arg0: $ServerHandshake$Type): void
public "send"(arg0: (byte)[]): void
public "send"(arg0: string): void
public "send"(arg0: $ByteBuffer$Type): void
public "setAttachment"<T>(arg0: T): void
public "addHeader"(arg0: string, arg1: string): void
public "setProxy"(arg0: $Proxy$Type): void
public "closeConnection"(arg0: integer, arg1: string): void
public "sendFrame"(arg0: $Framedata$Type): void
public "sendFrame"(arg0: $Collection$Type<($Framedata$Type)>): void
public "onWebsocketCloseInitiated"(arg0: $WebSocket$Type, arg1: integer, arg2: string): void
public "sendFragmentedFrame"(arg0: $Opcode$Type, arg1: $ByteBuffer$Type, arg2: boolean): void
public "getResourceDescriptor"(): string
public "getAttachment"<T>(): T
public "onError"(arg0: $Exception$Type): void
public "connectBlocking"(arg0: long, arg1: $TimeUnit$Type): boolean
public "connectBlocking"(): boolean
public "onWebsocketClose"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "onWebsocketError"(arg0: $WebSocket$Type, arg1: $Exception$Type): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: string): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: $ByteBuffer$Type): void
public "onWriteDemand"(arg0: $WebSocket$Type): void
public "onWebsocketOpen"(arg0: $WebSocket$Type, arg1: $Handshakedata$Type): void
public "onWebsocketClosing"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "sendPing"(): void
public "getDraft"(): $Draft
public "closeBlocking"(): void
public "reconnect"(): void
public "setDnsResolver"(arg0: $DnsResolver$Type): void
public "clearHeaders"(): void
public "removeHeader"(arg0: string): string
public "reconnectBlocking"(): boolean
public "getReadyState"(): $ReadyState
public "hasSSLSupport"(): boolean
public "onClosing"(arg0: integer, arg1: string, arg2: boolean): void
public "onCloseInitiated"(arg0: integer, arg1: string): void
public "hasBufferedData"(): boolean
/**
 * 
 * @deprecated
 */
public "setSocket"(arg0: $Socket$Type): void
public "isFlushAndClose"(): boolean
public "setSocketFactory"(arg0: $SocketFactory$Type): void
get "open"(): boolean
get "protocol"(): $IProtocol
get "connection"(): $WebSocket
get "uRI"(): $URI
get "closed"(): boolean
get "sSLSession"(): $SSLSession
get "remoteSocketAddress"(): $InetSocketAddress
get "localSocketAddress"(): $InetSocketAddress
get "closing"(): boolean
get "socket"(): $Socket
set "attachment"(value: T)
set "proxy"(value: $Proxy$Type)
get "resourceDescriptor"(): string
get "attachment"(): T
get "draft"(): $Draft
set "dnsResolver"(value: $DnsResolver$Type)
get "readyState"(): $ReadyState
set "socket"(value: $Socket$Type)
get "flushAndClose"(): boolean
set "socketFactory"(value: $SocketFactory$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketClient$Type = ($WebSocketClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketClient_ = $WebSocketClient$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapData$Builder" {
import {$SparkHeapProtos$HeapEntry$Builder, $SparkHeapProtos$HeapEntry$Builder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry$Builder"
import {$SparkHeapProtos$HeapEntry, $SparkHeapProtos$HeapEntry$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry"
import {$SparkHeapProtos$HeapDataOrBuilder, $SparkHeapProtos$HeapDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapDataOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkHeapProtos$HeapData, $SparkHeapProtos$HeapData$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapData"
import {$SparkHeapProtos$HeapMetadata$Builder, $SparkHeapProtos$HeapMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata$Builder"
import {$SparkHeapProtos$HeapMetadata, $SparkHeapProtos$HeapMetadata$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $SparkHeapProtos$HeapData$Builder extends $GeneratedMessageLite$Builder<($SparkHeapProtos$HeapData), ($SparkHeapProtos$HeapData$Builder)> implements $SparkHeapProtos$HeapDataOrBuilder {


public "getEntries"(arg0: integer): $SparkHeapProtos$HeapEntry
public "clearMetadata"(): $SparkHeapProtos$HeapData$Builder
public "setMetadata"(arg0: $SparkHeapProtos$HeapMetadata$Type): $SparkHeapProtos$HeapData$Builder
public "setMetadata"(arg0: $SparkHeapProtos$HeapMetadata$Builder$Type): $SparkHeapProtos$HeapData$Builder
public "mergeMetadata"(arg0: $SparkHeapProtos$HeapMetadata$Type): $SparkHeapProtos$HeapData$Builder
public "getEntriesList"(): $List<($SparkHeapProtos$HeapEntry)>
public "getEntriesCount"(): integer
public "removeEntries"(arg0: integer): $SparkHeapProtos$HeapData$Builder
public "addAllEntries"(arg0: $Iterable$Type<(any)>): $SparkHeapProtos$HeapData$Builder
public "setEntries"(arg0: integer, arg1: $SparkHeapProtos$HeapEntry$Builder$Type): $SparkHeapProtos$HeapData$Builder
public "setEntries"(arg0: integer, arg1: $SparkHeapProtos$HeapEntry$Type): $SparkHeapProtos$HeapData$Builder
public "hasMetadata"(): boolean
public "addEntries"(arg0: $SparkHeapProtos$HeapEntry$Type): $SparkHeapProtos$HeapData$Builder
public "addEntries"(arg0: integer, arg1: $SparkHeapProtos$HeapEntry$Type): $SparkHeapProtos$HeapData$Builder
public "addEntries"(arg0: integer, arg1: $SparkHeapProtos$HeapEntry$Builder$Type): $SparkHeapProtos$HeapData$Builder
public "addEntries"(arg0: $SparkHeapProtos$HeapEntry$Builder$Type): $SparkHeapProtos$HeapData$Builder
public "clearEntries"(): $SparkHeapProtos$HeapData$Builder
public "getMetadata"(): $SparkHeapProtos$HeapMetadata
set "metadata"(value: $SparkHeapProtos$HeapMetadata$Type)
set "metadata"(value: $SparkHeapProtos$HeapMetadata$Builder$Type)
get "entriesList"(): $List<($SparkHeapProtos$HeapEntry)>
get "entriesCount"(): integer
get "metadata"(): $SparkHeapProtos$HeapMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapData$Builder$Type = ($SparkHeapProtos$HeapData$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapData$Builder_ = $SparkHeapProtos$HeapData$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/java/$SimpleDataAggregator" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ThreadInfo, $ThreadInfo$Type} from "packages/java/lang/management/$ThreadInfo"
import {$JavaDataAggregator, $JavaDataAggregator$Type} from "packages/me/lucko/spark/common/sampler/java/$JavaDataAggregator"
import {$ThreadGrouper, $ThreadGrouper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadGrouper"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"

export class $SimpleDataAggregator extends $JavaDataAggregator {

constructor(arg0: $ExecutorService$Type, arg1: $ThreadGrouper$Type, arg2: integer, arg3: boolean, arg4: boolean)

public "insertData"(arg0: $ThreadInfo$Type, arg1: integer): void
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "metadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleDataAggregator$Type = ($SimpleDataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleDataAggregator_ = $SimpleDataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Listener" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $BytesocksClient$Listener {

 "onClose"(arg0: integer, arg1: string): void
 "onOpen"(): void
 "onError"(arg0: $Throwable$Type): void
 "onText"(arg0: string): void
}

export namespace $BytesocksClient$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesocksClient$Listener$Type = ($BytesocksClient$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesocksClient$Listener_ = $BytesocksClient$Listener$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $AbstractBuilder<R> {

 "build"(): R

(): R
}

export namespace $AbstractBuilder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractBuilder$Type<R> = ($AbstractBuilder<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractBuilder_<R> = $AbstractBuilder$Type<(R)>;
}}
declare module "packages/me/lucko/spark/forge/$ForgeTickHook" {
import {$TickHook$Callback, $TickHook$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickHook$Callback"
import {$AbstractTickHook, $AbstractTickHook$Type} from "packages/me/lucko/spark/common/tick/$AbstractTickHook"
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"

export class $ForgeTickHook extends $AbstractTickHook implements $TickHook {

constructor(arg0: $TickEvent$Type$Type)

public "start"(): void
public "close"(): void
public "onTick"(arg0: $TickEvent$Type): void
public "getCurrentTick"(): integer
public "removeCallback"(arg0: $TickHook$Callback$Type): void
public "addCallback"(arg0: $TickHook$Callback$Type): void
get "currentTick"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeTickHook$Type = ($ForgeTickHook);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeTickHook_ = $ForgeTickHook$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MsptOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$MsptOrBuilder extends $MessageLiteOrBuilder {

 "getLast5M"(): $SparkProtos$RollingAverageValues
 "getLast1M"(): $SparkProtos$RollingAverageValues
 "hasLast1M"(): boolean
 "hasLast5M"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$MsptOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$MsptOrBuilder$Type = ($SparkProtos$PlatformStatistics$MsptOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$MsptOrBuilder_ = $SparkProtos$PlatformStatistics$MsptOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializerImpl" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$GsonComponentSerializer, $GsonComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GsonComponentSerializer$Builder, $GsonComponentSerializer$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer$Builder"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$GsonBuilder, $GsonBuilder$Type} from "packages/com/google/gson/$GsonBuilder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $GsonComponentSerializerImpl implements $GsonComponentSerializer {


public "deserialize"(string: string): $Component
public "populator"(): $UnaryOperator<($GsonBuilder)>
public "serializer"(): $Gson
public "serializeToTree"(component: $Component$Type): $JsonElement
public "toBuilder"(): $GsonComponentSerializer$Builder
public "deserializeOr"(input: string, fallback: $Component$Type): $Component
public "deserializeFromTree"(input: $JsonElement$Type): $Component
public static "builder"(): $GsonComponentSerializer$Builder
public static "gson"(): $GsonComponentSerializer
public static "colorDownsamplingGson"(): $GsonComponentSerializer
public "deserializeOrNull"(input: string): $Component
public "serializeOr"(component: $Component$Type, fallback: string): string
public "serializeOrNull"(component: $Component$Type): string
/**
 * 
 * @deprecated
 */
public "deseializeOrNull"(input: string): $Component
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $GsonComponentSerializer$Builder$Type, consumer: $Consumer$Type<(any)>): $GsonComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GsonComponentSerializerImpl$Type = ($GsonComponentSerializerImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GsonComponentSerializerImpl_ = $GsonComponentSerializerImpl$Type;
}}
declare module "packages/me/lucko/spark/forge/plugin/$ForgeClientSparkPlugin" {
import {$Suggestions, $Suggestions$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestions"
import {$ForgeSparkPlugin, $ForgeSparkPlugin$Type} from "packages/me/lucko/spark/forge/plugin/$ForgeSparkPlugin"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$FMLClientSetupEvent, $FMLClientSetupEvent$Type} from "packages/net/minecraftforge/fml/event/lifecycle/$FMLClientSetupEvent"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$PlatformInfo, $PlatformInfo$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo"
import {$SuggestionProvider, $SuggestionProvider$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionProvider"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Minecraft, $Minecraft$Type} from "packages/net/minecraft/client/$Minecraft"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$Command, $Command$Type} from "packages/com/mojang/brigadier/$Command"
import {$ForgeSparkMod, $ForgeSparkMod$Type} from "packages/me/lucko/spark/forge/$ForgeSparkMod"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$ForgeCommandSender, $ForgeCommandSender$Type} from "packages/me/lucko/spark/forge/$ForgeCommandSender"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"
import {$RegisterClientCommandsEvent, $RegisterClientCommandsEvent$Type} from "packages/net/minecraftforge/client/event/$RegisterClientCommandsEvent"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"

export class $ForgeClientSparkPlugin extends $ForgeSparkPlugin implements $Command<($CommandSourceStack)>, $SuggestionProvider<($CommandSourceStack)> {

constructor(arg0: $ForgeSparkMod$Type, arg1: $Minecraft$Type)

public "run"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>): integer
public static "register"(arg0: $ForgeSparkMod$Type, arg1: $FMLClientSetupEvent$Type): void
public "enable"(): void
public "onCommandRegister"(arg0: $RegisterClientCommandsEvent$Type): void
public "createTickHook"(): $TickHook
public "createTickReporter"(): $TickReporter
public "executeSync"(arg0: $Runnable$Type): void
public "getPlatformInfo"(): $PlatformInfo
public "getCommandSenders"(): $Stream<($ForgeCommandSender)>
public "createExtraMetadataProvider"(): $MetadataProvider
public "getDefaultThreadDumper"(): $ThreadDumper
public "createWorldInfoProvider"(): $WorldInfoProvider
public "hasPermission"(arg0: $CommandSource$Type, arg1: string): boolean
public "getSuggestions"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public "getCommandName"(): string
get "platformInfo"(): $PlatformInfo
get "commandSenders"(): $Stream<($ForgeCommandSender)>
get "defaultThreadDumper"(): $ThreadDumper
get "commandName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeClientSparkPlugin$Type = ($ForgeClientSparkPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeClientSparkPlugin_ = $ForgeClientSparkPlugin$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Type" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Method, $Method$Type} from "packages/java/lang/reflect/$Method"
import {$Constructor, $Constructor$Type} from "packages/java/lang/reflect/$Constructor"

export class $Type {
static readonly "VOID": integer
static readonly "BOOLEAN": integer
static readonly "CHAR": integer
static readonly "BYTE": integer
static readonly "SHORT": integer
static readonly "INT": integer
static readonly "FLOAT": integer
static readonly "LONG": integer
static readonly "DOUBLE": integer
static readonly "ARRAY": integer
static readonly "OBJECT": integer
static readonly "METHOD": integer
static readonly "VOID_TYPE": $Type
static readonly "BOOLEAN_TYPE": $Type
static readonly "CHAR_TYPE": $Type
static readonly "BYTE_TYPE": $Type
static readonly "SHORT_TYPE": $Type
static readonly "INT_TYPE": $Type
static readonly "FLOAT_TYPE": $Type
static readonly "LONG_TYPE": $Type
static readonly "DOUBLE_TYPE": $Type


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getDescriptor"(): string
public static "getDescriptor"(arg0: $Class$Type<(any)>): string
public "getReturnType"(): $Type
public static "getReturnType"(arg0: string): $Type
public static "getReturnType"(arg0: $Method$Type): $Type
public static "getType"(arg0: $Class$Type<(any)>): $Type
public static "getType"(arg0: string): $Type
public static "getType"(arg0: $Method$Type): $Type
public static "getType"(arg0: $Constructor$Type<(any)>): $Type
public "getSize"(): integer
public static "getMethodType"(arg0: $Type$Type, ...arg1: ($Type$Type)[]): $Type
public static "getMethodType"(arg0: string): $Type
public static "getMethodDescriptor"(arg0: $Type$Type, ...arg1: ($Type$Type)[]): string
public static "getMethodDescriptor"(arg0: $Method$Type): string
public "getClassName"(): string
public "getInternalName"(): string
public static "getInternalName"(arg0: $Class$Type<(any)>): string
public "getSort"(): integer
public static "getObjectType"(arg0: string): $Type
public static "getArgumentTypes"(arg0: string): ($Type)[]
public static "getArgumentTypes"(arg0: $Method$Type): ($Type)[]
public "getArgumentTypes"(): ($Type)[]
public static "getArgumentsAndReturnSizes"(arg0: string): integer
public "getArgumentsAndReturnSizes"(): integer
public static "getConstructorDescriptor"(arg0: $Constructor$Type<(any)>): string
public "getDimensions"(): integer
public "getElementType"(): $Type
public "getOpcode"(arg0: integer): integer
get "descriptor"(): string
get "returnType"(): $Type
get "size"(): integer
get "className"(): string
get "internalName"(): string
get "sort"(): integer
get "argumentTypes"(): ($Type)[]
get "argumentsAndReturnSizes"(): integer
get "dimensions"(): integer
get "elementType"(): $Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Type$Type = ($Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Type_ = $Type$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Timestamp$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Timestamp, $Timestamp$Type} from "packages/me/lucko/spark/lib/protobuf/$Timestamp"
import {$TimestampOrBuilder, $TimestampOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$TimestampOrBuilder"

export class $Timestamp$Builder extends $GeneratedMessageLite$Builder<($Timestamp), ($Timestamp$Builder)> implements $TimestampOrBuilder {


public "getSeconds"(): long
public "setSeconds"(arg0: long): $Timestamp$Builder
public "getNanos"(): integer
public "setNanos"(arg0: integer): $Timestamp$Builder
public "clearNanos"(): $Timestamp$Builder
public "clearSeconds"(): $Timestamp$Builder
get "seconds"(): long
set "seconds"(value: long)
get "nanos"(): integer
set "nanos"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Timestamp$Builder$Type = ($Timestamp$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Timestamp$Builder_ = $Timestamp$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNodeOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkSamplerProtos$StackTraceNodeOrBuilder extends $MessageLiteOrBuilder {

 "getTimesList"(): $List<(double)>
 "getChildrenRefs"(arg0: integer): integer
 "getTimesCount"(): integer
 "getLineNumber"(): integer
 "getClassName"(): string
 "getMethodName"(): string
 "getTimes"(arg0: integer): double
 "getMethodDesc"(): string
 "getParentLineNumber"(): integer
 "getClassNameBytes"(): $ByteString
 "getMethodNameBytes"(): $ByteString
 "getMethodDescBytes"(): $ByteString
 "getChildrenRefsList"(): $List<(integer)>
 "getChildrenRefsCount"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$StackTraceNodeOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$StackTraceNodeOrBuilder$Type = ($SparkSamplerProtos$StackTraceNodeOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$StackTraceNodeOrBuilder_ = $SparkSamplerProtos$StackTraceNodeOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics" {
import {$SparkWebSocketProtos$ServerUpdateStatistics$Builder, $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder, $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder"

export class $SparkWebSocketProtos$ServerUpdateStatistics extends $GeneratedMessageLite<($SparkWebSocketProtos$ServerUpdateStatistics), ($SparkWebSocketProtos$ServerUpdateStatistics$Builder)> implements $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder {
static readonly "PLATFORM_FIELD_NUMBER": integer
static readonly "SYSTEM_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ServerUpdateStatistics)>
public static "newBuilder"(): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public static "newBuilder"(arg0: $SparkWebSocketProtos$ServerUpdateStatistics$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public "getPlatform"(): $SparkProtos$PlatformStatistics
public "hasPlatform"(): boolean
public static "getDefaultInstance"(): $SparkWebSocketProtos$ServerUpdateStatistics
public "hasSystem"(): boolean
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ServerUpdateStatistics
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ServerUpdateStatistics
public "getSystem"(): $SparkProtos$SystemStatistics
get "platform"(): $SparkProtos$PlatformStatistics
get "defaultInstance"(): $SparkWebSocketProtos$ServerUpdateStatistics
get "system"(): $SparkProtos$SystemStatistics
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateStatistics$Type = ($SparkWebSocketProtos$ServerUpdateStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateStatistics_ = $SparkWebSocketProtos$ServerUpdateStatistics$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$JfrParsingException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $JfrParsingException extends $RuntimeException {

constructor(arg0: string, arg1: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrParsingException$Type = ($JfrParsingException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrParsingException_ = $JfrParsingException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteString$Output" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $ByteString$Output extends $OutputStream {


public "toString"(): string
public "size"(): integer
public "write"(arg0: integer): void
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "reset"(): void
public "writeTo"(arg0: $OutputStream$Type): void
public "toByteString"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteString$Output$Type = ($ByteString$Output);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteString$Output_ = $ByteString$Output$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntryOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkHeapProtos$HeapEntryOrBuilder extends $MessageLiteOrBuilder {

 "getType"(): string
 "getSize"(): long
 "getOrder"(): integer
 "getTypeBytes"(): $ByteString
 "getInstances"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkHeapProtos$HeapEntryOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapEntryOrBuilder$Type = ($SparkHeapProtos$HeapEntryOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapEntryOrBuilder_ = $SparkHeapProtos$HeapEntryOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSetLite" {
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"

export class $UnknownFieldSetLite {


public "writeAsMessageSetTo"(arg0: $CodedOutputStream$Type): void
public "getSerializedSizeAsMessageSet"(): integer
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "writeTo"(arg0: $Writer$Type): void
public "writeTo"(arg0: $CodedOutputStream$Type): void
public "makeImmutable"(): void
public "getSerializedSize"(): integer
public static "getDefaultInstance"(): $UnknownFieldSetLite
get "serializedSizeAsMessageSet"(): integer
get "serializedSize"(): integer
get "defaultInstance"(): $UnknownFieldSetLite
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownFieldSetLite$Type = ($UnknownFieldSetLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnknownFieldSetLite_ = $UnknownFieldSetLite$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$ClassWriter" {
import {$MethodVisitor, $MethodVisitor$Type} from "packages/me/lucko/spark/lib/asm/$MethodVisitor"
import {$RecordComponentVisitor, $RecordComponentVisitor$Type} from "packages/me/lucko/spark/lib/asm/$RecordComponentVisitor"
import {$Handle, $Handle$Type} from "packages/me/lucko/spark/lib/asm/$Handle"
import {$ModuleVisitor, $ModuleVisitor$Type} from "packages/me/lucko/spark/lib/asm/$ModuleVisitor"
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$ClassVisitor, $ClassVisitor$Type} from "packages/me/lucko/spark/lib/asm/$ClassVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"
import {$ClassReader, $ClassReader$Type} from "packages/me/lucko/spark/lib/asm/$ClassReader"
import {$FieldVisitor, $FieldVisitor$Type} from "packages/me/lucko/spark/lib/asm/$FieldVisitor"

export class $ClassWriter extends $ClassVisitor {
static readonly "COMPUTE_MAXS": integer
static readonly "COMPUTE_FRAMES": integer

constructor(arg0: integer)
constructor(arg0: $ClassReader$Type, arg1: integer)

public "toByteArray"(): (byte)[]
public "newModule"(arg0: string): integer
public "visit"(arg0: integer, arg1: integer, arg2: string, arg3: string, arg4: string, arg5: (string)[]): void
public "visitSource"(arg0: string, arg1: string): void
public "visitField"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: any): $FieldVisitor
public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitMethod"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: (string)[]): $MethodVisitor
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
public "visitNestHost"(arg0: string): void
public "visitOuterClass"(arg0: string, arg1: string, arg2: string): void
public "visitNestMember"(arg0: string): void
public "visitInnerClass"(arg0: string, arg1: string, arg2: string, arg3: integer): void
public "visitModule"(arg0: string, arg1: integer, arg2: string): $ModuleVisitor
public "visitRecordComponent"(arg0: string, arg1: string, arg2: string): $RecordComponentVisitor
/**
 * 
 * @deprecated
 */
public "newHandle"(arg0: integer, arg1: string, arg2: string, arg3: string): integer
public "newHandle"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: boolean): integer
public "newConst"(arg0: any): integer
public "newUTF8"(arg0: string): integer
public "newClass"(arg0: string): integer
public "newMethodType"(arg0: string): integer
public "newPackage"(arg0: string): integer
public "newConstantDynamic"(arg0: string, arg1: string, arg2: $Handle$Type, ...arg3: (any)[]): integer
public "newInvokeDynamic"(arg0: string, arg1: string, arg2: $Handle$Type, ...arg3: (any)[]): integer
public "newField"(arg0: string, arg1: string, arg2: string): integer
public "newMethod"(arg0: string, arg1: string, arg2: string, arg3: boolean): integer
public "newNameType"(arg0: string, arg1: string): integer
public "visitPermittedSubclass"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassWriter$Type = ($ClassWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassWriter_ = $ClassWriter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapDataOrBuilder" {
import {$SparkHeapProtos$HeapEntry, $SparkHeapProtos$HeapEntry$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkHeapProtos$HeapMetadata, $SparkHeapProtos$HeapMetadata$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkHeapProtos$HeapDataOrBuilder extends $MessageLiteOrBuilder {

 "getEntries"(arg0: integer): $SparkHeapProtos$HeapEntry
 "getEntriesList"(): $List<($SparkHeapProtos$HeapEntry)>
 "getEntriesCount"(): integer
 "hasMetadata"(): boolean
 "getMetadata"(): $SparkHeapProtos$HeapMetadata
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkHeapProtos$HeapDataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapDataOrBuilder$Type = ($SparkHeapProtos$HeapDataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapDataOrBuilder_ = $SparkHeapProtos$HeapDataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Any$Builder" {
import {$AnyOrBuilder, $AnyOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$AnyOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Any, $Any$Type} from "packages/me/lucko/spark/lib/protobuf/$Any"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $Any$Builder extends $GeneratedMessageLite$Builder<($Any), ($Any$Builder)> implements $AnyOrBuilder {


public "getValue"(): $ByteString
public "setValue"(arg0: $ByteString$Type): $Any$Builder
public "clearValue"(): $Any$Builder
public "getTypeUrl"(): string
public "setTypeUrl"(arg0: string): $Any$Builder
public "clearTypeUrl"(): $Any$Builder
public "getTypeUrlBytes"(): $ByteString
public "setTypeUrlBytes"(arg0: $ByteString$Type): $Any$Builder
get "value"(): $ByteString
set "value"(value: $ByteString$Type)
get "typeUrl"(): string
set "typeUrl"(value: string)
get "typeUrlBytes"(): $ByteString
set "typeUrlBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Any$Builder$Type = ($Any$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Any$Builder_ = $Any$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt32ValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $UInt32ValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $UInt32ValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt32ValueOrBuilder$Type = ($UInt32ValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt32ValueOrBuilder_ = $UInt32ValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$IntFunction2" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $IntFunction2<R> {

 "apply"(first: integer, second: integer): R

(first: integer, second: integer): R
}

export namespace $IntFunction2 {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntFunction2$Type<R> = ($IntFunction2<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntFunction2_<R> = $IntFunction2$Type<(R)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$SSLSocketChannel2" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$SocketAddress, $SocketAddress$Type} from "packages/java/net/$SocketAddress"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$WrappedByteChannel, $WrappedByteChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WrappedByteChannel"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$Socket, $Socket$Type} from "packages/java/net/$Socket"
import {$ISSLChannel, $ISSLChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/interfaces/$ISSLChannel"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SelectableChannel, $SelectableChannel$Type} from "packages/java/nio/channels/$SelectableChannel"

export class $SSLSocketChannel2 implements $ByteChannel, $WrappedByteChannel, $ISSLChannel {

constructor(arg0: $SocketChannel$Type, arg1: $SSLEngine$Type, arg2: $ExecutorService$Type, arg3: $SelectionKey$Type)

public "isOpen"(): boolean
public "write"(arg0: $ByteBuffer$Type): integer
public "read"(arg0: $ByteBuffer$Type): integer
public "connect"(arg0: $SocketAddress$Type): boolean
public "close"(): void
public "configureBlocking"(arg0: boolean): $SelectableChannel
public "isBlocking"(): boolean
public "isInboundDone"(): boolean
public "isConnected"(): boolean
public "getSSLEngine"(): $SSLEngine
public "finishConnect"(): boolean
public "socket"(): $Socket
public "isNeedWrite"(): boolean
public "writeMore"(): void
public "isNeedRead"(): boolean
public "readMore"(arg0: $ByteBuffer$Type): integer
get "open"(): boolean
get "blocking"(): boolean
get "inboundDone"(): boolean
get "connected"(): boolean
get "sSLEngine"(): $SSLEngine
get "needWrite"(): boolean
get "needRead"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SSLSocketChannel2$Type = ($SSLSocketChannel2);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SSLSocketChannel2_ = $SSLSocketChannel2$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$GlobalTranslator" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$MessageFormat, $MessageFormat$Type} from "packages/java/text/$MessageFormat"
import {$Translator, $Translator$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$TranslatableComponentRenderer, $TranslatableComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$TranslatableComponentRenderer"

export interface $GlobalTranslator extends $Translator, $Examinable {

 "sources"(): $Iterable<(any)>
 "addSource"(source: $Translator$Type): boolean
 "removeSource"(source: $Translator$Type): boolean
 "name"(): $Key
 "translate"(key: string, locale: $Locale$Type): $MessageFormat
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $GlobalTranslator {
function get(): $GlobalTranslator
function render(component: $Component$Type, locale: $Locale$Type): $Component
function renderer(): $TranslatableComponentRenderer<($Locale)>
function translator(): $GlobalTranslator
function parseLocale(string: string): $Locale
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalTranslator$Type = ($GlobalTranslator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlobalTranslator_ = $GlobalTranslator$Type;
}}
declare module "packages/me/lucko/spark/common/util/$ThreadFinder" {
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $ThreadFinder {

constructor()

public "getThreads"(): $Stream<($Thread)>
get "threads"(): $Stream<($Thread)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadFinder$Type = ($ThreadFinder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadFinder_ = $ThreadFinder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$UsageOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder extends $MessageLiteOrBuilder {

 "getLast1M"(): double
 "getLast15M"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder$Type = ($SparkProtos$SystemStatistics$Cpu$UsageOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder_ = $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AllocatedBuffer" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $AllocatedBuffer {


public static "wrap"(arg0: (byte)[]): $AllocatedBuffer
public static "wrap"(arg0: (byte)[], arg1: integer, arg2: integer): $AllocatedBuffer
public static "wrap"(arg0: $ByteBuffer$Type): $AllocatedBuffer
public "position"(arg0: integer): $AllocatedBuffer
public "position"(): integer
public "limit"(): integer
public "remaining"(): integer
public "hasArray"(): boolean
public "array"(): (byte)[]
public "arrayOffset"(): integer
public "hasNioBuffer"(): boolean
public "nioBuffer"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AllocatedBuffer$Type = ($AllocatedBuffer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AllocatedBuffer_ = $AllocatedBuffer$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Opcodes" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Opcodes {

}

export namespace $Opcodes {
const ASM4: integer
const ASM5: integer
const ASM6: integer
const ASM7: integer
const ASM8: integer
const ASM9: integer
const ASM10_EXPERIMENTAL: integer
const SOURCE_DEPRECATED: integer
const SOURCE_MASK: integer
const V1_1: integer
const V1_2: integer
const V1_3: integer
const V1_4: integer
const V1_5: integer
const V1_6: integer
const V1_7: integer
const V1_8: integer
const V9: integer
const V10: integer
const V11: integer
const V12: integer
const V13: integer
const V14: integer
const V15: integer
const V16: integer
const V17: integer
const V_PREVIEW: integer
const ACC_PUBLIC: integer
const ACC_PRIVATE: integer
const ACC_PROTECTED: integer
const ACC_STATIC: integer
const ACC_FINAL: integer
const ACC_SUPER: integer
const ACC_SYNCHRONIZED: integer
const ACC_OPEN: integer
const ACC_TRANSITIVE: integer
const ACC_VOLATILE: integer
const ACC_BRIDGE: integer
const ACC_STATIC_PHASE: integer
const ACC_VARARGS: integer
const ACC_TRANSIENT: integer
const ACC_NATIVE: integer
const ACC_INTERFACE: integer
const ACC_ABSTRACT: integer
const ACC_STRICT: integer
const ACC_SYNTHETIC: integer
const ACC_ANNOTATION: integer
const ACC_ENUM: integer
const ACC_MANDATED: integer
const ACC_MODULE: integer
const ACC_RECORD: integer
const ACC_DEPRECATED: integer
const T_BOOLEAN: integer
const T_CHAR: integer
const T_FLOAT: integer
const T_DOUBLE: integer
const T_BYTE: integer
const T_SHORT: integer
const T_INT: integer
const T_LONG: integer
const H_GETFIELD: integer
const H_GETSTATIC: integer
const H_PUTFIELD: integer
const H_PUTSTATIC: integer
const H_INVOKEVIRTUAL: integer
const H_INVOKESTATIC: integer
const H_INVOKESPECIAL: integer
const H_NEWINVOKESPECIAL: integer
const H_INVOKEINTERFACE: integer
const F_NEW: integer
const F_FULL: integer
const F_APPEND: integer
const F_CHOP: integer
const F_SAME: integer
const F_SAME1: integer
const TOP: integer
const INTEGER: integer
const FLOAT: integer
const DOUBLE: integer
const LONG: integer
const NULL: integer
const UNINITIALIZED_THIS: integer
const NOP: integer
const ACONST_NULL: integer
const ICONST_M1: integer
const ICONST_0: integer
const ICONST_1: integer
const ICONST_2: integer
const ICONST_3: integer
const ICONST_4: integer
const ICONST_5: integer
const LCONST_0: integer
const LCONST_1: integer
const FCONST_0: integer
const FCONST_1: integer
const FCONST_2: integer
const DCONST_0: integer
const DCONST_1: integer
const BIPUSH: integer
const SIPUSH: integer
const LDC: integer
const ILOAD: integer
const LLOAD: integer
const FLOAD: integer
const DLOAD: integer
const ALOAD: integer
const IALOAD: integer
const LALOAD: integer
const FALOAD: integer
const DALOAD: integer
const AALOAD: integer
const BALOAD: integer
const CALOAD: integer
const SALOAD: integer
const ISTORE: integer
const LSTORE: integer
const FSTORE: integer
const DSTORE: integer
const ASTORE: integer
const IASTORE: integer
const LASTORE: integer
const FASTORE: integer
const DASTORE: integer
const AASTORE: integer
const BASTORE: integer
const CASTORE: integer
const SASTORE: integer
const POP: integer
const POP2: integer
const DUP: integer
const DUP_X1: integer
const DUP_X2: integer
const DUP2: integer
const DUP2_X1: integer
const DUP2_X2: integer
const SWAP: integer
const IADD: integer
const LADD: integer
const FADD: integer
const DADD: integer
const ISUB: integer
const LSUB: integer
const FSUB: integer
const DSUB: integer
const IMUL: integer
const LMUL: integer
const FMUL: integer
const DMUL: integer
const IDIV: integer
const LDIV: integer
const FDIV: integer
const DDIV: integer
const IREM: integer
const LREM: integer
const FREM: integer
const DREM: integer
const INEG: integer
const LNEG: integer
const FNEG: integer
const DNEG: integer
const ISHL: integer
const LSHL: integer
const ISHR: integer
const LSHR: integer
const IUSHR: integer
const LUSHR: integer
const IAND: integer
const LAND: integer
const IOR: integer
const LOR: integer
const IXOR: integer
const LXOR: integer
const IINC: integer
const I2L: integer
const I2F: integer
const I2D: integer
const L2I: integer
const L2F: integer
const L2D: integer
const F2I: integer
const F2L: integer
const F2D: integer
const D2I: integer
const D2L: integer
const D2F: integer
const I2B: integer
const I2C: integer
const I2S: integer
const LCMP: integer
const FCMPL: integer
const FCMPG: integer
const DCMPL: integer
const DCMPG: integer
const IFEQ: integer
const IFNE: integer
const IFLT: integer
const IFGE: integer
const IFGT: integer
const IFLE: integer
const IF_ICMPEQ: integer
const IF_ICMPNE: integer
const IF_ICMPLT: integer
const IF_ICMPGE: integer
const IF_ICMPGT: integer
const IF_ICMPLE: integer
const IF_ACMPEQ: integer
const IF_ACMPNE: integer
const GOTO: integer
const JSR: integer
const RET: integer
const TABLESWITCH: integer
const LOOKUPSWITCH: integer
const IRETURN: integer
const LRETURN: integer
const FRETURN: integer
const DRETURN: integer
const ARETURN: integer
const RETURN: integer
const GETSTATIC: integer
const PUTSTATIC: integer
const GETFIELD: integer
const PUTFIELD: integer
const INVOKEVIRTUAL: integer
const INVOKESPECIAL: integer
const INVOKESTATIC: integer
const INVOKEINTERFACE: integer
const INVOKEDYNAMIC: integer
const NEW: integer
const NEWARRAY: integer
const ANEWARRAY: integer
const ARRAYLENGTH: integer
const ATHROW: integer
const CHECKCAST: integer
const INSTANCEOF: integer
const MONITORENTER: integer
const MONITOREXIT: integer
const MULTIANEWARRAY: integer
const IFNULL: integer
const IFNONNULL: integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Opcodes$Type = ($Opcodes);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Opcodes_ = $Opcodes$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$DiskOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$DiskOrBuilder extends $MessageLiteOrBuilder {

 "getTotal"(): long
 "getUsed"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$DiskOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$DiskOrBuilder$Type = ($SparkProtos$SystemStatistics$DiskOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$DiskOrBuilder_ = $SparkProtos$SystemStatistics$DiskOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadataOrBuilder" {
import {$SparkProtos$PlatformMetadata$Type, $SparkProtos$PlatformMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Type"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformMetadataOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getType"(): $SparkProtos$PlatformMetadata$Type
 "getVersion"(): string
 "getSparkVersion"(): integer
 "getNameBytes"(): $ByteString
 "getMinecraftVersion"(): string
 "getMinecraftVersionBytes"(): $ByteString
 "getTypeValue"(): integer
 "getVersionBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformMetadataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformMetadataOrBuilder$Type = ($SparkProtos$PlatformMetadataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformMetadataOrBuilder_ = $SparkProtos$PlatformMetadataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementRenderer" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$TextReplacementRenderer$State, $TextReplacementRenderer$State$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementRenderer$State"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$ComponentRenderer, $ComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$ComponentRenderer"

export class $TextReplacementRenderer implements $ComponentRenderer<($TextReplacementRenderer$State)> {


public "render"(component: $Component$Type, state: $TextReplacementRenderer$State$Type): $Component
public "mapContext"<T>(transformer: $Function$Type<(T), ($TextReplacementRenderer$State$Type)>): $ComponentRenderer<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementRenderer$Type = ($TextReplacementRenderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementRenderer_ = $TextReplacementRenderer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteString$ByteIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ByteString$ByteIterator extends $Iterator<(byte)> {

 "nextByte"(): byte
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): byte
}

export namespace $ByteString$ByteIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteString$ByteIterator$Type = ($ByteString$ByteIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteString$ByteIterator_ = $ByteString$ByteIterator$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ServerPong, $SparkWebSocketProtos$ServerPong$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong"
import {$SparkWebSocketProtos$ServerPongOrBuilder, $SparkWebSocketProtos$ServerPongOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPongOrBuilder"

export class $SparkWebSocketProtos$ServerPong$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ServerPong), ($SparkWebSocketProtos$ServerPong$Builder)> implements $SparkWebSocketProtos$ServerPongOrBuilder {


public "getData"(): integer
public "setData"(arg0: integer): $SparkWebSocketProtos$ServerPong$Builder
public "clearData"(): $SparkWebSocketProtos$ServerPong$Builder
public "setOk"(arg0: boolean): $SparkWebSocketProtos$ServerPong$Builder
public "getOk"(): boolean
public "clearOk"(): $SparkWebSocketProtos$ServerPong$Builder
get "data"(): integer
set "data"(value: integer)
set "ok"(value: boolean)
get "ok"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerPong$Builder$Type = ($SparkWebSocketProtos$ServerPong$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerPong$Builder_ = $SparkWebSocketProtos$ServerPong$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Event" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"

export class $JfrReader$Event implements $Comparable<($JfrReader$Event)> {
readonly "time": long
readonly "tid": integer
readonly "stackTraceId": integer


public "value"(): long
public "hashCode"(): integer
public "compareTo"(arg0: $JfrReader$Event$Type): integer
public "sameGroup"(arg0: $JfrReader$Event$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$Event$Type = ($JfrReader$Event);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$Event_ = $JfrReader$Event$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ListValue$Builder" {
import {$Value$Builder, $Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Value$Builder"
import {$ListValueOrBuilder, $ListValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValueOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ListValue, $ListValue$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export class $ListValue$Builder extends $GeneratedMessageLite$Builder<($ListValue), ($ListValue$Builder)> implements $ListValueOrBuilder {


public "getValuesCount"(): integer
public "removeValues"(arg0: integer): $ListValue$Builder
public "getValuesList"(): $List<($Value)>
public "setValues"(arg0: integer, arg1: $Value$Type): $ListValue$Builder
public "setValues"(arg0: integer, arg1: $Value$Builder$Type): $ListValue$Builder
public "addAllValues"(arg0: $Iterable$Type<(any)>): $ListValue$Builder
public "addValues"(arg0: integer, arg1: $Value$Builder$Type): $ListValue$Builder
public "addValues"(arg0: integer, arg1: $Value$Type): $ListValue$Builder
public "addValues"(arg0: $Value$Type): $ListValue$Builder
public "addValues"(arg0: $Value$Builder$Type): $ListValue$Builder
public "clearValues"(): $ListValue$Builder
public "getValues"(arg0: integer): $Value
get "valuesCount"(): integer
get "valuesList"(): $List<($Value)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListValue$Builder$Type = ($ListValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListValue$Builder_ = $ListValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$ProtoTimeEncoder" {
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$LongAdder, $LongAdder$Type} from "packages/java/util/concurrent/atomic/$LongAdder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ProtoTimeEncoder {

constructor(arg0: $LongToDoubleFunction$Type, arg1: $List$Type<($ThreadNode$Type)>)

public "encode"(arg0: $Map$Type<(integer), ($LongAdder$Type)>): (double)[]
public "getKeys"(): (integer)[]
get "keys"(): (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtoTimeEncoder$Type = ($ProtoTimeEncoder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtoTimeEncoder_ = $ProtoTimeEncoder$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Command" {
import {$Command$TabCompleter, $Command$TabCompleter$Type} from "packages/me/lucko/spark/common/command/$Command$TabCompleter"
import {$Command$Builder, $Command$Builder$Type} from "packages/me/lucko/spark/common/command/$Command$Builder"
import {$Command$Executor, $Command$Executor$Type} from "packages/me/lucko/spark/common/command/$Command$Executor"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Command$ArgumentInfo, $Command$ArgumentInfo$Type} from "packages/me/lucko/spark/common/command/$Command$ArgumentInfo"

export class $Command {


public static "builder"(): $Command$Builder
public "arguments"(): $List<($Command$ArgumentInfo)>
public "aliases"(): $List<(string)>
public "executor"(): $Command$Executor
public "allowSubCommand"(): boolean
public "tabCompleter"(): $Command$TabCompleter
public "primaryAlias"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Command$Type = ($Command);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Command_ = $Command$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$ComponentMessageThrowable" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentMessageThrowable {

 "componentMessage"(): $Component

(throwable: $Throwable$Type): $Component
}

export namespace $ComponentMessageThrowable {
function getMessage(throwable: $Throwable$Type): $Component
function getOrConvertMessage(throwable: $Throwable$Type): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentMessageThrowable$Type = ($ComponentMessageThrowable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentMessageThrowable_ = $ComponentMessageThrowable$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketListener" {
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$ServerHandshakeBuilder, $ServerHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder"
import {$PingFrame, $PingFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$PingFrame"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export interface $WebSocketListener {

 "getRemoteSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
 "getLocalSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
 "onWebsocketHandshakeReceivedAsServer"(arg0: $WebSocket$Type, arg1: $Draft$Type, arg2: $ClientHandshake$Type): $ServerHandshakeBuilder
 "onWebsocketHandshakeReceivedAsClient"(arg0: $WebSocket$Type, arg1: $ClientHandshake$Type, arg2: $ServerHandshake$Type): void
 "onWebsocketHandshakeSentAsClient"(arg0: $WebSocket$Type, arg1: $ClientHandshake$Type): void
 "onWebsocketCloseInitiated"(arg0: $WebSocket$Type, arg1: integer, arg2: string): void
 "onWebsocketClose"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
 "onWebsocketPing"(arg0: $WebSocket$Type, arg1: $Framedata$Type): void
 "onWebsocketError"(arg0: $WebSocket$Type, arg1: $Exception$Type): void
 "onWebsocketPong"(arg0: $WebSocket$Type, arg1: $Framedata$Type): void
 "onPreparePing"(arg0: $WebSocket$Type): $PingFrame
 "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: $ByteBuffer$Type): void
 "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: string): void
 "onWriteDemand"(arg0: $WebSocket$Type): void
 "onWebsocketOpen"(arg0: $WebSocket$Type, arg1: $Handshakedata$Type): void
 "onWebsocketClosing"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
}

export namespace $WebSocketListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketListener$Type = ($WebSocketListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketListener_ = $WebSocketListener$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $KeybindComponent$KeybindLike {

 "asKeybind"(): string

(): string
}

export namespace $KeybindComponent$KeybindLike {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindComponent$KeybindLike$Type = ($KeybindComponent$KeybindLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeybindComponent$KeybindLike_ = $KeybindComponent$KeybindLike$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SourceContext$Builder" {
import {$SourceContextOrBuilder, $SourceContextOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContextOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SourceContext$Builder extends $GeneratedMessageLite$Builder<($SourceContext), ($SourceContext$Builder)> implements $SourceContextOrBuilder {


public "getFileName"(): string
public "setFileName"(arg0: string): $SourceContext$Builder
public "clearFileName"(): $SourceContext$Builder
public "getFileNameBytes"(): $ByteString
public "setFileNameBytes"(arg0: $ByteString$Type): $SourceContext$Builder
get "fileName"(): string
set "fileName"(value: string)
get "fileNameBytes"(): $ByteString
set "fileNameBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceContext$Builder$Type = ($SourceContext$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceContext$Builder_ = $SourceContext$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound$Emitter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Sound$Emitter {

}

export namespace $Sound$Emitter {
function self(): $Sound$Emitter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Emitter$Type = ($Sound$Emitter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound$Emitter_ = $Sound$Emitter$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt64Value" {
import {$UInt64Value$Builder, $UInt64Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt64Value$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$UInt64ValueOrBuilder, $UInt64ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt64ValueOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $UInt64Value extends $GeneratedMessageLite<($UInt64Value), ($UInt64Value$Builder)> implements $UInt64ValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): long
public static "of"(arg0: long): $UInt64Value
public static "parser"(): $Parser<($UInt64Value)>
public static "newBuilder"(arg0: $UInt64Value$Type): $UInt64Value$Builder
public static "newBuilder"(): $UInt64Value$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt64Value
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $UInt64Value
public static "getDefaultInstance"(): $UInt64Value
public static "parseFrom"(arg0: $ByteString$Type): $UInt64Value
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $UInt64Value
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $UInt64Value
public static "parseFrom"(arg0: $ByteBuffer$Type): $UInt64Value
public static "parseFrom"(arg0: $CodedInputStream$Type): $UInt64Value
public static "parseFrom"(arg0: $InputStream$Type): $UInt64Value
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt64Value
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $UInt64Value
public static "parseFrom"(arg0: (byte)[]): $UInt64Value
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $UInt64Value
get "value"(): long
get "defaultInstance"(): $UInt64Value
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt64Value$Type = ($UInt64Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt64Value_ = $UInt64Value$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$SamplerSettings" {
import {$ThreadGrouper, $ThreadGrouper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadGrouper"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"

export class $SamplerSettings {

constructor(arg0: integer, arg1: $ThreadDumper$Type, arg2: $ThreadGrouper$Type, arg3: long, arg4: boolean)

public "runningInBackground"(): boolean
public "interval"(): integer
public "autoEndTime"(): long
public "threadDumper"(): $ThreadDumper
public "threadGrouper"(): $ThreadGrouper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SamplerSettings$Type = ($SamplerSettings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SamplerSettings_ = $SamplerSettings$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$StyleSetter" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StyleSetter<T extends $StyleSetter<(any)>> {

 "color"(color: $TextColor$Type): T
 "colorIfAbsent"(color: $TextColor$Type): T
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): T
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): T
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): T
 "decorate"(...decorations: ($TextDecoration$Type)[]): T
 "decorate"(decoration: $TextDecoration$Type): T
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): T
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): T
 "font"(font: $Key$Type): T
 "insertion"(insertion: string): T
 "clickEvent"(event: $ClickEvent$Type): T
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): T
}

export namespace $StyleSetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StyleSetter$Type<T> = ($StyleSetter<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StyleSetter_<T> = $StyleSetter$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$VirtualMachine" {
import {$Properties, $Properties$Type} from "packages/java/util/$Properties"

export interface $VirtualMachine {

 "startLocalManagementAgent"(): string
 "detach"(): void
 "loadAgent"(arg0: string, arg1: string): void
 "loadAgent"(arg0: string): void
 "getSystemProperties"(): $Properties
 "loadAgentLibrary"(arg0: string, arg1: string): void
 "loadAgentLibrary"(arg0: string): void
 "getAgentProperties"(): $Properties
 "startManagementAgent"(arg0: $Properties$Type): void
 "loadAgentPath"(arg0: string, arg1: string): void
 "loadAgentPath"(arg0: string): void
}

export namespace $VirtualMachine {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $VirtualMachine$Type = ($VirtualMachine);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $VirtualMachine_ = $VirtualMachine$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SchemaFactory" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $SchemaFactory {

 "createSchema"<T>(arg0: $Class$Type<(T)>): $Schema<(T)>

(arg0: $Class$Type<(T)>): $Schema<(T)>
}

export namespace $SchemaFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SchemaFactory$Type = ($SchemaFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SchemaFactory_ = $SchemaFactory$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$RollingAverageValues$Builder, $SparkProtos$RollingAverageValues$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues$Builder"
import {$SparkProtos$SystemStatistics$NetInterface, $SparkProtos$SystemStatistics$NetInterface$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface"
import {$SparkProtos$SystemStatistics$NetInterfaceOrBuilder, $SparkProtos$SystemStatistics$NetInterfaceOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterfaceOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"

export class $SparkProtos$SystemStatistics$NetInterface$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$NetInterface), ($SparkProtos$SystemStatistics$NetInterface$Builder)> implements $SparkProtos$SystemStatistics$NetInterfaceOrBuilder {


public "hasTxBytesPerSecond"(): boolean
public "getTxBytesPerSecond"(): $SparkProtos$RollingAverageValues
public "clearRxBytesPerSecond"(): $SparkProtos$SystemStatistics$NetInterface$Builder
public "mergeRxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "hasRxBytesPerSecond"(): boolean
public "mergeTxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "clearTxBytesPerSecond"(): $SparkProtos$SystemStatistics$NetInterface$Builder
public "getRxBytesPerSecond"(): $SparkProtos$RollingAverageValues
public "hasRxPacketsPerSecond"(): boolean
public "getRxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
public "mergeRxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "clearRxPacketsPerSecond"(): $SparkProtos$SystemStatistics$NetInterface$Builder
public "clearTxPacketsPerSecond"(): $SparkProtos$SystemStatistics$NetInterface$Builder
public "mergeTxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "getTxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
public "hasTxPacketsPerSecond"(): boolean
public "setRxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setRxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setRxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setRxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setTxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setTxBytesPerSecond"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setTxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
public "setTxPacketsPerSecond"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$SystemStatistics$NetInterface$Builder
get "txBytesPerSecond"(): $SparkProtos$RollingAverageValues
get "rxBytesPerSecond"(): $SparkProtos$RollingAverageValues
get "rxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
get "txPacketsPerSecond"(): $SparkProtos$RollingAverageValues
set "rxBytesPerSecond"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "rxBytesPerSecond"(value: $SparkProtos$RollingAverageValues$Type)
set "rxPacketsPerSecond"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "rxPacketsPerSecond"(value: $SparkProtos$RollingAverageValues$Type)
set "txBytesPerSecond"(value: $SparkProtos$RollingAverageValues$Type)
set "txBytesPerSecond"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "txPacketsPerSecond"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "txPacketsPerSecond"(value: $SparkProtos$RollingAverageValues$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$NetInterface$Builder$Type = ($SparkProtos$SystemStatistics$NetInterface$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$NetInterface$Builder_ = $SparkProtos$SystemStatistics$NetInterface$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ListValue" {
import {$ListValueOrBuilder, $ListValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValueOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ListValue$Builder, $ListValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue$Builder"
import {$ValueOrBuilder, $ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ValueOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $ListValue extends $GeneratedMessageLite<($ListValue), ($ListValue$Builder)> implements $ListValueOrBuilder {
static readonly "VALUES_FIELD_NUMBER": integer


public "getValuesCount"(): integer
public "getValuesOrBuilder"(arg0: integer): $ValueOrBuilder
public static "parser"(): $Parser<($ListValue)>
public static "newBuilder"(): $ListValue$Builder
public static "newBuilder"(arg0: $ListValue$Type): $ListValue$Builder
public "getValuesList"(): $List<($Value)>
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $ListValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $ListValue
public static "getDefaultInstance"(): $ListValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $ListValue
public static "parseFrom"(arg0: (byte)[]): $ListValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $ListValue
public static "parseFrom"(arg0: $ByteString$Type): $ListValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $ListValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $ListValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $ListValue
public static "parseFrom"(arg0: $InputStream$Type): $ListValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $ListValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $ListValue
public "getValues"(arg0: integer): $Value
public "getValuesOrBuilderList"(): $List<(any)>
get "valuesCount"(): integer
get "valuesList"(): $List<($Value)>
get "defaultInstance"(): $ListValue
get "valuesOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListValue$Type = ($ListValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListValue_ = $ListValue$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$AbstractComponentBuilder" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"

export class $AbstractComponentBuilder<C extends $BuildableComponent<(C), (B)>, B extends $ComponentBuilder<(C), (B)>> implements $ComponentBuilder<(C), (B)> {


public "append"(...components: ($ComponentLike$Type)[]): B
public "append"(components: $Iterable$Type<(any)>): B
public "append"(...components: ($Component$Type)[]): B
public "append"(component: $Component$Type): B
public "color"(color: $TextColor$Type): B
public "style"(style: $Style$Type): B
public "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): B
public "children"(): $List<($Component)>
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): B
public "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): B
public "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
public "applyDeep"(consumer: $Consumer$Type<(any)>): B
public "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
public "resetStyle"(): B
public "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): B
public "hoverEvent"(source: $HoverEventSource$Type<(any)>): B
public "append"(component: $ComponentLike$Type): B
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): B
public "apply"(consumer: $Consumer$Type<(any)>): B
public "appendNewline"(): B
public "mergeStyle"(that: $Component$Type): B
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): B
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
public "applicableApply"(applicable: $ComponentBuilderApplicable$Type): B
public "asComponent"(): $Component
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): B
public "decorate"(decoration: $TextDecoration$Type): B
public "appendSpace"(): B
public static "configureAndBuild"<R, B extends $AbstractBuilder<(R)>>(builder: B, consumer: $Consumer$Type<(any)>): C
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractComponentBuilder$Type<C, B> = ($AbstractComponentBuilder<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractComponentBuilder_<C, B> = $AbstractComponentBuilder$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterfaceOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$NetInterfaceOrBuilder extends $MessageLiteOrBuilder {

 "hasTxBytesPerSecond"(): boolean
 "getTxBytesPerSecond"(): $SparkProtos$RollingAverageValues
 "hasRxBytesPerSecond"(): boolean
 "getRxBytesPerSecond"(): $SparkProtos$RollingAverageValues
 "hasRxPacketsPerSecond"(): boolean
 "getRxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
 "getTxPacketsPerSecond"(): $SparkProtos$RollingAverageValues
 "hasTxPacketsPerSecond"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$NetInterfaceOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$NetInterfaceOrBuilder$Type = ($SparkProtos$SystemStatistics$NetInterfaceOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$NetInterfaceOrBuilder_ = $SparkProtos$SystemStatistics$NetInterfaceOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$PaginationBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pagination$Renderer, $Pagination$Renderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer"
import {$Pagination, $Pagination$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination"
import {$Pagination$Builder, $Pagination$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder"
import {$Pagination$PageCommandFunction, $Pagination$PageCommandFunction$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$PageCommandFunction"
import {$Pagination$Renderer$RowRenderer, $Pagination$Renderer$RowRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer$RowRenderer"
import {$Pagination$Builder$CharacterAndStyle, $Pagination$Builder$CharacterAndStyle$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder$CharacterAndStyle"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $PaginationBuilder implements $Pagination$Builder {


public "line"(line: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
public "build"<T>(title: $Component$Type, rowRenderer: $Pagination$Renderer$RowRenderer$Type<(T)>, pageCommand: $Pagination$PageCommandFunction$Type): $Pagination<(T)>
public "width"(width: integer): $Pagination$Builder
public "resultsPerPage"(resultsPerPage: integer): $Pagination$Builder
public "previousButton"(previousButton: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
public "nextButton"(nextButton: $Consumer$Type<($Pagination$Builder$CharacterAndStyle$Type)>): $Pagination$Builder
public "renderer"(renderer: $Pagination$Renderer$Type): $Pagination$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaginationBuilder$Type = ($PaginationBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaginationBuilder_ = $PaginationBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$KeySerializer" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"

export class $KeySerializer extends $TypeAdapter<($Key)> {


public "write"(out: $JsonWriter$Type, value: $Key$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeySerializer$Type = ($KeySerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeySerializer_ = $KeySerializer$Type;
}}
declare module "packages/me/lucko/spark/common/command/modules/$HeapAnalysisModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"

export class $HeapAnalysisModule implements $CommandModule {

constructor()

public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeapAnalysisModule$Type = ($HeapAnalysisModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeapAnalysisModule_ = $HeapAnalysisModule$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int64Value" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$Int64ValueOrBuilder, $Int64ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int64ValueOrBuilder"
import {$Int64Value$Builder, $Int64Value$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int64Value$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $Int64Value extends $GeneratedMessageLite<($Int64Value), ($Int64Value$Builder)> implements $Int64ValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): long
public static "of"(arg0: long): $Int64Value
public static "parser"(): $Parser<($Int64Value)>
public static "newBuilder"(arg0: $Int64Value$Type): $Int64Value$Builder
public static "newBuilder"(): $Int64Value$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int64Value
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Int64Value
public static "getDefaultInstance"(): $Int64Value
public static "parseFrom"(arg0: $ByteString$Type): $Int64Value
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Int64Value
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Int64Value
public static "parseFrom"(arg0: $ByteBuffer$Type): $Int64Value
public static "parseFrom"(arg0: $CodedInputStream$Type): $Int64Value
public static "parseFrom"(arg0: $InputStream$Type): $Int64Value
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int64Value
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Int64Value
public static "parseFrom"(arg0: (byte)[]): $Int64Value
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Int64Value
get "value"(): long
get "defaultInstance"(): $Int64Value
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int64Value$Type = ($Int64Value);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int64Value_ = $Int64Value$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$BlockNBTComponent$WorldPos$Coordinate, $BlockNBTComponent$WorldPos$Coordinate$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $BlockNBTComponent extends $NBTComponent<($BlockNBTComponent), ($BlockNBTComponent$Builder)>, $ScopedComponent<($BlockNBTComponent)> {

 "pos"(): $BlockNBTComponent$Pos
 "pos"(pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
 "examinableProperties"(): $Stream<(any)>
 "absoluteWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent
 "relativeWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent
 "localPos"(left: double, up: double, forwards: double): $BlockNBTComponent
 "worldPos"(x: $BlockNBTComponent$WorldPos$Coordinate$Type, y: $BlockNBTComponent$WorldPos$Coordinate$Type, z: $BlockNBTComponent$WorldPos$Coordinate$Type): $BlockNBTComponent
 "separator"(): $Component
 "separator"(separator: $ComponentLike$Type): $BlockNBTComponent
 "nbtPath"(nbtPath: string): $BlockNBTComponent
 "nbtPath"(): string
 "interpret"(): boolean
 "interpret"(interpret: boolean): $BlockNBTComponent
 "append"(component: $Component$Type): $BlockNBTComponent
 "append"(like: $ComponentLike$Type): $BlockNBTComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $BlockNBTComponent
 "color"(color: $TextColor$Type): $BlockNBTComponent
 "style"(style: $Style$Type): $BlockNBTComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $BlockNBTComponent
 "style"(style: $Style$Builder$Type): $BlockNBTComponent
 "children"(children: $List$Type<(any)>): $BlockNBTComponent
 "mergeStyle"(that: $Component$Type): $BlockNBTComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $BlockNBTComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $BlockNBTComponent
 "colorIfAbsent"(color: $TextColor$Type): $BlockNBTComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $BlockNBTComponent
 "clickEvent"(event: $ClickEvent$Type): $BlockNBTComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $BlockNBTComponent
 "toBuilder"(): $BlockNBTComponent$Builder
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $BlockNBTComponent {
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function configureAndBuild<R, B>(builder: $BlockNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponent$Type = ($BlockNBTComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponent_ = $BlockNBTComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/interfaces/$ISSLChannel" {
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"

export interface $ISSLChannel {

 "getSSLEngine"(): $SSLEngine

(): $SSLEngine
}

export namespace $ISSLChannel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ISSLChannel$Type = ($ISSLChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ISSLChannel_ = $ISSLChannel$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageInfoFactory" {
import {$MessageInfoFactory, $MessageInfoFactory$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageInfoFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MessageInfo, $MessageInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageInfo"

export class $GeneratedMessageInfoFactory implements $MessageInfoFactory {


public static "getInstance"(): $GeneratedMessageInfoFactory
public "isSupported"(arg0: $Class$Type<(any)>): boolean
public "messageInfoFor"(arg0: $Class$Type<(any)>): $MessageInfo
get "instance"(): $GeneratedMessageInfoFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedMessageInfoFactory$Type = ($GeneratedMessageInfoFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedMessageInfoFactory_ = $GeneratedMessageInfoFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowItem" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$BinaryTagHolder, $BinaryTagHolder$Type} from "packages/me/lucko/spark/lib/adventure/nbt/api/$BinaryTagHolder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $HoverEvent$ShowItem implements $Examinable {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(item: $Key$Type, count: integer): $HoverEvent$ShowItem
public static "of"(item: $Keyed$Type, count: integer, nbt: $BinaryTagHolder$Type): $HoverEvent$ShowItem
public static "of"(item: $Keyed$Type, count: integer): $HoverEvent$ShowItem
public static "of"(item: $Key$Type, count: integer, nbt: $BinaryTagHolder$Type): $HoverEvent$ShowItem
public "count"(count: integer): $HoverEvent$ShowItem
public "count"(): integer
public "item"(): $Key
public "item"(item: $Key$Type): $HoverEvent$ShowItem
public "examinableProperties"(): $Stream<(any)>
public "nbt"(nbt: $BinaryTagHolder$Type): $HoverEvent$ShowItem
public "nbt"(): $BinaryTagHolder
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEvent$ShowItem$Type = ($HoverEvent$ShowItem);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEvent$ShowItem_ = $HoverEvent$ShowItem$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCall" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClassSourceLookup$MethodCall {

constructor(arg0: string, arg1: string, arg2: string)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getMethodDescriptor"(): string
public "getClassName"(): string
public "getMethodName"(): string
get "methodDescriptor"(): string
get "className"(): string
get "methodName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassSourceLookup$MethodCall$Type = ($ClassSourceLookup$MethodCall);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassSourceLookup$MethodCall_ = $ClassSourceLookup$MethodCall$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$StyleSerializer" {
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"

export class $StyleSerializer extends $TypeAdapter<($Style)> {


public "write"(out: $JsonWriter$Type, value: $Style$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StyleSerializer$Type = ($StyleSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StyleSerializer_ = $StyleSerializer$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$RegionOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$WorldStatistics$Chunk, $SparkProtos$WorldStatistics$Chunk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk"

export interface $SparkProtos$WorldStatistics$RegionOrBuilder extends $MessageLiteOrBuilder {

 "getChunks"(arg0: integer): $SparkProtos$WorldStatistics$Chunk
 "getChunksList"(): $List<($SparkProtos$WorldStatistics$Chunk)>
 "getChunksCount"(): integer
 "getTotalEntities"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$WorldStatistics$RegionOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$RegionOrBuilder$Type = ($SparkProtos$WorldStatistics$RegionOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$RegionOrBuilder_ = $SparkProtos$WorldStatistics$RegionOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java$Builder" {
import {$SparkProtos$SystemStatistics$JavaOrBuilder, $SparkProtos$SystemStatistics$JavaOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$JavaOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$Java, $SparkProtos$SystemStatistics$Java$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkProtos$SystemStatistics$Java$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Java), ($SparkProtos$SystemStatistics$Java$Builder)> implements $SparkProtos$SystemStatistics$JavaOrBuilder {


public "getVersion"(): string
public "setVersion"(arg0: string): $SparkProtos$SystemStatistics$Java$Builder
public "getVendor"(): string
public "getVersionBytes"(): $ByteString
public "setVendor"(arg0: string): $SparkProtos$SystemStatistics$Java$Builder
public "setVmArgs"(arg0: string): $SparkProtos$SystemStatistics$Java$Builder
public "setVendorVersion"(arg0: string): $SparkProtos$SystemStatistics$Java$Builder
public "clearVersion"(): $SparkProtos$SystemStatistics$Java$Builder
public "setVersionBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Java$Builder
public "setVendorBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Java$Builder
public "getVendorVersion"(): string
public "clearVendorVersion"(): $SparkProtos$SystemStatistics$Java$Builder
public "getVmArgs"(): string
public "getVmArgsBytes"(): $ByteString
public "clearVendor"(): $SparkProtos$SystemStatistics$Java$Builder
public "getVendorBytes"(): $ByteString
public "setVmArgsBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Java$Builder
public "clearVmArgs"(): $SparkProtos$SystemStatistics$Java$Builder
public "getVendorVersionBytes"(): $ByteString
public "setVendorVersionBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Java$Builder
get "version"(): string
set "version"(value: string)
get "vendor"(): string
get "versionBytes"(): $ByteString
set "vendor"(value: string)
set "vmArgs"(value: string)
set "vendorVersion"(value: string)
set "versionBytes"(value: $ByteString$Type)
set "vendorBytes"(value: $ByteString$Type)
get "vendorVersion"(): string
get "vmArgs"(): string
get "vmArgsBytes"(): $ByteString
get "vendorBytes"(): $ByteString
set "vmArgsBytes"(value: $ByteString$Type)
get "vendorVersionBytes"(): $ByteString
set "vendorVersionBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Java$Builder$Type = ($SparkProtos$SystemStatistics$Java$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Java$Builder_ = $SparkProtos$SystemStatistics$Java$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$GcOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$GcOrBuilder extends $MessageLiteOrBuilder {

 "getTotal"(): long
 "getAvgFrequency"(): double
 "getAvgTime"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$GcOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$GcOrBuilder$Type = ($SparkProtos$SystemStatistics$GcOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$GcOrBuilder_ = $SparkProtos$SystemStatistics$GcOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics$Builder" {
import {$SparkProtos$WindowStatisticsOrBuilder, $SparkProtos$WindowStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatisticsOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$WindowStatistics, $SparkProtos$WindowStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics"

export class $SparkProtos$WindowStatistics$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$WindowStatistics), ($SparkProtos$WindowStatistics$Builder)> implements $SparkProtos$WindowStatisticsOrBuilder {


public "getDuration"(): integer
public "setPlayers"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "setMsptMedian"(arg0: double): $SparkProtos$WindowStatistics$Builder
public "setMsptMax"(arg0: double): $SparkProtos$WindowStatistics$Builder
public "setEntities"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "setTileEntities"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "setChunks"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "setCpuSystem"(arg0: double): $SparkProtos$WindowStatistics$Builder
public "setCpuProcess"(arg0: double): $SparkProtos$WindowStatistics$Builder
public "setTicks"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "clearMsptMedian"(): $SparkProtos$WindowStatistics$Builder
public "clearMsptMax"(): $SparkProtos$WindowStatistics$Builder
public "clearPlayers"(): $SparkProtos$WindowStatistics$Builder
public "getCpuSystem"(): double
public "clearCpuProcess"(): $SparkProtos$WindowStatistics$Builder
public "getMsptMedian"(): double
public "clearTps"(): $SparkProtos$WindowStatistics$Builder
public "getTps"(): double
public "getMsptMax"(): double
public "getCpuProcess"(): double
public "clearTicks"(): $SparkProtos$WindowStatistics$Builder
public "clearCpuSystem"(): $SparkProtos$WindowStatistics$Builder
public "clearEntities"(): $SparkProtos$WindowStatistics$Builder
public "getTileEntities"(): integer
public "clearChunks"(): $SparkProtos$WindowStatistics$Builder
public "clearEndTime"(): $SparkProtos$WindowStatistics$Builder
public "clearStartTime"(): $SparkProtos$WindowStatistics$Builder
public "clearDuration"(): $SparkProtos$WindowStatistics$Builder
public "clearTileEntities"(): $SparkProtos$WindowStatistics$Builder
public "setEndTime"(arg0: long): $SparkProtos$WindowStatistics$Builder
public "getStartTime"(): long
public "getPlayers"(): integer
public "getEntities"(): integer
public "getTicks"(): integer
public "setDuration"(arg0: integer): $SparkProtos$WindowStatistics$Builder
public "getChunks"(): integer
public "getEndTime"(): long
public "setTps"(arg0: double): $SparkProtos$WindowStatistics$Builder
public "setStartTime"(arg0: long): $SparkProtos$WindowStatistics$Builder
get "duration"(): integer
set "players"(value: integer)
set "msptMedian"(value: double)
set "msptMax"(value: double)
set "entities"(value: integer)
set "tileEntities"(value: integer)
set "chunks"(value: integer)
set "cpuSystem"(value: double)
set "cpuProcess"(value: double)
set "ticks"(value: integer)
get "cpuSystem"(): double
get "msptMedian"(): double
get "tps"(): double
get "msptMax"(): double
get "cpuProcess"(): double
get "tileEntities"(): integer
set "endTime"(value: long)
get "startTime"(): long
get "players"(): integer
get "entities"(): integer
get "ticks"(): integer
set "duration"(value: integer)
get "chunks"(): integer
get "endTime"(): long
set "tps"(value: double)
set "startTime"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WindowStatistics$Builder$Type = ($SparkProtos$WindowStatistics$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WindowStatistics$Builder_ = $SparkProtos$WindowStatistics$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $TextComponentImpl extends $AbstractComponent implements $TextComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "content"(content: string): $TextComponent
public "content"(): string
public "examinableProperties"(): $Stream<(any)>
/**
 * 
 * @deprecated
 */
public static "ofChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public "append"(component: $Component$Type): $TextComponent
public "append"(like: $ComponentLike$Type): $TextComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TextComponent
public "color"(color: $TextColor$Type): $TextComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $TextComponent
public "style"(style: $Style$Builder$Type): $TextComponent
public "mergeStyle"(that: $Component$Type): $TextComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TextComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TextComponent
public "colorIfAbsent"(color: $TextColor$Type): $TextComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TextComponent
public "clickEvent"(event: $ClickEvent$Type): $TextComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $TextComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $TextComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $TextComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponentImpl$Type = ($TextComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponentImpl_ = $TextComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata$Builder" {
import {$SparkProtos$CommandSenderMetadata$Builder, $SparkProtos$CommandSenderMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Builder"
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkProtos$SystemStatistics$Builder, $SparkProtos$SystemStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Builder"
import {$SparkHeapProtos$HeapMetadata, $SparkHeapProtos$HeapMetadata$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata"
import {$SparkProtos$PlatformMetadata$Builder, $SparkProtos$PlatformMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Builder"
import {$SparkHeapProtos$HeapMetadataOrBuilder, $SparkHeapProtos$HeapMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadataOrBuilder"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"
import {$SparkProtos$PlatformStatistics$Builder, $SparkProtos$PlatformStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Builder"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"

export class $SparkHeapProtos$HeapMetadata$Builder extends $GeneratedMessageLite$Builder<($SparkHeapProtos$HeapMetadata), ($SparkHeapProtos$HeapMetadata$Builder)> implements $SparkHeapProtos$HeapMetadataOrBuilder {


public "setPlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setPlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Builder$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setPlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setPlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Builder$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Builder$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setCreator"(arg0: $SparkProtos$CommandSenderMetadata$Type): $SparkHeapProtos$HeapMetadata$Builder
public "setCreator"(arg0: $SparkProtos$CommandSenderMetadata$Builder$Type): $SparkHeapProtos$HeapMetadata$Builder
public "getCreator"(): $SparkProtos$CommandSenderMetadata
public "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
public "getSystemStatistics"(): $SparkProtos$SystemStatistics
public "hasPlatformMetadata"(): boolean
public "clearPlatformMetadata"(): $SparkHeapProtos$HeapMetadata$Builder
public "mergePlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Type): $SparkHeapProtos$HeapMetadata$Builder
public "hasSystemStatistics"(): boolean
public "clearPlatformStatistics"(): $SparkHeapProtos$HeapMetadata$Builder
public "mergeSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Type): $SparkHeapProtos$HeapMetadata$Builder
public "hasPlatformStatistics"(): boolean
public "clearSystemStatistics"(): $SparkHeapProtos$HeapMetadata$Builder
public "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
public "mergePlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkHeapProtos$HeapMetadata$Builder
public "hasCreator"(): boolean
public "clearCreator"(): $SparkHeapProtos$HeapMetadata$Builder
public "mergeCreator"(arg0: $SparkProtos$CommandSenderMetadata$Type): $SparkHeapProtos$HeapMetadata$Builder
set "platformMetadata"(value: $SparkProtos$PlatformMetadata$Type)
set "platformMetadata"(value: $SparkProtos$PlatformMetadata$Builder$Type)
set "platformStatistics"(value: $SparkProtos$PlatformStatistics$Type)
set "platformStatistics"(value: $SparkProtos$PlatformStatistics$Builder$Type)
set "systemStatistics"(value: $SparkProtos$SystemStatistics$Builder$Type)
set "systemStatistics"(value: $SparkProtos$SystemStatistics$Type)
set "creator"(value: $SparkProtos$CommandSenderMetadata$Type)
set "creator"(value: $SparkProtos$CommandSenderMetadata$Builder$Type)
get "creator"(): $SparkProtos$CommandSenderMetadata
get "platformStatistics"(): $SparkProtos$PlatformStatistics
get "systemStatistics"(): $SparkProtos$SystemStatistics
get "platformMetadata"(): $SparkProtos$PlatformMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapMetadata$Builder$Type = ($SparkHeapProtos$HeapMetadata$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapMetadata$Builder_ = $SparkHeapProtos$HeapMetadata$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$Pointered" {
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"

export interface $Pointered {

 "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
 "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
 "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T
 "pointers"(): $Pointers
}

export namespace $Pointered {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pointered$Type = ($Pointered);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pointered_ = $Pointered$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"

export interface $Sound$Type extends $Keyed {

 "key"(): $Key

(): $Key
}

export namespace $Sound$Type {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Type$Type = ($Sound$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound$Type_ = $Sound$Type$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$TranslationRegistryImpl" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$MessageFormat, $MessageFormat$Type} from "packages/java/text/$MessageFormat"
import {$ResourceBundle, $ResourceBundle$Type} from "packages/java/util/$ResourceBundle"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$TranslationRegistry, $TranslationRegistry$Type} from "packages/me/lucko/spark/lib/adventure/translation/$TranslationRegistry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $TranslationRegistryImpl implements $Examinable, $TranslationRegistry {


public "name"(): $Key
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "contains"(key: string): boolean
public "register"(key: string, locale: $Locale$Type, format: $MessageFormat$Type): void
public "unregister"(key: string): void
public "defaultLocale"(defaultLocale: $Locale$Type): void
public "examinableProperties"(): $Stream<(any)>
public "translate"(key: string, locale: $Locale$Type): $MessageFormat
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public static "create"(name: $Key$Type): $TranslationRegistry
public "registerAll"(locale: $Locale$Type, path: $Path$Type, escapeSingleQuotes: boolean): void
public "registerAll"(locale: $Locale$Type, keys: $Set$Type<(string)>, arg2: $Function$Type<(string), ($MessageFormat$Type)>): void
public "registerAll"(locale: $Locale$Type, formats: $Map$Type<(string), ($MessageFormat$Type)>): void
public "registerAll"(locale: $Locale$Type, bundle: $ResourceBundle$Type, escapeSingleQuotes: boolean): void
public static "parseLocale"(string: string): $Locale
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslationRegistryImpl$Type = ($TranslationRegistryImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslationRegistryImpl_ = $TranslationRegistryImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/renderer/$AbstractComponentRenderer" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$ComponentRenderer, $ComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$ComponentRenderer"

export class $AbstractComponentRenderer<C> implements $ComponentRenderer<(C)> {

constructor()

public "render"(component: $Component$Type, context: C): $Component
public "mapContext"<T>(transformer: $Function$Type<(T), (C)>): $ComponentRenderer<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractComponentRenderer$Type<C> = ($AbstractComponentRenderer<(C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractComponentRenderer_<C> = $AbstractComponentRenderer$Type<(C)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$AbstractMessageLite$Builder, $AbstractMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite$Builder"

export class $GeneratedMessageLite$Builder<MessageType extends $GeneratedMessageLite<(MessageType), (BuilderType)>, BuilderType extends $GeneratedMessageLite$Builder<(MessageType), (BuilderType)>> extends $AbstractMessageLite$Builder<(MessageType), (BuilderType)> {


public "clone"(): BuilderType
public "getDefaultInstanceForType"(): MessageType
public "isInitialized"(): boolean
public "mergeFrom"(arg0: MessageType): BuilderType
get "defaultInstanceForType"(): MessageType
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedMessageLite$Builder$Type<MessageType, BuilderType> = ($GeneratedMessageLite$Builder<(MessageType), (BuilderType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedMessageLite$Builder_<MessageType, BuilderType> = $GeneratedMessageLite$Builder$Type<(MessageType), (BuilderType)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BytesValue$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$BytesValue, $BytesValue$Type} from "packages/me/lucko/spark/lib/protobuf/$BytesValue"
import {$BytesValueOrBuilder, $BytesValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$BytesValueOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $BytesValue$Builder extends $GeneratedMessageLite$Builder<($BytesValue), ($BytesValue$Builder)> implements $BytesValueOrBuilder {


public "getValue"(): $ByteString
public "setValue"(arg0: $ByteString$Type): $BytesValue$Builder
public "clearValue"(): $BytesValue$Builder
get "value"(): $ByteString
set "value"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesValue$Builder$Type = ($BytesValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesValue$Builder_ = $BytesValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider$Accessor" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment, $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment$Type} from "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment"

export interface $ByteBuddyAgent$AttachmentProvider$Accessor {

 "isAvailable"(): boolean
 "getExternalAttachment"(): $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment
 "getVirtualMachineType"(): $Class<(any)>
 "isExternalAttachmentRequired"(): boolean
}

export namespace $ByteBuddyAgent$AttachmentProvider$Accessor {
const VIRTUAL_MACHINE_TYPE_NAME: string
const VIRTUAL_MACHINE_TYPE_NAME_J9: string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBuddyAgent$AttachmentProvider$Accessor$Type = ($ByteBuddyAgent$AttachmentProvider$Accessor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBuddyAgent$AttachmentProvider$Accessor_ = $ByteBuddyAgent$AttachmentProvider$Accessor$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeCommandSender" {
import {$ForgeSparkPlugin, $ForgeSparkPlugin$Type} from "packages/me/lucko/spark/forge/plugin/$ForgeSparkPlugin"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$AbstractCommandSender, $AbstractCommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$AbstractCommandSender"

export class $ForgeCommandSender extends $AbstractCommandSender<($CommandSource)> {

constructor(arg0: $CommandSource$Type, arg1: $ForgeSparkPlugin$Type)

public "getName"(): string
public "sendMessage"(arg0: $Component$Type): void
public "getUniqueId"(): $UUID
public "hasPermission"(arg0: string): boolean
get "name"(): string
get "uniqueId"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeCommandSender$Type = ($ForgeCommandSender);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeCommandSender_ = $ForgeCommandSender$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$LimitExceededException" {
import {$InvalidDataException, $InvalidDataException$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidDataException"

export class $LimitExceededException extends $InvalidDataException {

constructor(arg0: string)
constructor(arg0: string, arg1: integer)
constructor(arg0: integer)
constructor()

public "getLimit"(): integer
get "limit"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LimitExceededException$Type = ($LimitExceededException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LimitExceededException_ = $LimitExceededException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Parser" {
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $Parser<MessageType> {

 "parsePartialFrom"(arg0: $InputStream$Type): MessageType
 "parsePartialFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parsePartialFrom"(arg0: (byte)[]): MessageType
 "parsePartialFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parsePartialFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): MessageType
 "parsePartialFrom"(arg0: (byte)[], arg1: integer, arg2: integer): MessageType
 "parsePartialFrom"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: $ExtensionRegistryLite$Type): MessageType
 "parsePartialFrom"(arg0: $ByteString$Type): MessageType
 "parsePartialFrom"(arg0: $CodedInputStream$Type): MessageType
 "parsePartialFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parseDelimitedFrom"(arg0: $InputStream$Type): MessageType
 "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parsePartialDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parsePartialDelimitedFrom"(arg0: $InputStream$Type): MessageType
 "parseFrom"(arg0: $InputStream$Type): MessageType
 "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: $CodedInputStream$Type): MessageType
 "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: $ByteString$Type): MessageType
 "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: $ByteBuffer$Type): MessageType
 "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: (byte)[]): MessageType
 "parseFrom"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: $ExtensionRegistryLite$Type): MessageType
 "parseFrom"(arg0: (byte)[], arg1: integer, arg2: integer): MessageType
}

export namespace $Parser {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Parser$Type<MessageType> = ($Parser<(MessageType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Parser_<MessageType> = $Parser$Type<(MessageType)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder" {
import {$HandshakeBuilder, $HandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"

export interface $ServerHandshakeBuilder extends $HandshakeBuilder, $ServerHandshake {

 "setHttpStatus"(arg0: short): void
 "setHttpStatusMessage"(arg0: string): void
 "put"(arg0: string, arg1: string): void
 "setContent"(arg0: (byte)[]): void
 "getHttpStatus"(): short
 "getHttpStatusMessage"(): string
 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $ServerHandshakeBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ServerHandshakeBuilder$Type = ($ServerHandshakeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ServerHandshakeBuilder_ = $ServerHandshakeBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$PointersImpl" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Pointers$Builder, $Pointers$Builder$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $PointersImpl implements $Pointers {


public "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
public "supports"<T>(pointer: $Pointer$Type<(T)>): boolean
public "toBuilder"(): $Pointers$Builder
public "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
public static "builder"(): $Pointers$Builder
public static "empty"(): $Pointers
public "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $Pointers$Builder$Type, consumer: $Consumer$Type<(any)>): $Pointers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointersImpl$Type = ($PointersImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PointersImpl_ = $PointersImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Condition" {
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$MatchResult, $MatchResult$Type} from "packages/java/util/regex/$MatchResult"

export interface $TextReplacementConfig$Condition {

 "shouldReplace"(result: $MatchResult$Type, matchCount: integer, replaced: integer): $PatternReplacementResult

(result: $MatchResult$Type, matchCount: integer, replaced: integer): $PatternReplacementResult
}

export namespace $TextReplacementConfig$Condition {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementConfig$Condition$Type = ($TextReplacementConfig$Condition);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementConfig$Condition_ = $TextReplacementConfig$Condition$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry" {
import {$SparkHeapProtos$HeapEntry$Builder, $SparkHeapProtos$HeapEntry$Builder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry$Builder"
import {$SparkHeapProtos$HeapEntryOrBuilder, $SparkHeapProtos$HeapEntryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntryOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkHeapProtos$HeapEntry extends $GeneratedMessageLite<($SparkHeapProtos$HeapEntry), ($SparkHeapProtos$HeapEntry$Builder)> implements $SparkHeapProtos$HeapEntryOrBuilder {
static readonly "ORDER_FIELD_NUMBER": integer
static readonly "INSTANCES_FIELD_NUMBER": integer
static readonly "SIZE_FIELD_NUMBER": integer
static readonly "TYPE_FIELD_NUMBER": integer


public "getType"(): string
public "getSize"(): long
public static "parser"(): $Parser<($SparkHeapProtos$HeapEntry)>
public static "newBuilder"(): $SparkHeapProtos$HeapEntry$Builder
public static "newBuilder"(arg0: $SparkHeapProtos$HeapEntry$Type): $SparkHeapProtos$HeapEntry$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapEntry
public static "getDefaultInstance"(): $SparkHeapProtos$HeapEntry
public "getOrder"(): integer
public static "parseFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $ByteString$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapEntry
public static "parseFrom"(arg0: (byte)[]): $SparkHeapProtos$HeapEntry
public "getTypeBytes"(): $ByteString
public "getInstances"(): integer
get "type"(): string
get "size"(): long
get "defaultInstance"(): $SparkHeapProtos$HeapEntry
get "order"(): integer
get "typeBytes"(): $ByteString
get "instances"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapEntry$Type = ($SparkHeapProtos$HeapEntry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapEntry_ = $SparkHeapProtos$HeapEntry$Type;
}}
declare module "packages/me/lucko/spark/common/command/modules/$ActivityLogModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"
import {$Pagination$Renderer$RowRenderer, $Pagination$Renderer$RowRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer$RowRenderer"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Activity, $Activity$Type} from "packages/me/lucko/spark/common/activitylog/$Activity"

export class $ActivityLogModule implements $CommandModule, $Pagination$Renderer$RowRenderer<($Activity)> {

constructor()

public "renderRow"(arg0: $Activity$Type, arg1: integer): $Collection<($Component)>
public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ActivityLogModule$Type = ($ActivityLogModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ActivityLogModule_ = $ActivityLogModule$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$InvalidKeyException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $InvalidKeyException extends $RuntimeException {


public "keyValue"(): string
public "keyNamespace"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidKeyException$Type = ($InvalidKeyException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidKeyException_ = $InvalidKeyException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryFactory" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $ExtensionRegistryFactory {


public static "create"(): $ExtensionRegistryLite
public static "createEmpty"(): $ExtensionRegistryLite
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionRegistryFactory$Type = ($ExtensionRegistryFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionRegistryFactory_ = $ExtensionRegistryFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Mixin$Builder" {
import {$Mixin, $Mixin$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MixinOrBuilder, $MixinOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MixinOrBuilder"

export class $Mixin$Builder extends $GeneratedMessageLite$Builder<($Mixin), ($Mixin$Builder)> implements $MixinOrBuilder {


public "setRootBytes"(arg0: $ByteString$Type): $Mixin$Builder
public "clearRoot"(): $Mixin$Builder
public "getName"(): string
public "setName"(arg0: string): $Mixin$Builder
public "getRoot"(): string
public "setNameBytes"(arg0: $ByteString$Type): $Mixin$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Mixin$Builder
public "setRoot"(arg0: string): $Mixin$Builder
public "getRootBytes"(): $ByteString
set "rootBytes"(value: $ByteString$Type)
get "name"(): string
set "name"(value: string)
get "root"(): string
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
set "root"(value: string)
get "rootBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Mixin$Builder$Type = ($Mixin$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Mixin$Builder_ = $Mixin$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBarImpl" {
import {$HackyBossBarPlatformBridge, $HackyBossBarPlatformBridge$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$HackyBossBarPlatformBridge"
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$BossBar$Overlay, $BossBar$Overlay$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Overlay"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$BossBar$Listener, $BossBar$Listener$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Listener"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BossBar$Color, $BossBar$Color$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Color"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BossBar$Flag, $BossBar$Flag$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Flag"

export class $BossBarImpl extends $HackyBossBarPlatformBridge implements $BossBar {


public "removeFlag"(flag: $BossBar$Flag$Type): $BossBar
public "name"(newName: $Component$Type): $BossBar
public "name"(): $Component
public "toString"(): string
public "flags"(newFlags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
public "flags"(): $Set<($BossBar$Flag)>
public "color"(newColor: $BossBar$Color$Type): $BossBar
public "color"(): $BossBar$Color
public "addFlag"(flag: $BossBar$Flag$Type): $BossBar
public "examinableProperties"(): $Stream<(any)>
public "hasFlag"(flag: $BossBar$Flag$Type): boolean
public "removeListener"(listener: $BossBar$Listener$Type): $BossBar
public "overlay"(newOverlay: $BossBar$Overlay$Type): $BossBar
public "overlay"(): $BossBar$Overlay
public "addFlags"(...flags: ($BossBar$Flag$Type)[]): $BossBar
public "addFlags"(flags: $Iterable$Type<($BossBar$Flag$Type)>): $BossBar
public "progress"(newProgress: float): $BossBar
public "progress"(): float
public "addListener"(listener: $BossBar$Listener$Type): $BossBar
public "removeFlags"(...flags: ($BossBar$Flag$Type)[]): $BossBar
public "removeFlags"(flags: $Iterable$Type<($BossBar$Flag$Type)>): $BossBar
public "name"(name: $ComponentLike$Type): $BossBar
/**
 * 
 * @deprecated
 */
public "percent"(): float
/**
 * 
 * @deprecated
 */
public "percent"(progress: float): $BossBar
public static "bossBar"(name: $ComponentLike$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type): $BossBar
public static "bossBar"(name: $Component$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type, flags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
public static "bossBar"(name: $Component$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type): $BossBar
public static "bossBar"(name: $ComponentLike$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type, flags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBarImpl$Type = ($BossBarImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBarImpl_ = $BossBarImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageSetSchema" {
import {$ArrayDecoders$Registers, $ArrayDecoders$Registers$Type} from "packages/me/lucko/spark/lib/protobuf/$ArrayDecoders$Registers"
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"

export class $MessageSetSchema<T> implements $Schema<(T)> {


public "equals"(arg0: T, arg1: T): boolean
public "hashCode"(arg0: T): integer
public "newInstance"(): T
public "writeTo"(arg0: T, arg1: $Writer$Type): void
public "makeImmutable"(arg0: T): void
public "getSerializedSize"(arg0: T): integer
public "isInitialized"(arg0: T): boolean
public "mergeFrom"(arg0: T, arg1: T): void
public "mergeFrom"(arg0: T, arg1: $Reader$Type, arg2: $ExtensionRegistryLite$Type): void
public "mergeFrom"(arg0: T, arg1: (byte)[], arg2: integer, arg3: integer, arg4: $ArrayDecoders$Registers$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSetSchema$Type<T> = ($MessageSetSchema<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageSetSchema_<T> = $MessageSetSchema$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/title/$TitleImpl" {
import {$TitlePart, $TitlePart$Type} from "packages/me/lucko/spark/lib/adventure/title/$TitlePart"
import {$Title, $Title$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Title$Times, $Title$Times$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title$Times"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $TitleImpl implements $Title {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "part"<T>(part: $TitlePart$Type<(T)>): T
public "examinableProperties"(): $Stream<(any)>
public "title"(): $Component
public "times"(): $Title$Times
public "subtitle"(): $Component
public static "title"(title: $Component$Type, subtitle: $Component$Type): $Title
public static "title"(title: $Component$Type, subtitle: $Component$Type, times: $Title$Times$Type): $Title
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TitleImpl$Type = ($TitleImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TitleImpl_ = $TitleImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $SignedMessage$Signature extends $Examinable {

 "bytes"(): (byte)[]
 "examinableProperties"(): $Stream<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R

(): (byte)[]
}

export namespace $SignedMessage$Signature {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignedMessage$Signature$Type = ($SignedMessage$Signature);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignedMessage$Signature_ = $SignedMessage$Signature$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/title/$TitlePart" {
import {$Title$Times, $Title$Times$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title$Times"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $TitlePart<T> {

}

export namespace $TitlePart {
const TITLE: $TitlePart<($Component)>
const SUBTITLE: $TitlePart<($Component)>
const TIMES: $TitlePart<($Title$Times)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TitlePart$Type<T> = ($TitlePart<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TitlePart_<T> = $TitlePart$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Sound$Source extends $Enum<($Sound$Source)> {
static readonly "MASTER": $Sound$Source
static readonly "MUSIC": $Sound$Source
static readonly "RECORD": $Sound$Source
static readonly "WEATHER": $Sound$Source
static readonly "BLOCK": $Sound$Source
static readonly "HOSTILE": $Sound$Source
static readonly "NEUTRAL": $Sound$Source
static readonly "PLAYER": $Sound$Source
static readonly "AMBIENT": $Sound$Source
static readonly "VOICE": $Sound$Source
static readonly "NAMES": $Index<(string), ($Sound$Source)>


public static "values"(): ($Sound$Source)[]
public static "valueOf"(name: string): $Sound$Source
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Source$Type = (("voice") | ("music") | ("hostile") | ("record") | ("weather") | ("neutral") | ("block") | ("ambient") | ("master") | ("player")) | ($Sound$Source);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound$Source_ = $Sound$Source$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World$Builder" {
import {$SparkProtos$WorldStatistics$Region$Builder, $SparkProtos$WorldStatistics$Region$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$WorldStatistics$WorldOrBuilder, $SparkProtos$WorldStatistics$WorldOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$WorldOrBuilder"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkProtos$WorldStatistics$Region, $SparkProtos$WorldStatistics$Region$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region"
import {$SparkProtos$WorldStatistics$World, $SparkProtos$WorldStatistics$World$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World"

export class $SparkProtos$WorldStatistics$World$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$WorldStatistics$World), ($SparkProtos$WorldStatistics$World$Builder)> implements $SparkProtos$WorldStatistics$WorldOrBuilder {


public "getRegionsList"(): $List<($SparkProtos$WorldStatistics$Region)>
public "getRegionsCount"(): integer
public "getName"(): string
public "setName"(arg0: string): $SparkProtos$WorldStatistics$World$Builder
public "setNameBytes"(arg0: $ByteString$Type): $SparkProtos$WorldStatistics$World$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkProtos$WorldStatistics$World$Builder
public "getRegions"(arg0: integer): $SparkProtos$WorldStatistics$Region
public "clearTotalEntities"(): $SparkProtos$WorldStatistics$World$Builder
public "setTotalEntities"(arg0: integer): $SparkProtos$WorldStatistics$World$Builder
public "addRegions"(arg0: $SparkProtos$WorldStatistics$Region$Builder$Type): $SparkProtos$WorldStatistics$World$Builder
public "addRegions"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Region$Type): $SparkProtos$WorldStatistics$World$Builder
public "addRegions"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Region$Builder$Type): $SparkProtos$WorldStatistics$World$Builder
public "addRegions"(arg0: $SparkProtos$WorldStatistics$Region$Type): $SparkProtos$WorldStatistics$World$Builder
public "getTotalEntities"(): integer
public "removeRegions"(arg0: integer): $SparkProtos$WorldStatistics$World$Builder
public "clearRegions"(): $SparkProtos$WorldStatistics$World$Builder
public "setRegions"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Region$Builder$Type): $SparkProtos$WorldStatistics$World$Builder
public "setRegions"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Region$Type): $SparkProtos$WorldStatistics$World$Builder
public "addAllRegions"(arg0: $Iterable$Type<(any)>): $SparkProtos$WorldStatistics$World$Builder
get "regionsList"(): $List<($SparkProtos$WorldStatistics$Region)>
get "regionsCount"(): integer
get "name"(): string
set "name"(value: string)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
set "totalEntities"(value: integer)
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$World$Builder$Type = ($SparkProtos$WorldStatistics$World$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$World$Builder_ = $SparkProtos$WorldStatistics$World$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketFactory" {
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketAdapter, $WebSocketAdapter$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketAdapter"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"

export interface $WebSocketFactory {

 "createWebSocket"(arg0: $WebSocketAdapter$Type, arg1: $Draft$Type): $WebSocket
 "createWebSocket"(arg0: $WebSocketAdapter$Type, arg1: $List$Type<($Draft$Type)>): $WebSocket
}

export namespace $WebSocketFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketFactory$Type = ($WebSocketFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketFactory_ = $WebSocketFactory$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$SparkProtos$PlatformMetadata$Type, $SparkProtos$PlatformMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Type"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkProtos$PlatformMetadata$Builder, $SparkProtos$PlatformMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Builder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$SparkProtos$PlatformMetadataOrBuilder, $SparkProtos$PlatformMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadataOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$PlatformMetadata extends $GeneratedMessageLite<($SparkProtos$PlatformMetadata), ($SparkProtos$PlatformMetadata$Builder)> implements $SparkProtos$PlatformMetadataOrBuilder {
static readonly "TYPE_FIELD_NUMBER": integer
static readonly "NAME_FIELD_NUMBER": integer
static readonly "VERSION_FIELD_NUMBER": integer
static readonly "MINECRAFT_VERSION_FIELD_NUMBER": integer
static readonly "SPARK_VERSION_FIELD_NUMBER": integer


public "getName"(): string
public "getType"(): $SparkProtos$PlatformMetadata$Type
public static "parser"(): $Parser<($SparkProtos$PlatformMetadata)>
public "getVersion"(): string
public static "newBuilder"(arg0: $SparkProtos$PlatformMetadata$Type): $SparkProtos$PlatformMetadata$Builder
public static "newBuilder"(): $SparkProtos$PlatformMetadata$Builder
public "getSparkVersion"(): integer
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformMetadata
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "getDefaultInstance"(): $SparkProtos$PlatformMetadata
public "getNameBytes"(): $ByteString
public "getMinecraftVersion"(): string
public "getMinecraftVersionBytes"(): $ByteString
public "getTypeValue"(): integer
public "getVersionBytes"(): $ByteString
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformMetadata
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformMetadata
get "name"(): string
get "type"(): $SparkProtos$PlatformMetadata$Type
get "version"(): string
get "sparkVersion"(): integer
get "defaultInstance"(): $SparkProtos$PlatformMetadata
get "nameBytes"(): $ByteString
get "minecraftVersion"(): string
get "minecraftVersionBytes"(): $ByteString
get "typeValue"(): integer
get "versionBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformMetadata$Type = ($SparkProtos$PlatformMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformMetadata_ = $SparkProtos$PlatformMetadata$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$NullValue" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $NullValue extends $Enum<($NullValue)> implements $Internal$EnumLite {
static readonly "NULL_VALUE": $NullValue
static readonly "UNRECOGNIZED": $NullValue
static readonly "NULL_VALUE_VALUE": integer


public static "values"(): ($NullValue)[]
public static "valueOf"(arg0: string): $NullValue
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $NullValue
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($NullValue)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $NullValue
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NullValue$Type = (("null_value") | ("unrecognized")) | ($NullValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NullValue_ = $NullValue$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Edge" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Edge {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Edge$Type = ($Edge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Edge_ = $Edge$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$Translator" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$MessageFormat, $MessageFormat$Type} from "packages/java/text/$MessageFormat"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export interface $Translator {

 "name"(): $Key
 "translate"(key: string, locale: $Locale$Type): $MessageFormat
}

export namespace $Translator {
function parseLocale(string: string): $Locale
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Translator$Type = ($Translator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Translator_ = $Translator$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$KeybindComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $KeybindComponentImpl extends $AbstractComponent implements $KeybindComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "style"(style: $Style$Type): $KeybindComponent
public "keybind"(): string
public "keybind"(keybind: string): $KeybindComponent
public "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $KeybindComponent
public "append"(like: $ComponentLike$Type): $KeybindComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $KeybindComponent
public "color"(color: $TextColor$Type): $KeybindComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $KeybindComponent
public "style"(style: $Style$Builder$Type): $KeybindComponent
public "mergeStyle"(that: $Component$Type): $KeybindComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $KeybindComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $KeybindComponent
public "colorIfAbsent"(color: $TextColor$Type): $KeybindComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $KeybindComponent
public "clickEvent"(event: $ClickEvent$Type): $KeybindComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $KeybindComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $KeybindComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindComponentImpl$Type = ($KeybindComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeybindComponentImpl_ = $KeybindComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/api/$Spark" {
import {$GenericStatistic, $GenericStatistic$Type} from "packages/me/lucko/spark/api/statistic/types/$GenericStatistic"
import {$StatisticWindow$CpuUsage, $StatisticWindow$CpuUsage$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$CpuUsage"
import {$GarbageCollector, $GarbageCollector$Type} from "packages/me/lucko/spark/api/gc/$GarbageCollector"
import {$DoubleStatistic, $DoubleStatistic$Type} from "packages/me/lucko/spark/api/statistic/types/$DoubleStatistic"
import {$StatisticWindow$TicksPerSecond, $StatisticWindow$TicksPerSecond$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$TicksPerSecond"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$StatisticWindow$MillisPerTick, $StatisticWindow$MillisPerTick$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$MillisPerTick"

export interface $Spark {

 "gc"(): $Map<(string), ($GarbageCollector)>
 "cpuSystem"(): $DoubleStatistic<($StatisticWindow$CpuUsage)>
 "cpuProcess"(): $DoubleStatistic<($StatisticWindow$CpuUsage)>
 "tps"(): $DoubleStatistic<($StatisticWindow$TicksPerSecond)>
 "mspt"(): $GenericStatistic<($DoubleAverageInfo), ($StatisticWindow$MillisPerTick)>
}

export namespace $Spark {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Spark$Type = ($Spark);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Spark_ = $Spark$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$Audience" {
import {$SignedMessage, $SignedMessage$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage"
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$SignedMessage$Signature, $SignedMessage$Signature$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Pointered, $Pointered$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointered"
import {$ForwardingAudience, $ForwardingAudience$Type} from "packages/me/lucko/spark/lib/adventure/audience/$ForwardingAudience"
import {$TitlePart, $TitlePart$Type} from "packages/me/lucko/spark/lib/adventure/title/$TitlePart"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Book$Builder, $Book$Builder$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder"
import {$Sound$Emitter, $Sound$Emitter$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Emitter"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Identified, $Identified$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identified"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$MessageType, $MessageType$Type} from "packages/me/lucko/spark/lib/adventure/audience/$MessageType"
import {$Title, $Title$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound"
import {$Book, $Book$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Sound, $Sound$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound"

export interface $Audience extends $Pointered {

/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type): void
 "sendMessage"(signedMessage: $SignedMessage$Type, boundChatType: $ChatType$Bound$Type): void
 "sendMessage"(message: $ComponentLike$Type, boundChatType: $ChatType$Bound$Type): void
 "sendMessage"(message: $Component$Type, boundChatType: $ChatType$Bound$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $Component$Type, type: $MessageType$Type): void
 "sendMessage"(message: $ComponentLike$Type): void
 "sendMessage"(message: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type): void
 "forEachAudience"(action: $Consumer$Type<(any)>): void
 "filterAudience"(filter: $Predicate$Type<(any)>): $Audience
 "deleteMessage"(signature: $SignedMessage$Signature$Type): void
 "deleteMessage"(signedMessage: $SignedMessage$Type): void
 "clearTitle"(): void
 "sendActionBar"(message: $ComponentLike$Type): void
 "sendActionBar"(message: $Component$Type): void
 "showBossBar"(bar: $BossBar$Type): void
 "hideBossBar"(bar: $BossBar$Type): void
 "resetTitle"(): void
 "openBook"(book: $Book$Type): void
 "openBook"(book: $Book$Builder$Type): void
 "sendTitlePart"<T>(part: $TitlePart$Type<(T)>, value: T): void
 "stopSound"(stop: $SoundStop$Type): void
 "stopSound"(sound: $Sound$Type): void
 "showTitle"(title: $Title$Type): void
 "playSound"(sound: $Sound$Type, emitter: $Sound$Emitter$Type): void
 "playSound"(sound: $Sound$Type, x: double, y: double, z: double): void
 "playSound"(sound: $Sound$Type): void
 "sendPlayerListHeaderAndFooter"(header: $ComponentLike$Type, footer: $ComponentLike$Type): void
 "sendPlayerListHeaderAndFooter"(header: $Component$Type, footer: $Component$Type): void
 "sendPlayerListHeader"(header: $ComponentLike$Type): void
 "sendPlayerListHeader"(header: $Component$Type): void
 "sendPlayerListFooter"(footer: $Component$Type): void
 "sendPlayerListFooter"(footer: $ComponentLike$Type): void
 "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
 "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
 "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T
 "pointers"(): $Pointers
}

export namespace $Audience {
function empty(): $Audience
function audience(audiences: $Iterable$Type<(any)>): $ForwardingAudience
function audience(...audiences: ($Audience$Type)[]): $Audience
function toAudience(): $Collector<(any), (any), ($ForwardingAudience)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Audience$Type = ($Audience);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Audience_ = $Audience$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage" {
import {$SparkProtos$SystemStatistics$Cpu$Usage$Builder, $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage$Builder"
import {$SparkProtos$SystemStatistics$Cpu$UsageOrBuilder, $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$UsageOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Cpu$Usage extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Cpu$Usage), ($SparkProtos$SystemStatistics$Cpu$Usage$Builder)> implements $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder {
static readonly "LAST1M_FIELD_NUMBER": integer
static readonly "LAST15M_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Cpu$Usage)>
public static "newBuilder"(): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Type): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu$Usage
public "getLast1M"(): double
public "getLast15M"(): double
get "defaultInstance"(): $SparkProtos$SystemStatistics$Cpu$Usage
get "last1M"(): double
get "last15M"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Cpu$Usage$Type = ($SparkProtos$SystemStatistics$Cpu$Usage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Cpu$Usage_ = $SparkProtos$SystemStatistics$Cpu$Usage$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt64ValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $UInt64ValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $UInt64ValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt64ValueOrBuilder$Type = ($UInt64ValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt64ValueOrBuilder_ = $UInt64ValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$StyleGetter" {
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StyleGetter {

 "color"(): $TextColor
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
}

export namespace $StyleGetter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StyleGetter$Type = ($StyleGetter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StyleGetter_ = $StyleGetter$Type;
}}
declare module "packages/me/lucko/spark/common/util/$FormatUtil" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $FormatUtil extends $Enum<($FormatUtil)> {


public static "values"(): ($FormatUtil)[]
public static "valueOf"(arg0: string): $FormatUtil
public static "percent"(arg0: double, arg1: double): string
public static "formatSeconds"(arg0: long): string
public static "formatBytes"(arg0: long, arg1: $TextColor$Type, arg2: string): $Component
public static "formatBytes"(arg0: long): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FormatUtil$Type = (never) | ($FormatUtil);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FormatUtil_ = $FormatUtil$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$ChunksResult" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$ChunkInfo, $ChunkInfo$Type} from "packages/me/lucko/spark/common/platform/world/$ChunkInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $WorldInfoProvider$ChunksResult<T extends $ChunkInfo<(any)>> {

constructor()

public "put"(arg0: string, arg1: $List$Type<(T)>): void
public "getWorlds"(): $Map<(string), ($List<(T)>)>
get "worlds"(): $Map<(string), ($List<(T)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldInfoProvider$ChunksResult$Type<T> = ($WorldInfoProvider$ChunksResult<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldInfoProvider$ChunksResult_<T> = $WorldInfoProvider$ChunksResult$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$Constants" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Constants {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Constants$Type = ($Constants);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Constants_ = $Constants$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Context" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Context {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Context$Type = ($Context);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Context_ = $Context$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Field$Builder" {
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$Field$Cardinality, $Field$Cardinality$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Cardinality"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$FieldOrBuilder, $FieldOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Field, $Field$Type} from "packages/me/lucko/spark/lib/protobuf/$Field"
import {$Field$Kind, $Field$Kind$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Kind"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Field$Builder extends $GeneratedMessageLite$Builder<($Field), ($Field$Builder)> implements $FieldOrBuilder {


public "clearKind"(): $Field$Builder
public "clearNumber"(): $Field$Builder
public "getName"(): string
public "setName"(arg0: string): $Field$Builder
public "getDefaultValue"(): string
public "getNumber"(): integer
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: $Option$Type): $Field$Builder
public "addOptions"(arg0: integer, arg1: $Option$Type): $Field$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $Field$Builder
public "addOptions"(arg0: $Option$Builder$Type): $Field$Builder
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $Field$Builder
public "clearOptions"(): $Field$Builder
public "removeOptions"(arg0: integer): $Field$Builder
public "setNameBytes"(arg0: $ByteString$Type): $Field$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Field$Builder
public "setNumber"(arg0: integer): $Field$Builder
public "setDefaultValue"(arg0: string): $Field$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $Field$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $Field$Builder
public "setKind"(arg0: $Field$Kind$Type): $Field$Builder
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getKind"(): $Field$Kind
public "getCardinality"(): $Field$Cardinality
public "getJsonName"(): string
public "setPacked"(arg0: boolean): $Field$Builder
public "clearPacked"(): $Field$Builder
public "getJsonNameBytes"(): $ByteString
public "setOneofIndex"(arg0: integer): $Field$Builder
public "clearDefaultValue"(): $Field$Builder
public "clearOneofIndex"(): $Field$Builder
public "setCardinality"(arg0: $Field$Cardinality$Type): $Field$Builder
public "clearJsonName"(): $Field$Builder
public "clearCardinality"(): $Field$Builder
public "setJsonNameBytes"(arg0: $ByteString$Type): $Field$Builder
public "getKindValue"(): integer
public "setJsonName"(arg0: string): $Field$Builder
public "setKindValue"(arg0: integer): $Field$Builder
public "getOneofIndex"(): integer
public "getPacked"(): boolean
public "getTypeUrl"(): string
public "setTypeUrl"(arg0: string): $Field$Builder
public "clearTypeUrl"(): $Field$Builder
public "getTypeUrlBytes"(): $ByteString
public "setTypeUrlBytes"(arg0: $ByteString$Type): $Field$Builder
public "setDefaultValueBytes"(arg0: $ByteString$Type): $Field$Builder
public "getDefaultValueBytes"(): $ByteString
public "setCardinalityValue"(arg0: integer): $Field$Builder
public "getCardinalityValue"(): integer
get "name"(): string
set "name"(value: string)
get "defaultValue"(): string
get "number"(): integer
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
set "number"(value: integer)
set "defaultValue"(value: string)
set "kind"(value: $Field$Kind$Type)
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "kind"(): $Field$Kind
get "cardinality"(): $Field$Cardinality
get "jsonName"(): string
set "packed"(value: boolean)
get "jsonNameBytes"(): $ByteString
set "oneofIndex"(value: integer)
set "cardinality"(value: $Field$Cardinality$Type)
set "jsonNameBytes"(value: $ByteString$Type)
get "kindValue"(): integer
set "jsonName"(value: string)
set "kindValue"(value: integer)
get "oneofIndex"(): integer
get "packed"(): boolean
get "typeUrl"(): string
set "typeUrl"(value: string)
get "typeUrlBytes"(): $ByteString
set "typeUrlBytes"(value: $ByteString$Type)
set "defaultValueBytes"(value: $ByteString$Type)
get "defaultValueBytes"(): $ByteString
set "cardinalityValue"(value: integer)
get "cardinalityValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Field$Builder$Type = ($Field$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Field$Builder_ = $Field$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/tick/$TickMonitor" {
import {$TickHook$Callback, $TickHook$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickHook$Callback"
import {$GarbageCollectionMonitor$Listener, $GarbageCollectionMonitor$Listener$Type} from "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectionMonitor$Listener"
import {$ReportPredicate, $ReportPredicate$Type} from "packages/me/lucko/spark/common/monitor/tick/$ReportPredicate"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$GarbageCollectionNotificationInfo, $GarbageCollectionNotificationInfo$Type} from "packages/com/sun/management/$GarbageCollectionNotificationInfo"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"

export class $TickMonitor implements $TickHook$Callback, $GarbageCollectionMonitor$Listener, $AutoCloseable {

constructor(arg0: $SparkPlatform$Type, arg1: $TickHook$Type, arg2: $ReportPredicate$Type, arg3: boolean)

public "start"(): void
public "close"(): void
public "onGc"(arg0: $GarbageCollectionNotificationInfo$Type): void
public "getCurrentTick"(): integer
public "onTick"(arg0: integer): void
get "currentTick"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickMonitor$Type = ($TickMonitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickMonitor_ = $TickMonitor$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$TextColorWrapper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TextColorWrapper {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextColorWrapper$Type = ($TextColorWrapper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextColorWrapper_ = $TextColorWrapper$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $PlayerPingProvider {

 "poll"(): $Map<(string), (integer)>

(): $Map<(string), (integer)>
}

export namespace $PlayerPingProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlayerPingProvider$Type = ($PlayerPingProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlayerPingProvider_ = $PlayerPingProvider$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$StackTraceNode" {
import {$ProtoTimeEncoder, $ProtoTimeEncoder$Type} from "packages/me/lucko/spark/common/sampler/window/$ProtoTimeEncoder"
import {$MergeMode, $MergeMode$Type} from "packages/me/lucko/spark/common/sampler/node/$MergeMode"
import {$AbstractNode, $AbstractNode$Type} from "packages/me/lucko/spark/common/sampler/node/$AbstractNode"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$StackTraceNode$Description, $StackTraceNode$Description$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode$Description"
import {$SparkSamplerProtos$StackTraceNode, $SparkSamplerProtos$StackTraceNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode"

export class $StackTraceNode extends $AbstractNode {
static readonly "NULL_LINE_NUMBER": integer

constructor(arg0: $StackTraceNode$Description$Type)

public "getLineNumber"(): integer
public "getClassName"(): string
public "getMethodName"(): string
public "toProto"(arg0: $MergeMode$Type, arg1: $ProtoTimeEncoder$Type, arg2: $Iterable$Type<(integer)>): $SparkSamplerProtos$StackTraceNode
public "getMethodDescription"(): string
public "getParentLineNumber"(): integer
get "lineNumber"(): integer
get "className"(): string
get "methodName"(): string
get "methodDescription"(): string
get "parentLineNumber"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackTraceNode$Type = ($StackTraceNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackTraceNode_ = $StackTraceNode$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializerImpl" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$LegacyComponentSerializer, $LegacyComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LegacyComponentSerializer$Builder, $LegacyComponentSerializer$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer$Builder"
import {$LegacyFormat, $LegacyFormat$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyFormat"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $LegacyComponentSerializerImpl implements $LegacyComponentSerializer {


public "deserialize"(input: string): $TextComponent
public "serialize"(component: $Component$Type): string
public "toBuilder"(): $LegacyComponentSerializer$Builder
public static "builder"(): $LegacyComponentSerializer$Builder
public static "legacy"(legacyCharacter: character): $LegacyComponentSerializer
public static "parseChar"(character: character): $LegacyFormat
public static "legacySection"(): $LegacyComponentSerializer
public static "legacyAmpersand"(): $LegacyComponentSerializer
public "deserializeOrNull"(input: string): $TextComponent
public "serializeOr"(component: $Component$Type, fallback: string): string
public "serializeOrNull"(component: $Component$Type): string
/**
 * 
 * @deprecated
 */
public "deseializeOrNull"(input: string): $TextComponent
public "deserializeOr"(input: string, fallback: $TextComponent$Type): $TextComponent
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $LegacyComponentSerializer$Builder$Type, consumer: $Consumer$Type<(any)>): $LegacyComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyComponentSerializerImpl$Type = ($LegacyComponentSerializerImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyComponentSerializerImpl_ = $LegacyComponentSerializerImpl$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$TickCounter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $WindowStatisticsCollector$TickCounter {

 "getCountedTicksThisWindowAndReset"(): integer
 "stop"(): void
 "getTotalTicks"(): integer
}

export namespace $WindowStatisticsCollector$TickCounter {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowStatisticsCollector$TickCounter$Type = ($WindowStatisticsCollector$TickCounter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowStatisticsCollector$TickCounter_ = $WindowStatisticsCollector$TickCounter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics" {
import {$SparkProtos$PlatformStatistics$Mspt, $SparkProtos$PlatformStatistics$Mspt$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt"
import {$SparkProtos$PlatformStatistics$Gc, $SparkProtos$PlatformStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc"
import {$SparkProtos$PlatformStatistics$Memory, $SparkProtos$PlatformStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$SparkProtos$PlatformStatistics$Ping, $SparkProtos$PlatformStatistics$Ping$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$PlatformStatistics$Tps, $SparkProtos$PlatformStatistics$Tps$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps"
import {$SparkProtos$PlatformStatisticsOrBuilder, $SparkProtos$PlatformStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatisticsOrBuilder"
import {$SparkProtos$WorldStatistics, $SparkProtos$WorldStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$PlatformStatistics$Builder, $SparkProtos$PlatformStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$PlatformStatistics extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics), ($SparkProtos$PlatformStatistics$Builder)> implements $SparkProtos$PlatformStatisticsOrBuilder {
static readonly "MEMORY_FIELD_NUMBER": integer
static readonly "GC_FIELD_NUMBER": integer
static readonly "UPTIME_FIELD_NUMBER": integer
static readonly "TPS_FIELD_NUMBER": integer
static readonly "MSPT_FIELD_NUMBER": integer
static readonly "PING_FIELD_NUMBER": integer
static readonly "PLAYER_COUNT_FIELD_NUMBER": integer
static readonly "WORLD_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics)>
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkProtos$PlatformStatistics$Builder
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public "getTps"(): $SparkProtos$PlatformStatistics$Tps
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics
public "getUptime"(): long
public "getWorld"(): $SparkProtos$WorldStatistics
public "getMemory"(): $SparkProtos$PlatformStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics
public "hasTps"(): boolean
public "getGcOrDefault"(arg0: string, arg1: $SparkProtos$PlatformStatistics$Gc$Type): $SparkProtos$PlatformStatistics$Gc
public "hasMemory"(): boolean
public "getGcCount"(): integer
public "getGcMap"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
public "hasMspt"(): boolean
public "getMspt"(): $SparkProtos$PlatformStatistics$Mspt
public "hasPing"(): boolean
public "getPing"(): $SparkProtos$PlatformStatistics$Ping
/**
 * 
 * @deprecated
 */
public "getGc"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
public "getGcOrThrow"(arg0: string): $SparkProtos$PlatformStatistics$Gc
public "containsGc"(arg0: string): boolean
public "getPlayerCount"(): long
public "hasWorld"(): boolean
get "tps"(): $SparkProtos$PlatformStatistics$Tps
get "defaultInstance"(): $SparkProtos$PlatformStatistics
get "uptime"(): long
get "world"(): $SparkProtos$WorldStatistics
get "memory"(): $SparkProtos$PlatformStatistics$Memory
get "gcCount"(): integer
get "gcMap"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
get "mspt"(): $SparkProtos$PlatformStatistics$Mspt
get "ping"(): $SparkProtos$PlatformStatistics$Ping
get "gc"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
get "playerCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Type = ($SparkProtos$PlatformStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics_ = $SparkProtos$PlatformStatistics$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/java/$JavaSampler" {
import {$SamplerSettings, $SamplerSettings$Type} from "packages/me/lucko/spark/common/sampler/$SamplerSettings"
import {$ViewerSocket, $ViewerSocket$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocket"
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$AbstractSampler, $AbstractSampler$Type} from "packages/me/lucko/spark/common/sampler/$AbstractSampler"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$Sampler$ExportProps, $Sampler$ExportProps$Type} from "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps"
import {$SparkSamplerProtos$SamplerData, $SparkSamplerProtos$SamplerData$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $JavaSampler extends $AbstractSampler implements $Runnable {

constructor(arg0: $SparkPlatform$Type, arg1: $SamplerSettings$Type, arg2: boolean, arg3: boolean)
constructor(arg0: $SparkPlatform$Type, arg1: $SamplerSettings$Type, arg2: boolean, arg3: boolean, arg4: $TickHook$Type, arg5: integer)

public "run"(): void
public "start"(): void
public "stop"(arg0: boolean): void
public "toProto"(arg0: $SparkPlatform$Type, arg1: $Sampler$ExportProps$Type): $SparkSamplerProtos$SamplerData
public "attachSocket"(arg0: $ViewerSocket$Type): void
public "getMode"(): $SamplerMode
get "mode"(): $SamplerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JavaSampler$Type = ($JavaSampler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JavaSampler_ = $JavaSampler$Type;
}}
declare module "packages/me/lucko/spark/common/command/$CommandModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"

export interface $CommandModule extends $AutoCloseable {

 "close"(): void
 "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void

(): void
}

export namespace $CommandModule {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandModule$Type = ($CommandModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandModule_ = $CommandModule$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CompileTimeConstant" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $CompileTimeConstant extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $CompileTimeConstant {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompileTimeConstant$Type = ($CompileTimeConstant);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompileTimeConstant_ = $CompileTimeConstant$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Services" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"

export class $Services {


public static "service"<P>(type: $Class$Type<(P)>): $Optional<(P)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Services$Type = ($Services);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Services_ = $Services$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$MethodTooLargeException" {
import {$IndexOutOfBoundsException, $IndexOutOfBoundsException$Type} from "packages/java/lang/$IndexOutOfBoundsException"

export class $MethodTooLargeException extends $IndexOutOfBoundsException {

constructor(arg0: string, arg1: string, arg2: string, arg3: integer)

public "getDescriptor"(): string
public "getClassName"(): string
public "getMethodName"(): string
public "getCodeSize"(): integer
get "descriptor"(): string
get "className"(): string
get "methodName"(): string
get "codeSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodTooLargeException$Type = ($MethodTooLargeException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodTooLargeException_ = $MethodTooLargeException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DurationProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $DurationProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DurationProto$Type = ($DurationProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DurationProto_ = $DurationProto$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/inventory/$Book" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Book$Builder, $Book$Builder$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $Book extends $Buildable<($Book), ($Book$Builder)>, $Examinable {

 "title"(title: $Component$Type): $Book
 "title"(): $Component
 "toBuilder"(): $Book$Builder
 "pages"(pages: $List$Type<($Component$Type)>): $Book
 "pages"(...pages: ($Component$Type)[]): $Book
 "pages"(): $List<($Component)>
 "author"(): $Component
 "author"(author: $Component$Type): $Book
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $Book {
function builder(): $Book$Builder
function book(title: $Component$Type, author: $Component$Type, pages: $Collection$Type<($Component$Type)>): $Book
function book(title: $Component$Type, author: $Component$Type, ...pages: ($Component$Type)[]): $Book
function configureAndBuild<R, B>(builder: $Book$Builder$Type, consumer: $Consumer$Type<(any)>): $Book
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Book$Type = ($Book);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Book_ = $Book$Type;
}}
declare module "packages/me/lucko/spark/common/platform/serverconfig/$ExcludedConfigFilter" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $ExcludedConfigFilter {

constructor(arg0: $Collection$Type<(string)>)

public "apply"(arg0: $JsonElement$Type): $JsonElement
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExcludedConfigFilter$Type = ($ExcludedConfigFilter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExcludedConfigFilter_ = $ExcludedConfigFilter$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StructOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StructOrBuilder extends $MessageLiteOrBuilder {

 "getFieldsOrDefault"(arg0: string, arg1: $Value$Type): $Value
 "containsFields"(arg0: string): boolean
 "getFieldsOrThrow"(arg0: string): $Value
 "getFieldsCount"(): integer
 "getFieldsMap"(): $Map<(string), ($Value)>
/**
 * 
 * @deprecated
 */
 "getFields"(): $Map<(string), ($Value)>
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $StructOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructOrBuilder$Type = ($StructOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructOrBuilder_ = $StructOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNodeOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkSamplerProtos$StackTraceNode, $SparkSamplerProtos$StackTraceNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode"

export interface $SparkSamplerProtos$ThreadNodeOrBuilder extends $MessageLiteOrBuilder {

 "getTimesList"(): $List<(double)>
 "getChildrenList"(): $List<($SparkSamplerProtos$StackTraceNode)>
 "getChildrenRefs"(arg0: integer): integer
 "getTimesCount"(): integer
 "getName"(): string
 "getChildren"(arg0: integer): $SparkSamplerProtos$StackTraceNode
 "getTimes"(arg0: integer): double
 "getNameBytes"(): $ByteString
 "getChildrenCount"(): integer
 "getChildrenRefsList"(): $List<(integer)>
 "getChildrenRefsCount"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$ThreadNodeOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$ThreadNodeOrBuilder$Type = ($SparkSamplerProtos$ThreadNodeOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$ThreadNodeOrBuilder_ = $SparkSamplerProtos$ThreadNodeOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool$Builder, $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder, $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Memory$MemoryPool extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Memory$MemoryPool), ($SparkProtos$SystemStatistics$Memory$MemoryPool$Builder)> implements $SparkProtos$SystemStatistics$Memory$MemoryPoolOrBuilder {
static readonly "USED_FIELD_NUMBER": integer
static readonly "TOTAL_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Memory$MemoryPool)>
public static "newBuilder"(): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
public "getTotal"(): long
public "getUsed"(): long
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Memory$MemoryPool
get "defaultInstance"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
get "total"(): long
get "used"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Memory$MemoryPool$Type = ($SparkProtos$SystemStatistics$Memory$MemoryPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Memory$MemoryPool_ = $SparkProtos$SystemStatistics$Memory$MemoryPool$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$DataFrame" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$FramedataImpl1, $FramedataImpl1$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$FramedataImpl1"

export class $DataFrame extends $FramedataImpl1 {

constructor(arg0: $Opcode$Type)

public "isValid"(): void
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DataFrame$Type = ($DataFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DataFrame_ = $DataFrame$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent$Action" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ClickEvent$Action extends $Enum<($ClickEvent$Action)> {
static readonly "OPEN_URL": $ClickEvent$Action
static readonly "OPEN_FILE": $ClickEvent$Action
static readonly "RUN_COMMAND": $ClickEvent$Action
static readonly "SUGGEST_COMMAND": $ClickEvent$Action
static readonly "CHANGE_PAGE": $ClickEvent$Action
static readonly "COPY_TO_CLIPBOARD": $ClickEvent$Action
static readonly "NAMES": $Index<(string), ($ClickEvent$Action)>


public "toString"(): string
public static "values"(): ($ClickEvent$Action)[]
public static "valueOf"(name: string): $ClickEvent$Action
public "readable"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClickEvent$Action$Type = (("run_command") | ("open_file") | ("open_url") | ("copy_to_clipboard") | ("change_page") | ("suggest_command")) | ($ClickEvent$Action);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClickEvent$Action_ = $ClickEvent$Action$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteString" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$ByteString$Output, $ByteString$Output$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString$Output"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Charset, $Charset$Type} from "packages/java/nio/charset/$Charset"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ByteString$ByteIterator, $ByteString$ByteIterator$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString$ByteIterator"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $ByteString implements $Iterable<(byte)>, $Serializable {
static readonly "EMPTY": $ByteString


public "equals"(arg0: any): boolean
public "toString"(): string
public "toString"(arg0: string): string
public "toString"(arg0: $Charset$Type): string
public "hashCode"(): integer
public "startsWith"(arg0: $ByteString$Type): boolean
public "substring"(arg0: integer): $ByteString
public "substring"(arg0: integer, arg1: integer): $ByteString
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $ByteString$ByteIterator
public "endsWith"(arg0: $ByteString$Type): boolean
public "concat"(arg0: $ByteString$Type): $ByteString
public static "empty"(): $ByteString
public "toByteArray"(): (byte)[]
public "writeTo"(arg0: $OutputStream$Type): void
public static "readFrom"(arg0: $InputStream$Type, arg1: integer): $ByteString
public static "readFrom"(arg0: $InputStream$Type, arg1: integer, arg2: integer): $ByteString
public static "readFrom"(arg0: $InputStream$Type): $ByteString
public static "copyFrom"(arg0: (byte)[], arg1: integer, arg2: integer): $ByteString
public static "copyFrom"(arg0: string, arg1: string): $ByteString
public static "copyFrom"(arg0: $ByteBuffer$Type): $ByteString
public static "copyFrom"(arg0: $ByteBuffer$Type, arg1: integer): $ByteString
public static "copyFrom"(arg0: string, arg1: $Charset$Type): $ByteString
public static "copyFrom"(arg0: $Iterable$Type<($ByteString$Type)>): $ByteString
public static "copyFrom"(arg0: (byte)[]): $ByteString
public "newCodedInput"(): $CodedInputStream
public "toStringUtf8"(): string
public "isValidUtf8"(): boolean
public static "fromHex"(arg0: string): $ByteString
/**
 * 
 * @deprecated
 */
public "copyTo"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): void
public "copyTo"(arg0: $ByteBuffer$Type): void
public "copyTo"(arg0: (byte)[], arg1: integer): void
public "byteAt"(arg0: integer): byte
public static "unsignedLexicographicalComparator"(): $Comparator<($ByteString)>
public "asReadOnlyByteBufferList"(): $List<($ByteBuffer)>
public "asReadOnlyByteBuffer"(): $ByteBuffer
public static "copyFromUtf8"(arg0: string): $ByteString
public "newInput"(): $InputStream
public static "newOutput"(arg0: integer): $ByteString$Output
public static "newOutput"(): $ByteString$Output
public "spliterator"(): $Spliterator<(byte)>
public "forEach"(arg0: $Consumer$Type<(any)>): void
get "validUtf8"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteString$Type = ($ByteString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteString_ = $ByteString$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Builder" {
import {$SparkWebSocketProtos$ServerConnectResponse$Settings$Builder, $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ServerConnectResponse$Settings, $SparkWebSocketProtos$ServerConnectResponse$Settings$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings"
import {$SparkWebSocketProtos$ServerConnectResponse, $SparkWebSocketProtos$ServerConnectResponse$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse"
import {$SparkWebSocketProtos$ServerConnectResponseOrBuilder, $SparkWebSocketProtos$ServerConnectResponseOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponseOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkWebSocketProtos$ServerConnectResponse$State, $SparkWebSocketProtos$ServerConnectResponse$State$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$State"

export class $SparkWebSocketProtos$ServerConnectResponse$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ServerConnectResponse), ($SparkWebSocketProtos$ServerConnectResponse$Builder)> implements $SparkWebSocketProtos$ServerConnectResponseOrBuilder {


public "getState"(): $SparkWebSocketProtos$ServerConnectResponse$State
public "setState"(arg0: $SparkWebSocketProtos$ServerConnectResponse$State$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "clearState"(): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "getClientId"(): string
public "setLastPayloadId"(arg0: string): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "setClientId"(arg0: string): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "setSettings"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Settings$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "setSettings"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "getSettings"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
public "clearClientId"(): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "setClientIdBytes"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "getClientIdBytes"(): $ByteString
public "setStateValue"(arg0: integer): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "hasSettings"(): boolean
public "getStateValue"(): integer
public "clearLastPayloadId"(): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "getLastPayloadId"(): string
public "clearSettings"(): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "mergeSettings"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Settings$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
public "getLastPayloadIdBytes"(): $ByteString
public "setLastPayloadIdBytes"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerConnectResponse$Builder
get "state"(): $SparkWebSocketProtos$ServerConnectResponse$State
set "state"(value: $SparkWebSocketProtos$ServerConnectResponse$State$Type)
get "clientId"(): string
set "lastPayloadId"(value: string)
set "clientId"(value: string)
set "settings"(value: $SparkWebSocketProtos$ServerConnectResponse$Settings$Type)
set "settings"(value: $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type)
get "settings"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
set "clientIdBytes"(value: $ByteString$Type)
get "clientIdBytes"(): $ByteString
set "stateValue"(value: integer)
get "stateValue"(): integer
get "lastPayloadId"(): string
get "lastPayloadIdBytes"(): $ByteString
set "lastPayloadIdBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$Builder$Type = ($SparkWebSocketProtos$ServerConnectResponse$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse$Builder_ = $SparkWebSocketProtos$ServerConnectResponse$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/cpu/$CpuMonitor" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $CpuMonitor extends $Enum<($CpuMonitor)> {


public static "values"(): ($CpuMonitor)[]
public static "valueOf"(arg0: string): $CpuMonitor
public static "ensureMonitoring"(): void
public static "systemLoad10SecAvg"(): double
public static "systemLoad1MinAvg"(): double
public static "systemLoad15MinAvg"(): double
public static "processLoad1MinAvg"(): double
public static "processLoad15MinAvg"(): double
public static "processLoad10SecAvg"(): double
public static "processLoad"(): double
public static "systemLoad"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CpuMonitor$Type = (never) | ($CpuMonitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CpuMonitor_ = $CpuMonitor$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Field" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Field$Cardinality, $Field$Cardinality$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Cardinality"
import {$FieldOrBuilder, $FieldOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Field$Kind, $Field$Kind$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Kind"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Field$Builder, $Field$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Builder"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Field extends $GeneratedMessageLite<($Field), ($Field$Builder)> implements $FieldOrBuilder {
static readonly "KIND_FIELD_NUMBER": integer
static readonly "CARDINALITY_FIELD_NUMBER": integer
static readonly "NUMBER_FIELD_NUMBER": integer
static readonly "NAME_FIELD_NUMBER": integer
static readonly "TYPE_URL_FIELD_NUMBER": integer
static readonly "ONEOF_INDEX_FIELD_NUMBER": integer
static readonly "PACKED_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer
static readonly "JSON_NAME_FIELD_NUMBER": integer
static readonly "DEFAULT_VALUE_FIELD_NUMBER": integer


public "getName"(): string
public "getDefaultValue"(): string
public "getNumber"(): integer
public static "parser"(): $Parser<($Field)>
public static "newBuilder"(): $Field$Builder
public static "newBuilder"(arg0: $Field$Type): $Field$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Field
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Field
public static "getDefaultInstance"(): $Field
public "getOptions"(arg0: integer): $Option
public "getNameBytes"(): $ByteString
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public static "parseFrom"(arg0: (byte)[]): $Field
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Field
public static "parseFrom"(arg0: $ByteString$Type): $Field
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Field
public static "parseFrom"(arg0: $ByteBuffer$Type): $Field
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Field
public static "parseFrom"(arg0: $CodedInputStream$Type): $Field
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Field
public static "parseFrom"(arg0: $InputStream$Type): $Field
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Field
public "getKind"(): $Field$Kind
public "getCardinality"(): $Field$Cardinality
public "getJsonName"(): string
public "getJsonNameBytes"(): $ByteString
public "getKindValue"(): integer
public "getOneofIndex"(): integer
public "getPacked"(): boolean
public "getTypeUrl"(): string
public "getTypeUrlBytes"(): $ByteString
public "getDefaultValueBytes"(): $ByteString
public "getCardinalityValue"(): integer
get "name"(): string
get "defaultValue"(): string
get "number"(): integer
get "defaultInstance"(): $Field
get "nameBytes"(): $ByteString
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "optionsOrBuilderList"(): $List<(any)>
get "kind"(): $Field$Kind
get "cardinality"(): $Field$Cardinality
get "jsonName"(): string
get "jsonNameBytes"(): $ByteString
get "kindValue"(): integer
get "oneofIndex"(): integer
get "packed"(): boolean
get "typeUrl"(): string
get "typeUrlBytes"(): $ByteString
get "defaultValueBytes"(): $ByteString
get "cardinalityValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Field$Type = ($Field);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Field_ = $Field$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$Protocol" {
import {$IProtocol, $IProtocol$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol"

export class $Protocol implements $IProtocol {

constructor(arg0: string)

public "acceptProvidedProtocol"(arg0: string): boolean
public "getProvidedProtocol"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "copyInstance"(): $IProtocol
get "providedProtocol"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Protocol$Type = ($Protocol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Protocol_ = $Protocol$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$SimpleTickReporter" {
import {$AbstractTickReporter, $AbstractTickReporter$Type} from "packages/me/lucko/spark/common/tick/$AbstractTickReporter"

export class $SimpleTickReporter extends $AbstractTickReporter {

constructor()

public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SimpleTickReporter$Type = ($SimpleTickReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SimpleTickReporter_ = $SimpleTickReporter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$PlatformStatistics$Gc$Builder, $SparkProtos$PlatformStatistics$Gc$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkProtos$PlatformStatistics$GcOrBuilder, $SparkProtos$PlatformStatistics$GcOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$GcOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$PlatformStatistics$Gc extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Gc), ($SparkProtos$PlatformStatistics$Gc$Builder)> implements $SparkProtos$PlatformStatistics$GcOrBuilder {
static readonly "TOTAL_FIELD_NUMBER": integer
static readonly "AVG_TIME_FIELD_NUMBER": integer
static readonly "AVG_FREQUENCY_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Gc)>
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Gc$Builder
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Gc$Type): $SparkProtos$PlatformStatistics$Gc$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Gc
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Gc
public "getTotal"(): long
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Gc
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Gc
public "getAvgFrequency"(): double
public "getAvgTime"(): double
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Gc
get "total"(): long
get "avgFrequency"(): double
get "avgTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Gc$Type = ($SparkProtos$PlatformStatistics$Gc);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Gc_ = $SparkProtos$PlatformStatistics$Gc$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldOrBuilder" {
import {$Field$Cardinality, $Field$Cardinality$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Cardinality"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Field$Kind, $Field$Kind$Type} from "packages/me/lucko/spark/lib/protobuf/$Field$Kind"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $FieldOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getDefaultValue"(): string
 "getNumber"(): integer
 "getOptions"(arg0: integer): $Option
 "getNameBytes"(): $ByteString
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "getKind"(): $Field$Kind
 "getCardinality"(): $Field$Cardinality
 "getJsonName"(): string
 "getJsonNameBytes"(): $ByteString
 "getKindValue"(): integer
 "getOneofIndex"(): integer
 "getPacked"(): boolean
 "getTypeUrl"(): string
 "getTypeUrlBytes"(): $ByteString
 "getDefaultValueBytes"(): $ByteString
 "getCardinalityValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $FieldOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldOrBuilder$Type = ($FieldOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldOrBuilder_ = $FieldOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap" {
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export interface $Internal$EnumLiteMap<T extends $Internal$EnumLite> {

 "findValueByNumber"(arg0: integer): T

(arg0: integer): T
}

export namespace $Internal$EnumLiteMap {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$EnumLiteMap$Type<T> = ($Internal$EnumLiteMap<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$EnumLiteMap_<T> = $Internal$EnumLiteMap$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentApplicable" {
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentApplicable {

 "componentApply"(component: $Component$Type): $Component

(component: $Component$Type): $Component
}

export namespace $ComponentApplicable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentApplicable$Type = ($ComponentApplicable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentApplicable_ = $ComponentApplicable$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing" {
import {$SparkWebSocketProtos$ClientPing$Builder, $SparkWebSocketProtos$ClientPing$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkWebSocketProtos$ClientPingOrBuilder, $SparkWebSocketProtos$ClientPingOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPingOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkWebSocketProtos$ClientPing extends $GeneratedMessageLite<($SparkWebSocketProtos$ClientPing), ($SparkWebSocketProtos$ClientPing$Builder)> implements $SparkWebSocketProtos$ClientPingOrBuilder {
static readonly "OK_FIELD_NUMBER": integer
static readonly "DATA_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ClientPing)>
public "getData"(): integer
public static "newBuilder"(arg0: $SparkWebSocketProtos$ClientPing$Type): $SparkWebSocketProtos$ClientPing$Builder
public static "newBuilder"(): $SparkWebSocketProtos$ClientPing$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ClientPing
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "getDefaultInstance"(): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ClientPing
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ClientPing
public "getOk"(): boolean
get "data"(): integer
get "defaultInstance"(): $SparkWebSocketProtos$ClientPing
get "ok"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientPing$Type = ($SparkWebSocketProtos$ClientPing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientPing_ = $SparkWebSocketProtos$ClientPing$Type;
}}
declare module "packages/me/lucko/spark/common/platform/serverconfig/$PropertiesConfigParser" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$ExcludedConfigFilter, $ExcludedConfigFilter$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ExcludedConfigFilter"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$BufferedReader, $BufferedReader$Type} from "packages/java/io/$BufferedReader"
import {$ConfigParser, $ConfigParser$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ConfigParser"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $PropertiesConfigParser extends $Enum<($PropertiesConfigParser)> implements $ConfigParser {
static readonly "INSTANCE": $PropertiesConfigParser


public static "values"(): ($PropertiesConfigParser)[]
public "load"(arg0: string, arg1: $ExcludedConfigFilter$Type): $JsonElement
public static "valueOf"(arg0: string): $PropertiesConfigParser
public "parse"(arg0: $BufferedReader$Type): $Map<(string), (any)>
public "parse"(arg0: $Path$Type): $Map<(string), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PropertiesConfigParser$Type = (("instance")) | ($PropertiesConfigParser);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PropertiesConfigParser_ = $PropertiesConfigParser$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$WebSocketServer" {
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$WebSocketServerFactory, $WebSocketServerFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketServerFactory"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketFactory, $WebSocketFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketFactory"
import {$AbstractWebSocket, $AbstractWebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$AbstractWebSocket"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketServer extends $AbstractWebSocket implements $Runnable {

constructor(arg0: $InetSocketAddress$Type, arg1: integer, arg2: $List$Type<($Draft$Type)>, arg3: $Collection$Type<($WebSocket$Type)>)
constructor(arg0: $InetSocketAddress$Type, arg1: integer, arg2: $List$Type<($Draft$Type)>)
constructor(arg0: $InetSocketAddress$Type, arg1: $List$Type<($Draft$Type)>)
constructor()
constructor(arg0: $InetSocketAddress$Type)
constructor(arg0: $InetSocketAddress$Type, arg1: integer)

public "run"(): void
public "start"(): void
public "stop"(arg0: integer): void
public "stop"(arg0: integer, arg1: string): void
public "stop"(): void
public "getAddress"(): $InetSocketAddress
public "getPort"(): integer
public "broadcast"(arg0: $ByteBuffer$Type): void
public "broadcast"(arg0: (byte)[], arg1: $Collection$Type<($WebSocket$Type)>): void
public "broadcast"(arg0: $ByteBuffer$Type, arg1: $Collection$Type<($WebSocket$Type)>): void
public "broadcast"(arg0: (byte)[]): void
public "broadcast"(arg0: string): void
public "broadcast"(arg0: string, arg1: $Collection$Type<($WebSocket$Type)>): void
public "onClose"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "onStart"(): void
public "createBuffer"(): $ByteBuffer
public "getRemoteSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "getLocalSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "getConnections"(): $Collection<($WebSocket)>
public "onMessage"(arg0: $WebSocket$Type, arg1: $ByteBuffer$Type): void
public "onMessage"(arg0: $WebSocket$Type, arg1: string): void
public "onOpen"(arg0: $WebSocket$Type, arg1: $ClientHandshake$Type): void
public "onWebsocketCloseInitiated"(arg0: $WebSocket$Type, arg1: integer, arg2: string): void
public "onError"(arg0: $WebSocket$Type, arg1: $Exception$Type): void
public "onWebsocketClose"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "onWebsocketError"(arg0: $WebSocket$Type, arg1: $Exception$Type): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: string): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: $ByteBuffer$Type): void
public "onWriteDemand"(arg0: $WebSocket$Type): void
public "onWebsocketOpen"(arg0: $WebSocket$Type, arg1: $Handshakedata$Type): void
public "onWebsocketClosing"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "getDraft"(): $List<($Draft)>
public "onClosing"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "onCloseInitiated"(arg0: $WebSocket$Type, arg1: integer, arg2: string): void
public "setMaxPendingConnections"(arg0: integer): void
public "getMaxPendingConnections"(): integer
public "getWebSocketFactory"(): $WebSocketFactory
public "setWebSocketFactory"(arg0: $WebSocketServerFactory$Type): void
get "address"(): $InetSocketAddress
get "port"(): integer
get "connections"(): $Collection<($WebSocket)>
get "draft"(): $List<($Draft)>
set "maxPendingConnections"(value: integer)
get "maxPendingConnections"(): integer
get "webSocketFactory"(): $WebSocketFactory
set "webSocketFactory"(value: $WebSocketServerFactory$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServer$Type = ($WebSocketServer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServer_ = $WebSocketServer$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$Installer" {
import {$Instrumentation, $Instrumentation$Type} from "packages/java/lang/instrument/$Instrumentation"

export class $Installer {


public static "getInstrumentation"(): $Instrumentation
public static "agentmain"(arg0: string, arg1: $Instrumentation$Type): void
public static "premain"(arg0: string, arg1: $Instrumentation$Type): void
get "instrumentation"(): $Instrumentation
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Installer$Type = ($Installer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Installer_ = $Installer$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$GlobalTranslatorImpl" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$MessageFormat, $MessageFormat$Type} from "packages/java/text/$MessageFormat"
import {$GlobalTranslator, $GlobalTranslator$Type} from "packages/me/lucko/spark/lib/adventure/translation/$GlobalTranslator"
import {$Translator, $Translator$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$TranslatableComponentRenderer, $TranslatableComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$TranslatableComponentRenderer"

export class $GlobalTranslatorImpl implements $GlobalTranslator {


public "name"(): $Key
public "sources"(): $Iterable<(any)>
public "addSource"(source: $Translator$Type): boolean
public "examinableProperties"(): $Stream<(any)>
public "translate"(key: string, locale: $Locale$Type): $MessageFormat
public "removeSource"(source: $Translator$Type): boolean
/**
 * 
 * @deprecated
 */
public static "get"(): $GlobalTranslator
public static "render"(component: $Component$Type, locale: $Locale$Type): $Component
public static "renderer"(): $TranslatableComponentRenderer<($Locale)>
public static "translator"(): $GlobalTranslator
public static "parseLocale"(string: string): $Locale
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GlobalTranslatorImpl$Type = ($GlobalTranslatorImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GlobalTranslatorImpl_ = $GlobalTranslatorImpl$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$TickHook$Callback" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $TickHook$Callback {

 "onTick"(arg0: integer): void

(arg0: integer): void
}

export namespace $TickHook$Callback {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickHook$Callback$Type = ($TickHook$Callback);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickHook$Callback_ = $TickHook$Callback$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Builder" {
import {$SparkProtos$PlatformStatistics$Mspt, $SparkProtos$PlatformStatistics$Mspt$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt"
import {$SparkProtos$PlatformStatistics$Gc, $SparkProtos$PlatformStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc"
import {$SparkProtos$PlatformStatistics$Memory, $SparkProtos$PlatformStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformStatistics$Mspt$Builder, $SparkProtos$PlatformStatistics$Mspt$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt$Builder"
import {$SparkProtos$PlatformStatistics$Ping, $SparkProtos$PlatformStatistics$Ping$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkProtos$PlatformStatistics$Tps, $SparkProtos$PlatformStatistics$Tps$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps"
import {$SparkProtos$PlatformStatistics$Ping$Builder, $SparkProtos$PlatformStatistics$Ping$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping$Builder"
import {$SparkProtos$PlatformStatisticsOrBuilder, $SparkProtos$PlatformStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatisticsOrBuilder"
import {$SparkProtos$WorldStatistics, $SparkProtos$WorldStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics"
import {$SparkProtos$WorldStatistics$Builder, $SparkProtos$WorldStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Builder"
import {$SparkProtos$PlatformStatistics$Tps$Builder, $SparkProtos$PlatformStatistics$Tps$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps$Builder"
import {$SparkProtos$PlatformStatistics$Memory$Builder, $SparkProtos$PlatformStatistics$Memory$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$PlatformStatistics$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics), ($SparkProtos$PlatformStatistics$Builder)> implements $SparkProtos$PlatformStatisticsOrBuilder {


public "setMemory"(arg0: $SparkProtos$PlatformStatistics$Memory$Builder$Type): $SparkProtos$PlatformStatistics$Builder
public "setMemory"(arg0: $SparkProtos$PlatformStatistics$Memory$Type): $SparkProtos$PlatformStatistics$Builder
public "clearTps"(): $SparkProtos$PlatformStatistics$Builder
public "getTps"(): $SparkProtos$PlatformStatistics$Tps
public "getUptime"(): long
public "getWorld"(): $SparkProtos$WorldStatistics
public "setWorld"(arg0: $SparkProtos$WorldStatistics$Builder$Type): $SparkProtos$PlatformStatistics$Builder
public "setWorld"(arg0: $SparkProtos$WorldStatistics$Type): $SparkProtos$PlatformStatistics$Builder
public "getMemory"(): $SparkProtos$PlatformStatistics$Memory
public "setUptime"(arg0: long): $SparkProtos$PlatformStatistics$Builder
public "setTps"(arg0: $SparkProtos$PlatformStatistics$Tps$Builder$Type): $SparkProtos$PlatformStatistics$Builder
public "setTps"(arg0: $SparkProtos$PlatformStatistics$Tps$Type): $SparkProtos$PlatformStatistics$Builder
public "setMspt"(arg0: $SparkProtos$PlatformStatistics$Mspt$Builder$Type): $SparkProtos$PlatformStatistics$Builder
public "setMspt"(arg0: $SparkProtos$PlatformStatistics$Mspt$Type): $SparkProtos$PlatformStatistics$Builder
public "setPlayerCount"(arg0: long): $SparkProtos$PlatformStatistics$Builder
public "setPing"(arg0: $SparkProtos$PlatformStatistics$Ping$Type): $SparkProtos$PlatformStatistics$Builder
public "setPing"(arg0: $SparkProtos$PlatformStatistics$Ping$Builder$Type): $SparkProtos$PlatformStatistics$Builder
public "putGc"(arg0: string, arg1: $SparkProtos$PlatformStatistics$Gc$Type): $SparkProtos$PlatformStatistics$Builder
public "hasTps"(): boolean
public "getGcOrDefault"(arg0: string, arg1: $SparkProtos$PlatformStatistics$Gc$Type): $SparkProtos$PlatformStatistics$Gc
public "hasMemory"(): boolean
public "clearMemory"(): $SparkProtos$PlatformStatistics$Builder
public "clearUptime"(): $SparkProtos$PlatformStatistics$Builder
public "mergeTps"(arg0: $SparkProtos$PlatformStatistics$Tps$Type): $SparkProtos$PlatformStatistics$Builder
public "getGcCount"(): integer
public "getGcMap"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
public "hasMspt"(): boolean
public "getMspt"(): $SparkProtos$PlatformStatistics$Mspt
public "mergeMspt"(arg0: $SparkProtos$PlatformStatistics$Mspt$Type): $SparkProtos$PlatformStatistics$Builder
public "mergeMemory"(arg0: $SparkProtos$PlatformStatistics$Memory$Type): $SparkProtos$PlatformStatistics$Builder
public "clearMspt"(): $SparkProtos$PlatformStatistics$Builder
public "hasPing"(): boolean
public "getPing"(): $SparkProtos$PlatformStatistics$Ping
public "mergePing"(arg0: $SparkProtos$PlatformStatistics$Ping$Type): $SparkProtos$PlatformStatistics$Builder
/**
 * 
 * @deprecated
 */
public "getGc"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
public "getGcOrThrow"(arg0: string): $SparkProtos$PlatformStatistics$Gc
public "containsGc"(arg0: string): boolean
public "clearWorld"(): $SparkProtos$PlatformStatistics$Builder
public "clearPing"(): $SparkProtos$PlatformStatistics$Builder
public "mergeWorld"(arg0: $SparkProtos$WorldStatistics$Type): $SparkProtos$PlatformStatistics$Builder
public "getPlayerCount"(): long
public "clearPlayerCount"(): $SparkProtos$PlatformStatistics$Builder
public "hasWorld"(): boolean
public "clearGc"(): $SparkProtos$PlatformStatistics$Builder
public "removeGc"(arg0: string): $SparkProtos$PlatformStatistics$Builder
public "putAllGc"(arg0: $Map$Type<(string), ($SparkProtos$PlatformStatistics$Gc$Type)>): $SparkProtos$PlatformStatistics$Builder
set "memory"(value: $SparkProtos$PlatformStatistics$Memory$Builder$Type)
set "memory"(value: $SparkProtos$PlatformStatistics$Memory$Type)
get "tps"(): $SparkProtos$PlatformStatistics$Tps
get "uptime"(): long
get "world"(): $SparkProtos$WorldStatistics
set "world"(value: $SparkProtos$WorldStatistics$Builder$Type)
set "world"(value: $SparkProtos$WorldStatistics$Type)
get "memory"(): $SparkProtos$PlatformStatistics$Memory
set "uptime"(value: long)
set "tps"(value: $SparkProtos$PlatformStatistics$Tps$Builder$Type)
set "tps"(value: $SparkProtos$PlatformStatistics$Tps$Type)
set "mspt"(value: $SparkProtos$PlatformStatistics$Mspt$Builder$Type)
set "mspt"(value: $SparkProtos$PlatformStatistics$Mspt$Type)
set "playerCount"(value: long)
set "ping"(value: $SparkProtos$PlatformStatistics$Ping$Type)
set "ping"(value: $SparkProtos$PlatformStatistics$Ping$Builder$Type)
get "gcCount"(): integer
get "gcMap"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
get "mspt"(): $SparkProtos$PlatformStatistics$Mspt
get "ping"(): $SparkProtos$PlatformStatistics$Ping
get "gc"(): $Map<(string), ($SparkProtos$PlatformStatistics$Gc)>
get "playerCount"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Builder$Type = ($SparkProtos$PlatformStatistics$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Builder_ = $SparkProtos$PlatformStatistics$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Opcode extends $Enum<($Opcode)> {
static readonly "CONTINUOUS": $Opcode
static readonly "TEXT": $Opcode
static readonly "BINARY": $Opcode
static readonly "PING": $Opcode
static readonly "PONG": $Opcode
static readonly "CLOSING": $Opcode


public static "values"(): ($Opcode)[]
public static "valueOf"(arg0: string): $Opcode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Opcode$Type = (("closing") | ("ping") | ("continuous") | ("binary") | ("text") | ("pong")) | ($Opcode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Opcode_ = $Opcode$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$JavaOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$JavaOrBuilder extends $MessageLiteOrBuilder {

 "getVersion"(): string
 "getVendor"(): string
 "getVersionBytes"(): $ByteString
 "getVendorVersion"(): string
 "getVmArgs"(): string
 "getVmArgsBytes"(): $ByteString
 "getVendorBytes"(): $ByteString
 "getVendorVersionBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$JavaOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$JavaOrBuilder$Type = ($SparkProtos$SystemStatistics$JavaOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$JavaOrBuilder_ = $SparkProtos$SystemStatistics$JavaOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$InvalidProtocolBufferException" {
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$IOException, $IOException$Type} from "packages/java/io/$IOException"

export class $InvalidProtocolBufferException extends $IOException {

constructor(arg0: string, arg1: $IOException$Type)
constructor(arg0: string)
constructor(arg0: $Exception$Type)
constructor(arg0: string, arg1: $Exception$Type)
constructor(arg0: $IOException$Type)

public "getUnfinishedMessage"(): $MessageLite
public "unwrapIOException"(): $IOException
public "setUnfinishedMessage"(arg0: $MessageLite$Type): $InvalidProtocolBufferException
get "unfinishedMessage"(): $MessageLite
set "unfinishedMessage"(value: $MessageLite$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidProtocolBufferException$Type = ($InvalidProtocolBufferException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidProtocolBufferException_ = $InvalidProtocolBufferException$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect" {
import {$SparkWebSocketProtos$ClientConnectOrBuilder, $SparkWebSocketProtos$ClientConnectOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnectOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkWebSocketProtos$ClientConnect$Builder, $SparkWebSocketProtos$ClientConnect$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkWebSocketProtos$ClientConnect extends $GeneratedMessageLite<($SparkWebSocketProtos$ClientConnect), ($SparkWebSocketProtos$ClientConnect$Builder)> implements $SparkWebSocketProtos$ClientConnectOrBuilder {
static readonly "CLIENT_ID_FIELD_NUMBER": integer
static readonly "DESCRIPTION_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ClientConnect)>
public static "newBuilder"(): $SparkWebSocketProtos$ClientConnect$Builder
public static "newBuilder"(arg0: $SparkWebSocketProtos$ClientConnect$Type): $SparkWebSocketProtos$ClientConnect$Builder
public "getDescription"(): string
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ClientConnect
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public static "getDefaultInstance"(): $SparkWebSocketProtos$ClientConnect
public "getClientId"(): string
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ClientConnect
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ClientConnect
public "getClientIdBytes"(): $ByteString
public "getDescriptionBytes"(): $ByteString
get "description"(): string
get "defaultInstance"(): $SparkWebSocketProtos$ClientConnect
get "clientId"(): string
get "clientIdBytes"(): $ByteString
get "descriptionBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientConnect$Type = ($SparkWebSocketProtos$ClientConnect);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientConnect_ = $SparkWebSocketProtos$ClientConnect$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ScopedComponent<C extends $Component> extends $Component {

 "append"(component: $Component$Type): C
 "append"(like: $ComponentLike$Type): C
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): C
 "color"(color: $TextColor$Type): C
 "style"(style: $Style$Type): C
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): C
 "style"(style: $Style$Builder$Type): C
 "children"(children: $List$Type<(any)>): C
 "mergeStyle"(that: $Component$Type): C
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): C
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): C
 "colorIfAbsent"(color: $TextColor$Type): C
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): C
 "clickEvent"(event: $ClickEvent$Type): C
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): C
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "examinableProperties"(): $Stream<(any)>
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $ScopedComponent {
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScopedComponent$Type<C> = ($ScopedComponent<(C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScopedComponent_<C> = $ScopedComponent$Type<(C)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$Any, $Any$Type} from "packages/me/lucko/spark/lib/protobuf/$Any"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $OptionOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getValue"(): $Any
 "hasValue"(): boolean
 "getNameBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $OptionOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OptionOrBuilder$Type = ($OptionOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OptionOrBuilder_ = $OptionOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Duration$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$DurationOrBuilder, $DurationOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$DurationOrBuilder"
import {$Duration, $Duration$Type} from "packages/me/lucko/spark/lib/protobuf/$Duration"

export class $Duration$Builder extends $GeneratedMessageLite$Builder<($Duration), ($Duration$Builder)> implements $DurationOrBuilder {


public "getSeconds"(): long
public "setSeconds"(arg0: long): $Duration$Builder
public "getNanos"(): integer
public "setNanos"(arg0: integer): $Duration$Builder
public "clearNanos"(): $Duration$Builder
public "clearSeconds"(): $Duration$Builder
get "seconds"(): long
set "seconds"(value: long)
get "nanos"(): integer
set "nanos"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Duration$Builder$Type = ($Duration$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Duration$Builder_ = $Duration$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"

export interface $ComponentBuilderApplicable {

 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void

(component: $ComponentBuilder$Type<(any), (any)>): void
}

export namespace $ComponentBuilderApplicable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBuilderApplicable$Type = ($ComponentBuilderApplicable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBuilderApplicable_ = $ComponentBuilderApplicable$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$Builder" {
import {$SparkProtos$SystemStatistics$Memory, $SparkProtos$SystemStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$MemoryOrBuilder, $SparkProtos$SystemStatistics$MemoryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$MemoryOrBuilder"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool$Builder, $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool$Builder"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool, $SparkProtos$SystemStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool"

export class $SparkProtos$SystemStatistics$Memory$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Memory), ($SparkProtos$SystemStatistics$Memory$Builder)> implements $SparkProtos$SystemStatistics$MemoryOrBuilder {


public "getSwap"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
public "hasPhysical"(): boolean
public "getPhysical"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
public "hasSwap"(): boolean
public "mergePhysical"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type): $SparkProtos$SystemStatistics$Memory$Builder
public "clearPhysical"(): $SparkProtos$SystemStatistics$Memory$Builder
public "mergeSwap"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type): $SparkProtos$SystemStatistics$Memory$Builder
public "clearSwap"(): $SparkProtos$SystemStatistics$Memory$Builder
public "setSwap"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type): $SparkProtos$SystemStatistics$Memory$Builder
public "setSwap"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type): $SparkProtos$SystemStatistics$Memory$Builder
public "setPhysical"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type): $SparkProtos$SystemStatistics$Memory$Builder
public "setPhysical"(arg0: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type): $SparkProtos$SystemStatistics$Memory$Builder
get "swap"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
get "physical"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
set "swap"(value: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type)
set "swap"(value: $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type)
set "physical"(value: $SparkProtos$SystemStatistics$Memory$MemoryPool$Builder$Type)
set "physical"(value: $SparkProtos$SystemStatistics$Memory$MemoryPool$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Memory$Builder$Type = ($SparkProtos$SystemStatistics$Memory$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Memory$Builder_ = $SparkProtos$SystemStatistics$Memory$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/enums/$ReadyState" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ReadyState extends $Enum<($ReadyState)> {
static readonly "NOT_YET_CONNECTED": $ReadyState
static readonly "OPEN": $ReadyState
static readonly "CLOSING": $ReadyState
static readonly "CLOSED": $ReadyState


public static "values"(): ($ReadyState)[]
public static "valueOf"(arg0: string): $ReadyState
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReadyState$Type = (("not_yet_connected") | ("closing") | ("closed") | ("open")) | ($ReadyState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReadyState_ = $ReadyState$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$AbstractMessageLite$Builder, $AbstractMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite$Builder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"

export class $AbstractMessageLite<MessageType extends $AbstractMessageLite<(MessageType), (BuilderType)>, BuilderType extends $AbstractMessageLite$Builder<(MessageType), (BuilderType)>> implements $MessageLite {

constructor()

public "toByteArray"(): (byte)[]
public "writeTo"(arg0: $OutputStream$Type): void
public "writeDelimitedTo"(arg0: $OutputStream$Type): void
public "toByteString"(): $ByteString
public "writeTo"(arg0: $CodedOutputStream$Type): void
public "getSerializedSize"(): integer
public "newBuilderForType"(): $MessageLite$Builder
public "getParserForType"(): $Parser<(any)>
public "toBuilder"(): $MessageLite$Builder
public "getDefaultInstanceForType"(): $MessageLite
public "isInitialized"(): boolean
get "serializedSize"(): integer
get "parserForType"(): $Parser<(any)>
get "defaultInstanceForType"(): $MessageLite
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMessageLite$Type<MessageType, BuilderType> = ($AbstractMessageLite<(MessageType), (BuilderType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMessageLite_<MessageType, BuilderType> = $AbstractMessageLite$Type<(MessageType), (BuilderType)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"

export interface $TranslatableComponent$Builder extends $ComponentBuilder<($TranslatableComponent), ($TranslatableComponent$Builder)> {

 "args"(...args: ($ComponentLike$Type)[]): $TranslatableComponent$Builder
 "args"(arg: $Component$Type): $TranslatableComponent$Builder
 "args"(args: $List$Type<(any)>): $TranslatableComponent$Builder
 "args"(...args: ($ComponentBuilder$Type<(any), (any)>)[]): $TranslatableComponent$Builder
 "args"(arg: $ComponentBuilder$Type<(any), (any)>): $TranslatableComponent$Builder
 "key"(key: string): $TranslatableComponent$Builder
 "key"(translatable: $Translatable$Type): $TranslatableComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $TranslatableComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $TranslatableComponent$Builder
 "append"(...components: ($Component$Type)[]): $TranslatableComponent$Builder
 "append"(component: $Component$Type): $TranslatableComponent$Builder
 "append"(component: $ComponentLike$Type): $TranslatableComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TranslatableComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $TranslatableComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $TranslatableComponent$Builder
 "style"(style: $Style$Type): $TranslatableComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $TranslatableComponent$Builder
 "mergeStyle"(that: $Component$Type): $TranslatableComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TranslatableComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TranslatableComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $TranslatableComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $TranslatableComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $TranslatableComponent$Builder
 "resetStyle"(): $TranslatableComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $TranslatableComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TranslatableComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $TranslatableComponent$Builder
 "font"(font: $Key$Type): $TranslatableComponent$Builder
 "appendSpace"(): $TranslatableComponent$Builder
 "insertion"(insertion: string): $TranslatableComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $TranslatableComponent$Builder
}

export namespace $TranslatableComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $TranslatableComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslatableComponent$Builder$Type = ($TranslatableComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslatableComponent$Builder_ = $TranslatableComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$HSVLike" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $HSVLike extends $Examinable {

 "s"(): float
 "h"(): float
 "v"(): float
 "examinableProperties"(): $Stream<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
}

export namespace $HSVLike {
function of(h: float, s: float, v: float): $HSVLike
function hsvLike(h: float, s: float, v: float): $HSVLike
function fromRGB(red: integer, green: integer, blue: integer): $HSVLike
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HSVLike$Type = ($HSVLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HSVLike_ = $HSVLike$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$Label" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Label {
 "info": any

constructor()

public "toString"(): string
public "getOffset"(): integer
get "offset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Label$Type = ($Label);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Label_ = $Label$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Color" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BossBar$Color extends $Enum<($BossBar$Color)> {
static readonly "PINK": $BossBar$Color
static readonly "BLUE": $BossBar$Color
static readonly "RED": $BossBar$Color
static readonly "GREEN": $BossBar$Color
static readonly "YELLOW": $BossBar$Color
static readonly "PURPLE": $BossBar$Color
static readonly "WHITE": $BossBar$Color
static readonly "NAMES": $Index<(string), ($BossBar$Color)>


public static "values"(): ($BossBar$Color)[]
public static "valueOf"(name: string): $BossBar$Color
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBar$Color$Type = (("red") | ("pink") | ("green") | ("blue") | ("white") | ("yellow") | ("purple")) | ($BossBar$Color);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBar$Color_ = $BossBar$Color$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AnyOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $AnyOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): $ByteString
 "getTypeUrl"(): string
 "getTypeUrlBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $AnyOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AnyOrBuilder$Type = ($AnyOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AnyOrBuilder_ = $AnyOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/permission/$PermissionChecker" {
import {$TriState, $TriState$Type} from "packages/me/lucko/spark/lib/adventure/util/$TriState"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"

export interface $PermissionChecker extends $Predicate<(string)> {

 "value"(permission: string): $TriState
 "test"(permission: string): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
 "negate"(): $Predicate<(string)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(string)>

(permission: string): $TriState
}

export namespace $PermissionChecker {
const POINTER: $Pointer<($PermissionChecker)>
function always(state: $TriState$Type): $PermissionChecker
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(string)>
function isEqual<T>(arg0: any): $Predicate<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionChecker$Type = ($PermissionChecker);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionChecker_ = $PermissionChecker$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"

export class $Style$Merge extends $Enum<($Style$Merge)> {
static readonly "COLOR": $Style$Merge
static readonly "DECORATIONS": $Style$Merge
static readonly "EVENTS": $Style$Merge
static readonly "INSERTION": $Style$Merge
static readonly "FONT": $Style$Merge


public static "values"(): ($Style$Merge)[]
public static "valueOf"(name: string): $Style$Merge
/**
 * 
 * @deprecated
 */
public static "of"(...merges: ($Style$Merge$Type)[]): $Set<($Style$Merge)>
public static "all"(): $Set<($Style$Merge)>
public static "merges"(...merges: ($Style$Merge$Type)[]): $Set<($Style$Merge)>
public static "colorAndDecorations"(): $Set<($Style$Merge)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Style$Merge$Type = (("color") | ("decorations") | ("insertion") | ("events") | ("font")) | ($Style$Merge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Style$Merge_ = $Style$Merge$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient" {
import {$BytesocksClient$Socket, $BytesocksClient$Socket$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Socket"
import {$BytesocksClient$Listener, $BytesocksClient$Listener$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Listener"

export interface $BytesocksClient {

 "connect"(arg0: string, arg1: $BytesocksClient$Listener$Type): $BytesocksClient$Socket
 "createAndConnect"(arg0: $BytesocksClient$Listener$Type): $BytesocksClient$Socket
}

export namespace $BytesocksClient {
function create(arg0: string, arg1: string): $BytesocksClient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesocksClient$Type = ($BytesocksClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesocksClient_ = $BytesocksClient$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData$Builder" {
import {$SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder, $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ServerUpdateSamplerData, $SparkWebSocketProtos$ServerUpdateSamplerData$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkWebSocketProtos$ServerUpdateSamplerData$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ServerUpdateSamplerData), ($SparkWebSocketProtos$ServerUpdateSamplerData$Builder)> implements $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder {


public "setPayloadId"(arg0: string): $SparkWebSocketProtos$ServerUpdateSamplerData$Builder
public "getPayloadId"(): string
public "getPayloadIdBytes"(): $ByteString
public "clearPayloadId"(): $SparkWebSocketProtos$ServerUpdateSamplerData$Builder
public "setPayloadIdBytes"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerUpdateSamplerData$Builder
set "payloadId"(value: string)
get "payloadId"(): string
get "payloadIdBytes"(): $ByteString
set "payloadIdBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type = ($SparkWebSocketProtos$ServerUpdateSamplerData$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateSamplerData$Builder_ = $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $SparkProtos {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$Type = ($SparkProtos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos_ = $SparkProtos$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$ClickEventActionSerializer" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ClickEventActionSerializer {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClickEventActionSerializer$Type = ($ClickEventActionSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClickEventActionSerializer_ = $ClickEventActionSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Api" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$Api$Builder, $Api$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Api$Builder"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MethodOrBuilder, $MethodOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MethodOrBuilder"
import {$ApiOrBuilder, $ApiOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ApiOrBuilder"
import {$Mixin, $Mixin$Type} from "packages/me/lucko/spark/lib/protobuf/$Mixin"
import {$Method, $Method$Type} from "packages/me/lucko/spark/lib/protobuf/$Method"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MixinOrBuilder, $MixinOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MixinOrBuilder"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Api extends $GeneratedMessageLite<($Api), ($Api$Builder)> implements $ApiOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "METHODS_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer
static readonly "VERSION_FIELD_NUMBER": integer
static readonly "SOURCE_CONTEXT_FIELD_NUMBER": integer
static readonly "MIXINS_FIELD_NUMBER": integer
static readonly "SYNTAX_FIELD_NUMBER": integer


public "getName"(): string
public "getMethods"(arg0: integer): $Method
public static "parser"(): $Parser<($Api)>
public "getVersion"(): string
public static "newBuilder"(arg0: $Api$Type): $Api$Builder
public static "newBuilder"(): $Api$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Api
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Api
public "getSyntax"(): $Syntax
public static "getDefaultInstance"(): $Api
public "getOptions"(arg0: integer): $Option
public "getNameBytes"(): $ByteString
public "getMixins"(arg0: integer): $Mixin
public "getMethodsCount"(): integer
public "getSourceContext"(): $SourceContext
public "getMethodsList"(): $List<($Method)>
public "getMixinsList"(): $List<($Mixin)>
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getVersionBytes"(): $ByteString
public "hasSourceContext"(): boolean
public "getMixinsCount"(): integer
public "getSyntaxValue"(): integer
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Api
public static "parseFrom"(arg0: $ByteString$Type): $Api
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Api
public static "parseFrom"(arg0: $ByteBuffer$Type): $Api
public static "parseFrom"(arg0: $CodedInputStream$Type): $Api
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Api
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Api
public static "parseFrom"(arg0: $InputStream$Type): $Api
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Api
public static "parseFrom"(arg0: (byte)[]): $Api
public "getMixinsOrBuilder"(arg0: integer): $MixinOrBuilder
public "getMethodsOrBuilderList"(): $List<(any)>
public "getMethodsOrBuilder"(arg0: integer): $MethodOrBuilder
public "getMixinsOrBuilderList"(): $List<(any)>
get "name"(): string
get "version"(): string
get "syntax"(): $Syntax
get "defaultInstance"(): $Api
get "nameBytes"(): $ByteString
get "methodsCount"(): integer
get "sourceContext"(): $SourceContext
get "methodsList"(): $List<($Method)>
get "mixinsList"(): $List<($Mixin)>
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "versionBytes"(): $ByteString
get "mixinsCount"(): integer
get "syntaxValue"(): integer
get "optionsOrBuilderList"(): $List<(any)>
get "methodsOrBuilderList"(): $List<(any)>
get "mixinsOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Api$Type = ($Api);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Api_ = $Api$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Any" {
import {$AnyOrBuilder, $AnyOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$AnyOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Any$Builder, $Any$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Any$Builder"

export class $Any extends $GeneratedMessageLite<($Any), ($Any$Builder)> implements $AnyOrBuilder {
static readonly "TYPE_URL_FIELD_NUMBER": integer
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): $ByteString
public static "parser"(): $Parser<($Any)>
public static "newBuilder"(arg0: $Any$Type): $Any$Builder
public static "newBuilder"(): $Any$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Any
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Any
public static "getDefaultInstance"(): $Any
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Any
public static "parseFrom"(arg0: $CodedInputStream$Type): $Any
public static "parseFrom"(arg0: (byte)[]): $Any
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Any
public static "parseFrom"(arg0: $ByteString$Type): $Any
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Any
public static "parseFrom"(arg0: $ByteBuffer$Type): $Any
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Any
public static "parseFrom"(arg0: $InputStream$Type): $Any
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Any
public "getTypeUrl"(): string
public "getTypeUrlBytes"(): $ByteString
get "value"(): $ByteString
get "defaultInstance"(): $Any
get "typeUrl"(): string
get "typeUrlBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Any$Type = ($Any);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Any_ = $Any$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPongOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkWebSocketProtos$ServerPongOrBuilder extends $MessageLiteOrBuilder {

 "getData"(): integer
 "getOk"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ServerPongOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerPongOrBuilder$Type = ($SparkWebSocketProtos$ServerPongOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerPongOrBuilder_ = $SparkWebSocketProtos$ServerPongOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BinaryReader" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BinaryReader implements $Reader {


public "shouldDiscardUnknownFields"(): boolean
public static "newInstance"(arg0: $ByteBuffer$Type, arg1: boolean): $BinaryReader
public "getTotalBytesRead"(): integer
public "readStringRequireUtf8"(): string
public "readStringListRequireUtf8"(arg0: $List$Type<(string)>): void
/**
 * 
 * @deprecated
 */
public "readGroupBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readMessageBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readBytes"(): $ByteString
public "readFloat"(): float
public "readDouble"(): double
public "readString"(): string
public "getTag"(): integer
public "getFieldNumber"(): integer
public "skipField"(): boolean
public "readUInt64"(): long
public "readInt64"(): long
/**
 * 
 * @deprecated
 */
public "readGroup"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readSFixed64"(): long
public "readFloatList"(arg0: $List$Type<(float)>): void
public "readBoolList"(arg0: $List$Type<(boolean)>): void
public "readMessage"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readBool"(): boolean
public "readFixed32"(): integer
public "readDoubleList"(arg0: $List$Type<(double)>): void
public "readUInt32"(): integer
public "readSInt64"(): long
public "mergeGroupField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readInt64List"(arg0: $List$Type<(long)>): void
public "readFixed64List"(arg0: $List$Type<(long)>): void
public "readInt32List"(arg0: $List$Type<(integer)>): void
public "readFixed64"(): long
public "readSFixed32"(): integer
public "readSInt32"(): integer
public "readFixed32List"(arg0: $List$Type<(integer)>): void
public "readStringList"(arg0: $List$Type<(string)>): void
public "readUInt64List"(arg0: $List$Type<(long)>): void
public "readInt32"(): integer
public "mergeMessageField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readSInt64List"(arg0: $List$Type<(long)>): void
public "readBytesList"(arg0: $List$Type<($ByteString$Type)>): void
public "readSInt32List"(arg0: $List$Type<(integer)>): void
public "readSFixed32List"(arg0: $List$Type<(integer)>): void
/**
 * 
 * @deprecated
 */
public "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
/**
 * 
 * @deprecated
 */
public "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readEnumList"(arg0: $List$Type<(integer)>): void
public "readSFixed64List"(arg0: $List$Type<(long)>): void
public "readUInt32List"(arg0: $List$Type<(integer)>): void
public "readEnum"(): integer
public "readMap"<K, V>(arg0: $Map$Type<(K), (V)>, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $ExtensionRegistryLite$Type): void
get "totalBytesRead"(): integer
get "tag"(): integer
get "fieldNumber"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryReader$Type = ($BinaryReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryReader_ = $BinaryReader$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$TypeReference" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TypeReference {
static readonly "CLASS_TYPE_PARAMETER": integer
static readonly "METHOD_TYPE_PARAMETER": integer
static readonly "CLASS_EXTENDS": integer
static readonly "CLASS_TYPE_PARAMETER_BOUND": integer
static readonly "METHOD_TYPE_PARAMETER_BOUND": integer
static readonly "FIELD": integer
static readonly "METHOD_RETURN": integer
static readonly "METHOD_RECEIVER": integer
static readonly "METHOD_FORMAL_PARAMETER": integer
static readonly "THROWS": integer
static readonly "LOCAL_VARIABLE": integer
static readonly "RESOURCE_VARIABLE": integer
static readonly "EXCEPTION_PARAMETER": integer
static readonly "INSTANCEOF": integer
static readonly "NEW": integer
static readonly "CONSTRUCTOR_REFERENCE": integer
static readonly "METHOD_REFERENCE": integer
static readonly "CAST": integer
static readonly "CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT": integer
static readonly "METHOD_INVOCATION_TYPE_ARGUMENT": integer
static readonly "CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT": integer
static readonly "METHOD_REFERENCE_TYPE_ARGUMENT": integer

constructor(arg0: integer)

public "getValue"(): integer
public "getSort"(): integer
public static "newFormalParameterReference"(arg0: integer): $TypeReference
public static "newTryCatchReference"(arg0: integer): $TypeReference
public static "newTypeParameterReference"(arg0: integer, arg1: integer): $TypeReference
public static "newExceptionReference"(arg0: integer): $TypeReference
public static "newTypeArgumentReference"(arg0: integer, arg1: integer): $TypeReference
public static "newTypeParameterBoundReference"(arg0: integer, arg1: integer, arg2: integer): $TypeReference
public static "newSuperTypeReference"(arg0: integer): $TypeReference
public "getFormalParameterIndex"(): integer
public "getTypeParameterIndex"(): integer
public "getTryCatchBlockIndex"(): integer
public "getTypeArgumentIndex"(): integer
public "getTypeParameterBoundIndex"(): integer
public static "newTypeReference"(arg0: integer): $TypeReference
public "getSuperTypeIndex"(): integer
public "getExceptionIndex"(): integer
get "value"(): integer
get "sort"(): integer
get "formalParameterIndex"(): integer
get "typeParameterIndex"(): integer
get "tryCatchBlockIndex"(): integer
get "typeArgumentIndex"(): integer
get "typeParameterBoundIndex"(): integer
get "superTypeIndex"(): integer
get "exceptionIndex"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeReference$Type = ($TypeReference);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeReference_ = $TypeReference$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExperimentalApi" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ExperimentalApi extends $Annotation {

 "value"(): string
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $ExperimentalApi {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExperimentalApi$Type = ($ExperimentalApi);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExperimentalApi_ = $ExperimentalApi$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadataOrBuilder" {
import {$SparkProtos$CommandSenderMetadata$Type, $SparkProtos$CommandSenderMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Type"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$CommandSenderMetadataOrBuilder extends $MessageLiteOrBuilder {

 "getUniqueIdBytes"(): $ByteString
 "getName"(): string
 "getType"(): $SparkProtos$CommandSenderMetadata$Type
 "getNameBytes"(): $ByteString
 "getUniqueId"(): string
 "getTypeValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$CommandSenderMetadataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$CommandSenderMetadataOrBuilder$Type = ($SparkProtos$CommandSenderMetadataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$CommandSenderMetadataOrBuilder_ = $SparkProtos$CommandSenderMetadataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkSamplerProtos$ThreadNode, $SparkSamplerProtos$ThreadNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode"
import {$SparkSamplerProtos$SamplerDataOrBuilder, $SparkSamplerProtos$SamplerDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerDataOrBuilder"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkSamplerProtos$ThreadNode$Builder, $SparkSamplerProtos$ThreadNode$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$SparkSamplerProtos$SamplerMetadata, $SparkSamplerProtos$SamplerMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata"
import {$SparkSamplerProtos$SamplerMetadata$Builder, $SparkSamplerProtos$SamplerMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$Builder"
import {$SparkSamplerProtos$SamplerData, $SparkSamplerProtos$SamplerData$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData"
import {$SparkProtos$WindowStatistics, $SparkProtos$WindowStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$SparkSamplerProtos$SocketChannelInfo$Builder, $SparkSamplerProtos$SocketChannelInfo$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo$Builder"

export class $SparkSamplerProtos$SamplerData$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SamplerData), ($SparkSamplerProtos$SamplerData$Builder)> implements $SparkSamplerProtos$SamplerDataOrBuilder {


public "putAllTimeWindowStatistics"(arg0: $Map$Type<(integer), ($SparkProtos$WindowStatistics$Type)>): $SparkSamplerProtos$SamplerData$Builder
public "putAllMethodSources"(arg0: $Map$Type<(string), (string)>): $SparkSamplerProtos$SamplerData$Builder
public "getThreads"(arg0: integer): $SparkSamplerProtos$ThreadNode
public "clearMetadata"(): $SparkSamplerProtos$SamplerData$Builder
public "setMetadata"(arg0: $SparkSamplerProtos$SamplerMetadata$Type): $SparkSamplerProtos$SamplerData$Builder
public "setMetadata"(arg0: $SparkSamplerProtos$SamplerMetadata$Builder$Type): $SparkSamplerProtos$SamplerData$Builder
public "mergeMetadata"(arg0: $SparkSamplerProtos$SamplerMetadata$Type): $SparkSamplerProtos$SamplerData$Builder
public "getClassSourcesMap"(): $Map<(string), (string)>
public "getThreadsCount"(): integer
public "getThreadsList"(): $List<($SparkSamplerProtos$ThreadNode)>
public "addAllThreads"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$SamplerData$Builder
/**
 * 
 * @deprecated
 */
public "getMethodSources"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
public "getClassSources"(): $Map<(string), (string)>
public "clearThreads"(): $SparkSamplerProtos$SamplerData$Builder
public "addThreads"(arg0: $SparkSamplerProtos$ThreadNode$Type): $SparkSamplerProtos$SamplerData$Builder
public "addThreads"(arg0: integer, arg1: $SparkSamplerProtos$ThreadNode$Type): $SparkSamplerProtos$SamplerData$Builder
public "addThreads"(arg0: $SparkSamplerProtos$ThreadNode$Builder$Type): $SparkSamplerProtos$SamplerData$Builder
public "addThreads"(arg0: integer, arg1: $SparkSamplerProtos$ThreadNode$Builder$Type): $SparkSamplerProtos$SamplerData$Builder
/**
 * 
 * @deprecated
 */
public "getLineSources"(): $Map<(string), (string)>
public "setThreads"(arg0: integer, arg1: $SparkSamplerProtos$ThreadNode$Builder$Type): $SparkSamplerProtos$SamplerData$Builder
public "setThreads"(arg0: integer, arg1: $SparkSamplerProtos$ThreadNode$Type): $SparkSamplerProtos$SamplerData$Builder
public "removeThreads"(arg0: integer): $SparkSamplerProtos$SamplerData$Builder
public "addTimeWindows"(arg0: integer): $SparkSamplerProtos$SamplerData$Builder
public "addAllTimeWindows"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$SamplerData$Builder
public "getLineSourcesMap"(): $Map<(string), (string)>
public "setTimeWindows"(arg0: integer, arg1: integer): $SparkSamplerProtos$SamplerData$Builder
public "getTimeWindows"(arg0: integer): integer
public "clearChannelInfo"(): $SparkSamplerProtos$SamplerData$Builder
public "getChannelInfo"(): $SparkSamplerProtos$SocketChannelInfo
public "clearTimeWindows"(): $SparkSamplerProtos$SamplerData$Builder
public "mergeChannelInfo"(arg0: $SparkSamplerProtos$SocketChannelInfo$Type): $SparkSamplerProtos$SamplerData$Builder
public "hasChannelInfo"(): boolean
public "setChannelInfo"(arg0: $SparkSamplerProtos$SocketChannelInfo$Type): $SparkSamplerProtos$SamplerData$Builder
public "setChannelInfo"(arg0: $SparkSamplerProtos$SocketChannelInfo$Builder$Type): $SparkSamplerProtos$SamplerData$Builder
public "getTimeWindowsList"(): $List<(integer)>
public "putAllClassSources"(arg0: $Map$Type<(string), (string)>): $SparkSamplerProtos$SamplerData$Builder
public "putAllLineSources"(arg0: $Map$Type<(string), (string)>): $SparkSamplerProtos$SamplerData$Builder
public "hasMetadata"(): boolean
public "getMethodSourcesOrDefault"(arg0: string, arg1: string): string
public "getLineSourcesCount"(): integer
public "getLineSourcesOrDefault"(arg0: string, arg1: string): string
public "getTimeWindowStatisticsOrDefault"(arg0: integer, arg1: $SparkProtos$WindowStatistics$Type): $SparkProtos$WindowStatistics
public "containsLineSources"(arg0: string): boolean
public "getMethodSourcesCount"(): integer
public "containsMethodSources"(arg0: string): boolean
public "getTimeWindowStatisticsCount"(): integer
public "getMethodSourcesMap"(): $Map<(string), (string)>
public "getTimeWindowStatisticsMap"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
public "getClassSourcesOrDefault"(arg0: string, arg1: string): string
public "getMethodSourcesOrThrow"(arg0: string): string
public "getTimeWindowsCount"(): integer
public "containsTimeWindowStatistics"(arg0: integer): boolean
public "containsClassSources"(arg0: string): boolean
public "getClassSourcesCount"(): integer
public "getClassSourcesOrThrow"(arg0: string): string
public "getLineSourcesOrThrow"(arg0: string): string
/**
 * 
 * @deprecated
 */
public "getTimeWindowStatistics"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
public "getTimeWindowStatisticsOrThrow"(arg0: integer): $SparkProtos$WindowStatistics
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata
public "removeMethodSources"(arg0: string): $SparkSamplerProtos$SamplerData$Builder
public "removeTimeWindowStatistics"(arg0: integer): $SparkSamplerProtos$SamplerData$Builder
public "clearTimeWindowStatistics"(): $SparkSamplerProtos$SamplerData$Builder
public "putTimeWindowStatistics"(arg0: integer, arg1: $SparkProtos$WindowStatistics$Type): $SparkSamplerProtos$SamplerData$Builder
public "putClassSources"(arg0: string, arg1: string): $SparkSamplerProtos$SamplerData$Builder
public "clearClassSources"(): $SparkSamplerProtos$SamplerData$Builder
public "clearLineSources"(): $SparkSamplerProtos$SamplerData$Builder
public "removeLineSources"(arg0: string): $SparkSamplerProtos$SamplerData$Builder
public "clearMethodSources"(): $SparkSamplerProtos$SamplerData$Builder
public "putMethodSources"(arg0: string, arg1: string): $SparkSamplerProtos$SamplerData$Builder
public "putLineSources"(arg0: string, arg1: string): $SparkSamplerProtos$SamplerData$Builder
public "removeClassSources"(arg0: string): $SparkSamplerProtos$SamplerData$Builder
set "metadata"(value: $SparkSamplerProtos$SamplerMetadata$Type)
set "metadata"(value: $SparkSamplerProtos$SamplerMetadata$Builder$Type)
get "classSourcesMap"(): $Map<(string), (string)>
get "threadsCount"(): integer
get "threadsList"(): $List<($SparkSamplerProtos$ThreadNode)>
get "methodSources"(): $Map<(string), (string)>
get "classSources"(): $Map<(string), (string)>
get "lineSources"(): $Map<(string), (string)>
get "lineSourcesMap"(): $Map<(string), (string)>
get "channelInfo"(): $SparkSamplerProtos$SocketChannelInfo
set "channelInfo"(value: $SparkSamplerProtos$SocketChannelInfo$Type)
set "channelInfo"(value: $SparkSamplerProtos$SocketChannelInfo$Builder$Type)
get "timeWindowsList"(): $List<(integer)>
get "lineSourcesCount"(): integer
get "methodSourcesCount"(): integer
get "timeWindowStatisticsCount"(): integer
get "methodSourcesMap"(): $Map<(string), (string)>
get "timeWindowStatisticsMap"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
get "timeWindowsCount"(): integer
get "classSourcesCount"(): integer
get "timeWindowStatistics"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
get "metadata"(): $SparkSamplerProtos$SamplerMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerData$Builder$Type = ($SparkSamplerProtos$SamplerData$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerData$Builder_ = $SparkSamplerProtos$SamplerData$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$MemoryOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool, $SparkProtos$SystemStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$SystemStatistics$MemoryOrBuilder extends $MessageLiteOrBuilder {

 "getSwap"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
 "hasPhysical"(): boolean
 "getPhysical"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
 "hasSwap"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$SystemStatistics$MemoryOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$MemoryOrBuilder$Type = ($SparkProtos$SystemStatistics$MemoryOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$MemoryOrBuilder_ = $SparkProtos$SystemStatistics$MemoryOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode$Builder" {
import {$SparkSamplerProtos$ThreadNodeOrBuilder, $SparkSamplerProtos$ThreadNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNodeOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkSamplerProtos$ThreadNode, $SparkSamplerProtos$ThreadNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkSamplerProtos$StackTraceNode, $SparkSamplerProtos$StackTraceNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode"
import {$SparkSamplerProtos$StackTraceNode$Builder, $SparkSamplerProtos$StackTraceNode$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode$Builder"

export class $SparkSamplerProtos$ThreadNode$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$ThreadNode), ($SparkSamplerProtos$ThreadNode$Builder)> implements $SparkSamplerProtos$ThreadNodeOrBuilder {


public "getTimesList"(): $List<(double)>
public "setChildrenRefs"(arg0: integer, arg1: integer): $SparkSamplerProtos$ThreadNode$Builder
public "getChildrenList"(): $List<($SparkSamplerProtos$StackTraceNode)>
public "clearChildrenRefs"(): $SparkSamplerProtos$ThreadNode$Builder
public "getChildrenRefs"(arg0: integer): integer
public "addAllTimes"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$ThreadNode$Builder
public "addChildrenRefs"(arg0: integer): $SparkSamplerProtos$ThreadNode$Builder
public "setChildren"(arg0: integer, arg1: $SparkSamplerProtos$StackTraceNode$Type): $SparkSamplerProtos$ThreadNode$Builder
public "setChildren"(arg0: integer, arg1: $SparkSamplerProtos$StackTraceNode$Builder$Type): $SparkSamplerProtos$ThreadNode$Builder
public "clearTimes"(): $SparkSamplerProtos$ThreadNode$Builder
public "getTimesCount"(): integer
public "getName"(): string
public "setName"(arg0: string): $SparkSamplerProtos$ThreadNode$Builder
public "setTimes"(arg0: integer, arg1: double): $SparkSamplerProtos$ThreadNode$Builder
public "getChildren"(arg0: integer): $SparkSamplerProtos$StackTraceNode
public "getTimes"(arg0: integer): double
public "setNameBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$ThreadNode$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkSamplerProtos$ThreadNode$Builder
public "addChildren"(arg0: integer, arg1: $SparkSamplerProtos$StackTraceNode$Builder$Type): $SparkSamplerProtos$ThreadNode$Builder
public "addChildren"(arg0: $SparkSamplerProtos$StackTraceNode$Builder$Type): $SparkSamplerProtos$ThreadNode$Builder
public "addChildren"(arg0: integer, arg1: $SparkSamplerProtos$StackTraceNode$Type): $SparkSamplerProtos$ThreadNode$Builder
public "addChildren"(arg0: $SparkSamplerProtos$StackTraceNode$Type): $SparkSamplerProtos$ThreadNode$Builder
public "removeChildren"(arg0: integer): $SparkSamplerProtos$ThreadNode$Builder
public "addTimes"(arg0: double): $SparkSamplerProtos$ThreadNode$Builder
public "addAllChildrenRefs"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$ThreadNode$Builder
public "addAllChildren"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$ThreadNode$Builder
public "clearChildren"(): $SparkSamplerProtos$ThreadNode$Builder
public "getChildrenCount"(): integer
public "getChildrenRefsList"(): $List<(integer)>
public "getChildrenRefsCount"(): integer
get "timesList"(): $List<(double)>
get "childrenList"(): $List<($SparkSamplerProtos$StackTraceNode)>
get "timesCount"(): integer
get "name"(): string
set "name"(value: string)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "childrenCount"(): integer
get "childrenRefsList"(): $List<(integer)>
get "childrenRefsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$ThreadNode$Builder$Type = ($SparkSamplerProtos$ThreadNode$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$ThreadNode$Builder_ = $SparkSamplerProtos$ThreadNode$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$InlineMe" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $InlineMe extends $Annotation {

 "replacement"(): string
 "imports"(): (string)[]
 "staticImports"(): (string)[]
 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $InlineMe {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InlineMe$Type = ($InlineMe);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InlineMe_ = $InlineMe$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StringValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $StringValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): string
 "getValueBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $StringValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringValueOrBuilder$Type = ($StringValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringValueOrBuilder_ = $StringValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$ProfileSegment" {
import {$AsyncStackTraceElement, $AsyncStackTraceElement$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncStackTraceElement"
import {$JfrReader, $JfrReader$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader"
import {$JfrReader$Event, $JfrReader$Event$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Event"

export class $ProfileSegment {

constructor(arg0: integer, arg1: string, arg2: ($AsyncStackTraceElement$Type)[], arg3: long)

public "getStackTrace"(): ($AsyncStackTraceElement)[]
public "getValue"(): long
public "getThreadName"(): string
public "getNativeThreadId"(): integer
public static "parseSegment"(arg0: $JfrReader$Type, arg1: $JfrReader$Event$Type, arg2: string, arg3: long): $ProfileSegment
get "stackTrace"(): ($AsyncStackTraceElement)[]
get "value"(): long
get "threadName"(): string
get "nativeThreadId"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProfileSegment$Type = ($ProfileSegment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProfileSegment_ = $ProfileSegment$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$SampleCollector" {
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$AsyncProfilerAccess, $AsyncProfilerAccess$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerAccess"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$JfrReader$Event, $JfrReader$Event$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Event"

export interface $SampleCollector<E extends $JfrReader$Event> {

 "initArguments"(arg0: $AsyncProfilerAccess$Type): $Collection<(string)>
 "getMode"(): $SamplerMode
 "eventClass"(): $Class<(E)>
 "measure"(arg0: E): long
}

export namespace $SampleCollector {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SampleCollector$Type<E> = ($SampleCollector<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SampleCollector_<E> = $SampleCollector$Type<(E)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$SerializerFactory" {
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$TypeAdapterFactory, $TypeAdapterFactory$Type} from "packages/com/google/gson/$TypeAdapterFactory"
import {$TypeToken, $TypeToken$Type} from "packages/com/google/gson/reflect/$TypeToken"

export class $SerializerFactory implements $TypeAdapterFactory {


public "create"<T>(gson: $Gson$Type, type: $TypeToken$Type<(T)>): $TypeAdapter<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SerializerFactory$Type = ($SerializerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SerializerFactory_ = $SerializerFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/string/$Strings" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Strings {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Strings$Type = ($Strings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Strings_ = $Strings$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/client/$DnsResolver" {
import {$URI, $URI$Type} from "packages/java/net/$URI"
import {$InetAddress, $InetAddress$Type} from "packages/java/net/$InetAddress"

export interface $DnsResolver {

 "resolve"(arg0: $URI$Type): $InetAddress

(arg0: $URI$Type): $InetAddress
}

export namespace $DnsResolver {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DnsResolver$Type = ($DnsResolver);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DnsResolver_ = $DnsResolver$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo$Builder" {
import {$SparkSamplerProtos$SocketChannelInfoOrBuilder, $SparkSamplerProtos$SocketChannelInfoOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfoOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkSamplerProtos$SocketChannelInfo$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SocketChannelInfo), ($SparkSamplerProtos$SocketChannelInfo$Builder)> implements $SparkSamplerProtos$SocketChannelInfoOrBuilder {


public "getPublicKey"(): $ByteString
public "setChannelId"(arg0: string): $SparkSamplerProtos$SocketChannelInfo$Builder
public "setPublicKey"(arg0: $ByteString$Type): $SparkSamplerProtos$SocketChannelInfo$Builder
public "getChannelId"(): string
public "clearChannelId"(): $SparkSamplerProtos$SocketChannelInfo$Builder
public "setChannelIdBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$SocketChannelInfo$Builder
public "getChannelIdBytes"(): $ByteString
public "clearPublicKey"(): $SparkSamplerProtos$SocketChannelInfo$Builder
get "publicKey"(): $ByteString
set "channelId"(value: string)
set "publicKey"(value: $ByteString$Type)
get "channelId"(): string
set "channelIdBytes"(value: $ByteString$Type)
get "channelIdBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SocketChannelInfo$Builder$Type = ($SparkSamplerProtos$SocketChannelInfo$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SocketChannelInfo$Builder_ = $SparkSamplerProtos$SocketChannelInfo$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage" {
import {$Instant, $Instant$Type} from "packages/java/time/$Instant"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Identified, $Identified$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identified"
import {$SignedMessage$Signature, $SignedMessage$Signature$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $SignedMessage extends $Identified, $Examinable {

 "signature"(): $SignedMessage$Signature
 "message"(): string
 "timestamp"(): $Instant
 "isSystem"(): boolean
 "examinableProperties"(): $Stream<(any)>
 "unsignedContent"(): $Component
 "canDelete"(): boolean
 "salt"(): long
 "identity"(): $Identity
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
}

export namespace $SignedMessage {
function signature(signature: (byte)[]): $SignedMessage$Signature
function system(message: string, unsignedContent: $ComponentLike$Type): $SignedMessage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignedMessage$Type = ($SignedMessage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignedMessage_ = $SignedMessage$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$ExplicitTickCounter" {
import {$WindowStatisticsCollector$BaseTickCounter, $WindowStatisticsCollector$BaseTickCounter$Type} from "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$BaseTickCounter"

export class $WindowStatisticsCollector$ExplicitTickCounter extends $WindowStatisticsCollector$BaseTickCounter {


public "getTotalCountedTicks"(): integer
public "getCountedTicksThisWindowAndReset"(): integer
public "increment"(): void
get "totalCountedTicks"(): integer
get "countedTicksThisWindowAndReset"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowStatisticsCollector$ExplicitTickCounter$Type = ($WindowStatisticsCollector$ExplicitTickCounter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowStatisticsCollector$ExplicitTickCounter_ = $WindowStatisticsCollector$ExplicitTickCounter$Type;
}}
declare module "packages/me/lucko/spark/common/util/$MethodDisambiguator" {
import {$StackTraceNode, $StackTraceNode$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$MethodDisambiguator$MethodDescription, $MethodDisambiguator$MethodDescription$Type} from "packages/me/lucko/spark/common/util/$MethodDisambiguator$MethodDescription"

export class $MethodDisambiguator {

constructor()

public "disambiguate"(arg0: $StackTraceNode$Type): $Optional<($MethodDisambiguator$MethodDescription)>
public "disambiguate"(arg0: string, arg1: string, arg2: integer): $Optional<($MethodDisambiguator$MethodDescription)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodDisambiguator$Type = ($MethodDisambiguator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodDisambiguator_ = $MethodDisambiguator$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type extends $Enum<($SparkSamplerProtos$SamplerMetadata$DataAggregator$Type)> implements $Internal$EnumLite {
static readonly "SIMPLE": $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
static readonly "TICKED": $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
static readonly "UNRECOGNIZED": $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
static readonly "SIMPLE_VALUE": integer
static readonly "TICKED_VALUE": integer


public static "values"(): ($SparkSamplerProtos$SamplerMetadata$DataAggregator$Type)[]
public static "valueOf"(arg0: string): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkSamplerProtos$SamplerMetadata$DataAggregator$Type)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type = (("ticked") | ("simple") | ("unrecognized")) | ($SparkSamplerProtos$SamplerMetadata$DataAggregator$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type_ = $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WindowStatisticsOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$WindowStatisticsOrBuilder extends $MessageLiteOrBuilder {

 "getDuration"(): integer
 "getCpuSystem"(): double
 "getMsptMedian"(): double
 "getTps"(): double
 "getMsptMax"(): double
 "getCpuProcess"(): double
 "getTileEntities"(): integer
 "getStartTime"(): long
 "getPlayers"(): integer
 "getEntities"(): integer
 "getTicks"(): integer
 "getChunks"(): integer
 "getEndTime"(): long
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$WindowStatisticsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WindowStatisticsOrBuilder$Type = ($SparkProtos$WindowStatisticsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WindowStatisticsOrBuilder_ = $SparkProtos$WindowStatisticsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Enum" {
import {$Enum$Builder, $Enum$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Enum$Builder"
import {$EnumOrBuilder, $EnumOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$EnumValue, $EnumValue$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$EnumValueOrBuilder, $EnumValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValueOrBuilder"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Enum extends $GeneratedMessageLite<($Enum), ($Enum$Builder)> implements $EnumOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "ENUMVALUE_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer
static readonly "SOURCE_CONTEXT_FIELD_NUMBER": integer
static readonly "SYNTAX_FIELD_NUMBER": integer


public "getName"(): string
public static "parser"(): $Parser<($Enum)>
public static "newBuilder"(arg0: $Enum$Type): $Enum$Builder
public static "newBuilder"(): $Enum$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Enum
public "getSyntax"(): $Syntax
public static "getDefaultInstance"(): $Enum
public "getOptions"(arg0: integer): $Option
public "getNameBytes"(): $ByteString
public "getSourceContext"(): $SourceContext
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "hasSourceContext"(): boolean
public "getSyntaxValue"(): integer
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public static "parseFrom"(arg0: (byte)[]): $Enum
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseFrom"(arg0: $ByteString$Type): $Enum
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseFrom"(arg0: $InputStream$Type): $Enum
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseFrom"(arg0: $CodedInputStream$Type): $Enum
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Enum
public static "parseFrom"(arg0: $ByteBuffer$Type): $Enum
public "getEnumvalueCount"(): integer
public "getEnumvalue"(arg0: integer): $EnumValue
public "getEnumvalueList"(): $List<($EnumValue)>
public "getEnumvalueOrBuilder"(arg0: integer): $EnumValueOrBuilder
public "getEnumvalueOrBuilderList"(): $List<(any)>
get "name"(): string
get "syntax"(): $Syntax
get "defaultInstance"(): $Enum
get "nameBytes"(): $ByteString
get "sourceContext"(): $SourceContext
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
get "optionsOrBuilderList"(): $List<(any)>
get "enumvalueCount"(): integer
get "enumvalueList"(): $List<($EnumValue)>
get "enumvalueOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Enum$Type = ($Enum);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Enum_ = $Enum$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgePlayerPingProvider" {
import {$PlayerPingProvider, $PlayerPingProvider$Type} from "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgePlayerPingProvider implements $PlayerPingProvider {

constructor(arg0: $MinecraftServer$Type)

public "poll"(): $Map<(string), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgePlayerPingProvider$Type = ($ForgePlayerPingProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgePlayerPingProvider_ = $ForgePlayerPingProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/server/$DefaultWebSocketServerFactory" {
import {$WebSocketServerFactory, $WebSocketServerFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketServerFactory"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"

export class $DefaultWebSocketServerFactory implements $WebSocketServerFactory {

constructor()

public "close"(): void
public "wrapChannel"(arg0: $SocketChannel$Type, arg1: $SelectionKey$Type): $SocketChannel
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultWebSocketServerFactory$Type = ($DefaultWebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultWebSocketServerFactory_ = $DefaultWebSocketServerFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BytesValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $BytesValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $BytesValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesValueOrBuilder$Type = ($BytesValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesValueOrBuilder_ = $BytesValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/util/$SparkPlaceholder" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"

export class $SparkPlaceholder extends $Enum<($SparkPlaceholder)> {
static readonly "TPS": $SparkPlaceholder
static readonly "TICKDURATION": $SparkPlaceholder
static readonly "CPU_SYSTEM": $SparkPlaceholder
static readonly "CPU_PROCESS": $SparkPlaceholder


public "getName"(): string
public static "values"(): ($SparkPlaceholder)[]
public static "valueOf"(arg0: string): $SparkPlaceholder
public "resolve"(arg0: $SparkPlatform$Type, arg1: string): $TextComponent
public static "resolveComponent"(arg0: $SparkPlatform$Type, arg1: string): $TextComponent
public static "resolveFormattingCode"(arg0: $SparkPlatform$Type, arg1: string): string
get "name"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkPlaceholder$Type = (("tickduration") | ("tps") | ("cpu_system") | ("cpu_process")) | ($SparkPlaceholder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkPlaceholder_ = $SparkPlaceholder$Type;
}}
declare module "packages/me/lucko/spark/common/api/$AbstractStatistic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Statistic, $Statistic$Type} from "packages/me/lucko/spark/api/statistic/$Statistic"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export class $AbstractStatistic<W extends ($Enum<(W)>) & ($StatisticWindow)> implements $Statistic<(W)> {


public "name"(): string
public "getWindows"(): (W)[]
get "windows"(): (W)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractStatistic$Type<W> = ($AbstractStatistic<(W)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractStatistic_<W> = $AbstractStatistic$Type<(W)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$CloseFrame" {
import {$ControlFrame, $ControlFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$ControlFrame"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $CloseFrame extends $ControlFrame {
static readonly "NORMAL": integer
static readonly "GOING_AWAY": integer
static readonly "PROTOCOL_ERROR": integer
static readonly "REFUSE": integer
static readonly "NOCODE": integer
static readonly "ABNORMAL_CLOSE": integer
static readonly "NO_UTF8": integer
static readonly "POLICY_VALIDATION": integer
static readonly "TOOBIG": integer
static readonly "EXTENSION": integer
static readonly "UNEXPECTED_CONDITION": integer
static readonly "SERVICE_RESTART": integer
static readonly "TRY_AGAIN_LATER": integer
static readonly "BAD_GATEWAY": integer
static readonly "TLS_ERROR": integer
static readonly "NEVER_CONNECTED": integer
static readonly "BUGGYCLOSE": integer
static readonly "FLASHPOLICY": integer

constructor()

public "setReason"(arg0: string): void
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getMessage"(): string
public "isValid"(): void
public "setPayload"(arg0: $ByteBuffer$Type): void
public "getCloseCode"(): integer
public "setCode"(arg0: integer): void
public "getPayloadData"(): $ByteBuffer
set "reason"(value: string)
get "message"(): string
get "valid"(): boolean
set "payload"(value: $ByteBuffer$Type)
get "closeCode"(): integer
set "code"(value: integer)
get "payloadData"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseFrame$Type = ($CloseFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseFrame_ = $CloseFrame$Type;
}}
declare module "packages/me/lucko/spark/common/ws/$ViewerSocketConnection" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$BytesocksClient, $BytesocksClient$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$BytesocksClient$Listener, $BytesocksClient$Listener$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Listener"
import {$ViewerSocketConnection$Listener, $ViewerSocketConnection$Listener$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocketConnection$Listener"
import {$CryptoAlgorithm, $CryptoAlgorithm$Type} from "packages/me/lucko/spark/common/ws/$CryptoAlgorithm"
import {$SparkWebSocketProtos$PacketWrapper$Builder, $SparkWebSocketProtos$PacketWrapper$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$Builder"

export class $ViewerSocketConnection implements $BytesocksClient$Listener, $AutoCloseable {
static readonly "VERSION_1": integer
static readonly "CRYPTO": $CryptoAlgorithm

constructor(arg0: $SparkPlatform$Type, arg1: $BytesocksClient$Type, arg2: $ViewerSocketConnection$Listener$Type)

public "isOpen"(): boolean
public "close"(): void
public "onClose"(arg0: integer, arg1: string): void
public "sendPacket"(arg0: $Consumer$Type<($SparkWebSocketProtos$PacketWrapper$Builder$Type)>): void
public "getChannelId"(): string
public "onError"(arg0: $Throwable$Type): void
public "onText"(arg0: string): void
public "onOpen"(): void
get "open"(): boolean
get "channelId"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewerSocketConnection$Type = ($ViewerSocketConnection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewerSocketConnection_ = $ViewerSocketConnection$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$PacketCase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $SparkWebSocketProtos$PacketWrapper$PacketCase extends $Enum<($SparkWebSocketProtos$PacketWrapper$PacketCase)> {
static readonly "SERVER_PONG": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "SERVER_CONNECT_RESPONSE": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "SERVER_UPDATE_SAMPLER": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "SERVER_UPDATE_STATISTICS": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "CLIENT_PING": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "CLIENT_CONNECT": $SparkWebSocketProtos$PacketWrapper$PacketCase
static readonly "PACKET_NOT_SET": $SparkWebSocketProtos$PacketWrapper$PacketCase


public static "values"(): ($SparkWebSocketProtos$PacketWrapper$PacketCase)[]
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkWebSocketProtos$PacketWrapper$PacketCase
public static "valueOf"(arg0: string): $SparkWebSocketProtos$PacketWrapper$PacketCase
public "getNumber"(): integer
public static "forNumber"(arg0: integer): $SparkWebSocketProtos$PacketWrapper$PacketCase
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$PacketWrapper$PacketCase$Type = (("server_pong") | ("server_update_sampler") | ("client_ping") | ("packet_not_set") | ("server_connect_response") | ("server_update_statistics") | ("client_connect")) | ($SparkWebSocketProtos$PacketWrapper$PacketCase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$PacketWrapper$PacketCase_ = $SparkWebSocketProtos$PacketWrapper$PacketCase$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowEntity" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $HoverEvent$ShowEntity implements $Examinable {


public "name"(): $Component
public "name"(name: $Component$Type): $HoverEvent$ShowEntity
public "type"(): $Key
public "type"(type: $Keyed$Type): $HoverEvent$ShowEntity
public "type"(type: $Key$Type): $HoverEvent$ShowEntity
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public static "of"(type: $Keyed$Type, id: $UUID$Type): $HoverEvent$ShowEntity
public static "of"(type: $Key$Type, id: $UUID$Type): $HoverEvent$ShowEntity
public static "of"(type: $Key$Type, id: $UUID$Type, name: $Component$Type): $HoverEvent$ShowEntity
public static "of"(type: $Keyed$Type, id: $UUID$Type, name: $Component$Type): $HoverEvent$ShowEntity
public "id"(): $UUID
public "id"(id: $UUID$Type): $HoverEvent$ShowEntity
public "examinableProperties"(): $Stream<(any)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HoverEvent$ShowEntity$Type = ($HoverEvent$ShowEntity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HoverEvent$ShowEntity_ = $HoverEvent$ShowEntity$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/title/$Title" {
import {$TitlePart, $TitlePart$Type} from "packages/me/lucko/spark/lib/adventure/title/$TitlePart"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Title$Times, $Title$Times$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title$Times"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Title extends $Examinable {

 "part"<T>(part: $TitlePart$Type<(T)>): T
 "title"(): $Component
 "times"(): $Title$Times
 "subtitle"(): $Component
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $Title {
const DEFAULT_TIMES: $Title$Times
function title(title: $Component$Type, subtitle: $Component$Type): $Title
function title(title: $Component$Type, subtitle: $Component$Type, times: $Title$Times$Type): $Title
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Title$Type = ($Title);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Title_ = $Title$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/util/$Base64" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Base64 {
static readonly "NO_OPTIONS": integer
static readonly "ENCODE": integer
static readonly "GZIP": integer
static readonly "DO_BREAK_LINES": integer
static readonly "URL_SAFE": integer
static readonly "ORDERED": integer


public static "encodeBytesToBytes"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): (byte)[]
public static "encodeBytes"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: integer): string
public static "encodeBytes"(arg0: (byte)[]): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Base64$Type = ($Base64);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Base64_ = $Base64$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata" {
import {$SparkProtos$CommandSenderMetadata$Builder, $SparkProtos$CommandSenderMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Builder"
import {$SparkProtos$CommandSenderMetadata$Type, $SparkProtos$CommandSenderMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Type"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$CommandSenderMetadataOrBuilder, $SparkProtos$CommandSenderMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadataOrBuilder"

export class $SparkProtos$CommandSenderMetadata extends $GeneratedMessageLite<($SparkProtos$CommandSenderMetadata), ($SparkProtos$CommandSenderMetadata$Builder)> implements $SparkProtos$CommandSenderMetadataOrBuilder {
static readonly "TYPE_FIELD_NUMBER": integer
static readonly "NAME_FIELD_NUMBER": integer
static readonly "UNIQUE_ID_FIELD_NUMBER": integer


public "getUniqueIdBytes"(): $ByteString
public "getName"(): string
public "getType"(): $SparkProtos$CommandSenderMetadata$Type
public static "parser"(): $Parser<($SparkProtos$CommandSenderMetadata)>
public static "newBuilder"(): $SparkProtos$CommandSenderMetadata$Builder
public static "newBuilder"(arg0: $SparkProtos$CommandSenderMetadata$Type): $SparkProtos$CommandSenderMetadata$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$CommandSenderMetadata
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "getDefaultInstance"(): $SparkProtos$CommandSenderMetadata
public "getNameBytes"(): $ByteString
public "getUniqueId"(): string
public "getTypeValue"(): integer
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$CommandSenderMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$CommandSenderMetadata
get "uniqueIdBytes"(): $ByteString
get "name"(): string
get "type"(): $SparkProtos$CommandSenderMetadata$Type
get "defaultInstance"(): $SparkProtos$CommandSenderMetadata
get "nameBytes"(): $ByteString
get "uniqueId"(): string
get "typeValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$CommandSenderMetadata$Type = ($SparkProtos$CommandSenderMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$CommandSenderMetadata_ = $SparkProtos$CommandSenderMetadata$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics" {
import {$SparkProtos$WindowStatisticsOrBuilder, $SparkProtos$WindowStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatisticsOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$WindowStatistics$Builder, $SparkProtos$WindowStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$WindowStatistics extends $GeneratedMessageLite<($SparkProtos$WindowStatistics), ($SparkProtos$WindowStatistics$Builder)> implements $SparkProtos$WindowStatisticsOrBuilder {
static readonly "TICKS_FIELD_NUMBER": integer
static readonly "CPU_PROCESS_FIELD_NUMBER": integer
static readonly "CPU_SYSTEM_FIELD_NUMBER": integer
static readonly "TPS_FIELD_NUMBER": integer
static readonly "MSPT_MEDIAN_FIELD_NUMBER": integer
static readonly "MSPT_MAX_FIELD_NUMBER": integer
static readonly "PLAYERS_FIELD_NUMBER": integer
static readonly "ENTITIES_FIELD_NUMBER": integer
static readonly "TILE_ENTITIES_FIELD_NUMBER": integer
static readonly "CHUNKS_FIELD_NUMBER": integer
static readonly "START_TIME_FIELD_NUMBER": integer
static readonly "END_TIME_FIELD_NUMBER": integer
static readonly "DURATION_FIELD_NUMBER": integer


public "getDuration"(): integer
public static "parser"(): $Parser<($SparkProtos$WindowStatistics)>
public static "newBuilder"(arg0: $SparkProtos$WindowStatistics$Type): $SparkProtos$WindowStatistics$Builder
public static "newBuilder"(): $SparkProtos$WindowStatistics$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$WindowStatistics
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public "getCpuSystem"(): double
public "getMsptMedian"(): double
public "getTps"(): double
public "getMsptMax"(): double
public "getCpuProcess"(): double
public "getTileEntities"(): integer
public static "getDefaultInstance"(): $SparkProtos$WindowStatistics
public "getStartTime"(): long
public "getPlayers"(): integer
public "getEntities"(): integer
public "getTicks"(): integer
public "getChunks"(): integer
public "getEndTime"(): long
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WindowStatistics
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$WindowStatistics
get "duration"(): integer
get "cpuSystem"(): double
get "msptMedian"(): double
get "tps"(): double
get "msptMax"(): double
get "cpuProcess"(): double
get "tileEntities"(): integer
get "defaultInstance"(): $SparkProtos$WindowStatistics
get "startTime"(): long
get "players"(): integer
get "entities"(): integer
get "ticks"(): integer
get "chunks"(): integer
get "endTime"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WindowStatistics$Type = ($SparkProtos$WindowStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WindowStatistics_ = $SparkProtos$WindowStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Type" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Type$Builder, $Type$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Type$Builder"
import {$FieldOrBuilder, $FieldOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Field, $Field$Type} from "packages/me/lucko/spark/lib/protobuf/$Field"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"
import {$TypeOrBuilder, $TypeOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$TypeOrBuilder"

export class $Type extends $GeneratedMessageLite<($Type), ($Type$Builder)> implements $TypeOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "FIELDS_FIELD_NUMBER": integer
static readonly "ONEOFS_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer
static readonly "SOURCE_CONTEXT_FIELD_NUMBER": integer
static readonly "SYNTAX_FIELD_NUMBER": integer


public "getFieldsCount"(): integer
public "getOneofsList"(): $List<(string)>
public "getOneofsBytes"(arg0: integer): $ByteString
public "getOneofs"(arg0: integer): string
public "getFieldsList"(): $List<($Field)>
public "getOneofsCount"(): integer
public "getName"(): string
public "getFields"(arg0: integer): $Field
public static "parser"(): $Parser<($Type)>
public static "newBuilder"(): $Type$Builder
public static "newBuilder"(arg0: $Type$Type): $Type$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Type
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Type
public "getSyntax"(): $Syntax
public static "getDefaultInstance"(): $Type
public "getOptions"(arg0: integer): $Option
public "getNameBytes"(): $ByteString
public "getSourceContext"(): $SourceContext
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "hasSourceContext"(): boolean
public "getSyntaxValue"(): integer
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public static "parseFrom"(arg0: (byte)[]): $Type
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Type
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Type
public static "parseFrom"(arg0: $CodedInputStream$Type): $Type
public static "parseFrom"(arg0: $InputStream$Type): $Type
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Type
public static "parseFrom"(arg0: $ByteBuffer$Type): $Type
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Type
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Type
public static "parseFrom"(arg0: $ByteString$Type): $Type
public "getFieldsOrBuilder"(arg0: integer): $FieldOrBuilder
public "getFieldsOrBuilderList"(): $List<(any)>
get "fieldsCount"(): integer
get "oneofsList"(): $List<(string)>
get "fieldsList"(): $List<($Field)>
get "oneofsCount"(): integer
get "name"(): string
get "syntax"(): $Syntax
get "defaultInstance"(): $Type
get "nameBytes"(): $ByteString
get "sourceContext"(): $SourceContext
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
get "optionsOrBuilderList"(): $List<(any)>
get "fieldsOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Type$Type = ($Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Type_ = $Type$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnmodifiableLazyStringList" {
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractList, $AbstractList$Type} from "packages/java/util/$AbstractList"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$LazyStringList, $LazyStringList$Type} from "packages/me/lucko/spark/lib/protobuf/$LazyStringList"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $UnmodifiableLazyStringList extends $AbstractList<(string)> implements $LazyStringList, $RandomAccess {

constructor(arg0: $LazyStringList$Type)

public "getUnderlyingElements"(): $List<(any)>
public "getUnmodifiableView"(): $LazyStringList
public "add"(arg0: $ByteString$Type): void
public "add"(arg0: (byte)[]): void
public "get"(arg0: integer): string
public "size"(): integer
public "iterator"(): $Iterator<(string)>
public "set"(arg0: integer, arg1: (byte)[]): void
public "set"(arg0: integer, arg1: $ByteString$Type): void
public "listIterator"(arg0: integer): $ListIterator<(string)>
public "getRaw"(arg0: integer): any
public "getByteArray"(arg0: integer): (byte)[]
public "mergeFrom"(arg0: $LazyStringList$Type): void
public "asByteStringList"(): $List<($ByteString)>
public "getByteString"(arg0: integer): $ByteString
public "asByteArrayList"(): $List<((byte)[])>
public "addAllByteString"(arg0: $Collection$Type<(any)>): boolean
public "addAllByteArray"(arg0: $Collection$Type<((byte)[])>): boolean
public "remove"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(string)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string): $List<(string)>
public static "of"<E>(arg0: string): $List<(string)>
public static "of"<E>(): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string): $List<(string)>
public static "of"<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string): $List<(string)>
public static "of"<E>(...arg0: (string)[]): $List<(string)>
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "underlyingElements"(): $List<(any)>
get "unmodifiableView"(): $LazyStringList
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnmodifiableLazyStringList$Type = ($UnmodifiableLazyStringList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnmodifiableLazyStringList_ = $UnmodifiableLazyStringList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$TranslationRegistry" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$MessageFormat, $MessageFormat$Type} from "packages/java/text/$MessageFormat"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Translator, $Translator$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translator"
import {$ResourceBundle, $ResourceBundle$Type} from "packages/java/util/$ResourceBundle"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $TranslationRegistry extends $Translator {

 "contains"(key: string): boolean
 "register"(key: string, locale: $Locale$Type, format: $MessageFormat$Type): void
 "unregister"(key: string): void
 "defaultLocale"(locale: $Locale$Type): void
 "registerAll"(locale: $Locale$Type, path: $Path$Type, escapeSingleQuotes: boolean): void
 "registerAll"(locale: $Locale$Type, keys: $Set$Type<(string)>, arg2: $Function$Type<(string), ($MessageFormat$Type)>): void
 "registerAll"(locale: $Locale$Type, formats: $Map$Type<(string), ($MessageFormat$Type)>): void
 "registerAll"(locale: $Locale$Type, bundle: $ResourceBundle$Type, escapeSingleQuotes: boolean): void
 "translate"(key: string, locale: $Locale$Type): $MessageFormat
 "name"(): $Key
}

export namespace $TranslationRegistry {
const SINGLE_QUOTE_PATTERN: $Pattern
function create(name: $Key$Type): $TranslationRegistry
function parseLocale(string: string): $Locale
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslationRegistry$Type = ($TranslationRegistry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslationRegistry_ = $TranslationRegistry$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldInfo" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$FieldType, $FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldType"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$OneofInfo, $OneofInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$OneofInfo"
import {$FieldInfo$Builder, $FieldInfo$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldInfo$Builder"

export class $FieldInfo implements $Comparable<($FieldInfo)> {


public "getMessageFieldClass"(): $Class<(any)>
public "compareTo"(arg0: $FieldInfo$Type): integer
public "getField"(): $Field
public "getType"(): $FieldType
public static "newBuilder"(): $FieldInfo$Builder
public "getFieldNumber"(): integer
public "isRequired"(): boolean
public "getMapDefaultEntry"(): any
public "getOneof"(): $OneofInfo
public "getPresenceField"(): $Field
public "getPresenceMask"(): integer
public "getCachedSizeField"(): $Field
public "isEnforceUtf8"(): boolean
public "getEnumVerifier"(): $Internal$EnumVerifier
public static "forField"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: boolean): $FieldInfo
public static "forPackedField"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Field$Type): $FieldInfo
public "getListElementType"(): $Class<(any)>
public "getOneofStoredType"(): $Class<(any)>
public static "forMapField"(arg0: $Field$Type, arg1: integer, arg2: any, arg3: $Internal$EnumVerifier$Type): $FieldInfo
public static "forProto2OptionalField"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Field$Type, arg4: integer, arg5: boolean, arg6: $Internal$EnumVerifier$Type): $FieldInfo
public static "forOneofMemberField"(arg0: integer, arg1: $FieldType$Type, arg2: $OneofInfo$Type, arg3: $Class$Type<(any)>, arg4: boolean, arg5: $Internal$EnumVerifier$Type): $FieldInfo
public static "forPackedFieldWithEnumVerifier"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Internal$EnumVerifier$Type, arg4: $Field$Type): $FieldInfo
public static "forRepeatedMessageField"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Class$Type<(any)>): $FieldInfo
public static "forFieldWithEnumVerifier"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Internal$EnumVerifier$Type): $FieldInfo
public static "forProto2RequiredField"(arg0: $Field$Type, arg1: integer, arg2: $FieldType$Type, arg3: $Field$Type, arg4: integer, arg5: boolean, arg6: $Internal$EnumVerifier$Type): $FieldInfo
get "messageFieldClass"(): $Class<(any)>
get "field"(): $Field
get "type"(): $FieldType
get "fieldNumber"(): integer
get "required"(): boolean
get "mapDefaultEntry"(): any
get "oneof"(): $OneofInfo
get "presenceField"(): $Field
get "presenceMask"(): integer
get "cachedSizeField"(): $Field
get "enforceUtf8"(): boolean
get "enumVerifier"(): $Internal$EnumVerifier
get "listElementType"(): $Class<(any)>
get "oneofStoredType"(): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldInfo$Type = ($FieldInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldInfo_ = $FieldInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"

/**
 * 
 * @deprecated
 */
export interface $Buildable$Builder<R> extends $AbstractBuilder<(R)> {

 "build"(): R

(): R
}

export namespace $Buildable$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Buildable$Builder$Type<R> = ($Buildable$Builder<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Buildable$Builder_<R> = $Buildable$Builder$Type<(R)>;
}}
declare module "packages/me/lucko/spark/common/sampler/source/$SourceMetadata" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata"

export class $SourceMetadata {

constructor(arg0: string, arg1: string, arg2: string)

public "getName"(): string
public "getVersion"(): string
public "toProto"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public static "gather"<T>(arg0: $Collection$Type<(T)>, arg1: $Function$Type<(any), (string)>, arg2: $Function$Type<(any), (string)>, arg3: $Function$Type<(any), (string)>): $List<($SourceMetadata)>
public "getAuthor"(): string
get "name"(): string
get "version"(): string
get "author"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceMetadata$Type = ($SourceMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceMetadata_ = $SourceMetadata$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$StackTrace" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $JfrReader$StackTrace {
readonly "methods": (long)[]
readonly "types": (byte)[]
readonly "locations": (integer)[]

constructor(arg0: (long)[], arg1: (byte)[], arg2: (integer)[])

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$StackTrace$Type = ($JfrReader$StackTrace);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$StackTrace_ = $JfrReader$StackTrace$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$TypePath" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TypePath {
static readonly "ARRAY_ELEMENT": integer
static readonly "INNER_TYPE": integer
static readonly "WILDCARD_BOUND": integer
static readonly "TYPE_ARGUMENT": integer


public "toString"(): string
public "getLength"(): integer
public static "fromString"(arg0: string): $TypePath
public "getStep"(arg0: integer): integer
public "getStepArgument"(arg0: integer): integer
get "length"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypePath$Type = ($TypePath);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypePath_ = $TypePath$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$ShowEntitySerializer" {
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"
import {$HoverEvent$ShowEntity, $HoverEvent$ShowEntity$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent$ShowEntity"

export class $ShowEntitySerializer extends $TypeAdapter<($HoverEvent$ShowEntity)> {


public "write"(out: $JsonWriter$Type, value: $HoverEvent$ShowEntity$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShowEntitySerializer$Type = ($ShowEntitySerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShowEntitySerializer_ = $ShowEntitySerializer$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues$Builder" {
import {$SparkProtos$RollingAverageValuesOrBuilder, $SparkProtos$RollingAverageValuesOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValuesOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"

export class $SparkProtos$RollingAverageValues$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$RollingAverageValues), ($SparkProtos$RollingAverageValues$Builder)> implements $SparkProtos$RollingAverageValuesOrBuilder {


public "getMin"(): double
public "getMax"(): double
public "setMin"(arg0: double): $SparkProtos$RollingAverageValues$Builder
public "setMax"(arg0: double): $SparkProtos$RollingAverageValues$Builder
public "setPercentile95"(arg0: double): $SparkProtos$RollingAverageValues$Builder
public "setMedian"(arg0: double): $SparkProtos$RollingAverageValues$Builder
public "setMean"(arg0: double): $SparkProtos$RollingAverageValues$Builder
public "getMean"(): double
public "getMedian"(): double
public "clearMax"(): $SparkProtos$RollingAverageValues$Builder
public "clearPercentile95"(): $SparkProtos$RollingAverageValues$Builder
public "clearMin"(): $SparkProtos$RollingAverageValues$Builder
public "clearMean"(): $SparkProtos$RollingAverageValues$Builder
public "clearMedian"(): $SparkProtos$RollingAverageValues$Builder
public "getPercentile95"(): double
get "min"(): double
get "max"(): double
set "min"(value: double)
set "max"(value: double)
set "percentile95"(value: double)
set "median"(value: double)
set "mean"(value: double)
get "mean"(): double
get "median"(): double
get "percentile95"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$RollingAverageValues$Builder$Type = ($SparkProtos$RollingAverageValues$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$RollingAverageValues$Builder_ = $SparkProtos$RollingAverageValues$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper" {
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder, $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder"

export class $SparkSamplerProtos$SamplerMetadata$ThreadDumper extends $GeneratedMessageLite<($SparkSamplerProtos$SamplerMetadata$ThreadDumper), ($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder)> implements $SparkSamplerProtos$SamplerMetadata$ThreadDumperOrBuilder {
static readonly "TYPE_FIELD_NUMBER": integer
static readonly "IDS_FIELD_NUMBER": integer
static readonly "PATTERNS_FIELD_NUMBER": integer


public "getIdsList"(): $List<(long)>
public "getPatternsList"(): $List<(string)>
public "getPatternsBytes"(arg0: integer): $ByteString
public "getIdsCount"(): integer
public "getPatternsCount"(): integer
public "getType"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
public static "parser"(): $Parser<($SparkSamplerProtos$SamplerMetadata$ThreadDumper)>
public static "newBuilder"(arg0: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public static "newBuilder"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "getDefaultInstance"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public "getIds"(arg0: integer): long
public "getTypeValue"(): integer
public "getPatterns"(arg0: integer): string
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
get "idsList"(): $List<(long)>
get "patternsList"(): $List<(string)>
get "idsCount"(): integer
get "patternsCount"(): integer
get "type"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
get "defaultInstance"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
get "typeValue"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type = ($SparkSamplerProtos$SamplerMetadata$ThreadDumper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper_ = $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$PlatformStatistics$Ping$Builder, $SparkProtos$PlatformStatistics$Ping$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$SparkProtos$PlatformStatistics$PingOrBuilder, $SparkProtos$PlatformStatistics$PingOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$PingOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$PlatformStatistics$Ping extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Ping), ($SparkProtos$PlatformStatistics$Ping$Builder)> implements $SparkProtos$PlatformStatistics$PingOrBuilder {
static readonly "LAST15M_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Ping)>
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Ping$Builder
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Ping$Type): $SparkProtos$PlatformStatistics$Ping$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Ping
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Ping
public "getLast15M"(): $SparkProtos$RollingAverageValues
public "hasLast15M"(): boolean
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Ping
get "last15M"(): $SparkProtos$RollingAverageValues
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Ping$Type = ($SparkProtos$PlatformStatistics$Ping);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Ping_ = $SparkProtos$PlatformStatistics$Ping$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$DoubleList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$DoubleList extends $Internal$ProtobufList<(double)> {

 "getDouble"(arg0: integer): double
 "setDouble"(arg0: integer, arg1: double): double
 "addDouble"(arg0: double): void
 "mutableCopyWithCapacity"(arg0: integer): $Internal$DoubleList
 "makeImmutable"(): void
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: double): void
 "add"(arg0: double): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(double)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(double)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(double)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(double)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: double): double
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(double)>
 "listIterator"(): $ListIterator<(double)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(double)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(double)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$DoubleList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
function of<E>(arg0: double, arg1: double): $List<(double)>
function of<E>(arg0: double): $List<(double)>
function of<E>(): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
function of<E>(...arg0: (double)[]): $List<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$DoubleList$Type = ($Internal$DoubleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$DoubleList_ = $Internal$DoubleList$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$SparkSamplerProtos$SamplerMetadataOrBuilder, $SparkSamplerProtos$SamplerMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadataOrBuilder"
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkSamplerProtos$SamplerMetadata$SamplerMode, $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SamplerMode"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper"
import {$SparkSamplerProtos$SamplerMetadata$Builder, $SparkSamplerProtos$SamplerMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkSamplerProtos$SamplerMetadata extends $GeneratedMessageLite<($SparkSamplerProtos$SamplerMetadata), ($SparkSamplerProtos$SamplerMetadata$Builder)> implements $SparkSamplerProtos$SamplerMetadataOrBuilder {
static readonly "CREATOR_FIELD_NUMBER": integer
static readonly "START_TIME_FIELD_NUMBER": integer
static readonly "INTERVAL_FIELD_NUMBER": integer
static readonly "THREAD_DUMPER_FIELD_NUMBER": integer
static readonly "DATA_AGGREGATOR_FIELD_NUMBER": integer
static readonly "COMMENT_FIELD_NUMBER": integer
static readonly "PLATFORM_METADATA_FIELD_NUMBER": integer
static readonly "PLATFORM_STATISTICS_FIELD_NUMBER": integer
static readonly "SYSTEM_STATISTICS_FIELD_NUMBER": integer
static readonly "SERVER_CONFIGURATIONS_FIELD_NUMBER": integer
static readonly "END_TIME_FIELD_NUMBER": integer
static readonly "NUMBER_OF_TICKS_FIELD_NUMBER": integer
static readonly "SOURCES_FIELD_NUMBER": integer
static readonly "EXTRA_PLATFORM_METADATA_FIELD_NUMBER": integer
static readonly "SAMPLER_MODE_FIELD_NUMBER": integer


public "getSourcesOrThrow"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public "containsSources"(arg0: string): boolean
public "getSourcesCount"(): integer
public "getSamplerMode"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
public "getSourcesMap"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
public static "parser"(): $Parser<($SparkSamplerProtos$SamplerMetadata)>
public "getComment"(): string
public static "newBuilder"(): $SparkSamplerProtos$SamplerMetadata$Builder
public static "newBuilder"(arg0: $SparkSamplerProtos$SamplerMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata
public static "getDefaultInstance"(): $SparkSamplerProtos$SamplerMetadata
public "getStartTime"(): long
public "getInterval"(): integer
public "getCreator"(): $SparkProtos$CommandSenderMetadata
public "getEndTime"(): long
/**
 * 
 * @deprecated
 */
public "getSources"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
public "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
public "getSystemStatistics"(): $SparkProtos$SystemStatistics
public "getNumberOfTicks"(): integer
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SamplerMetadata
public "getServerConfigurationsOrDefault"(arg0: string, arg1: string): string
public "hasPlatformMetadata"(): boolean
/**
 * 
 * @deprecated
 */
public "getServerConfigurations"(): $Map<(string), (string)>
public "getServerConfigurationsOrThrow"(arg0: string): string
public "getServerConfigurationsMap"(): $Map<(string), (string)>
public "containsServerConfigurations"(arg0: string): boolean
public "hasSystemStatistics"(): boolean
public "getExtraPlatformMetadataOrDefault"(arg0: string, arg1: string): string
public "hasPlatformStatistics"(): boolean
public "getExtraPlatformMetadataCount"(): integer
/**
 * 
 * @deprecated
 */
public "getExtraPlatformMetadata"(): $Map<(string), (string)>
public "getExtraPlatformMetadataOrThrow"(arg0: string): string
public "getSourcesOrDefault"(arg0: string, arg1: $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public "getServerConfigurationsCount"(): integer
public "containsExtraPlatformMetadata"(arg0: string): boolean
public "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
public "getExtraPlatformMetadataMap"(): $Map<(string), (string)>
public "getSamplerModeValue"(): integer
public "hasThreadDumper"(): boolean
public "hasCreator"(): boolean
public "getThreadDumper"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public "hasDataAggregator"(): boolean
public "getDataAggregator"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public "getCommentBytes"(): $ByteString
get "sourcesCount"(): integer
get "samplerMode"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
get "sourcesMap"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
get "comment"(): string
get "defaultInstance"(): $SparkSamplerProtos$SamplerMetadata
get "startTime"(): long
get "interval"(): integer
get "creator"(): $SparkProtos$CommandSenderMetadata
get "endTime"(): long
get "sources"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
get "platformStatistics"(): $SparkProtos$PlatformStatistics
get "systemStatistics"(): $SparkProtos$SystemStatistics
get "numberOfTicks"(): integer
get "serverConfigurations"(): $Map<(string), (string)>
get "serverConfigurationsMap"(): $Map<(string), (string)>
get "extraPlatformMetadataCount"(): integer
get "extraPlatformMetadata"(): $Map<(string), (string)>
get "serverConfigurationsCount"(): integer
get "platformMetadata"(): $SparkProtos$PlatformMetadata
get "extraPlatformMetadataMap"(): $Map<(string), (string)>
get "samplerModeValue"(): integer
get "threadDumper"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
get "dataAggregator"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "commentBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$Type = ($SparkSamplerProtos$SamplerMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata_ = $SparkSamplerProtos$SamplerMetadata$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Timestamp" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$TimestampOrBuilder, $TimestampOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$TimestampOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Timestamp$Builder, $Timestamp$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Timestamp$Builder"

export class $Timestamp extends $GeneratedMessageLite<($Timestamp), ($Timestamp$Builder)> implements $TimestampOrBuilder {
static readonly "SECONDS_FIELD_NUMBER": integer
static readonly "NANOS_FIELD_NUMBER": integer


public "getSeconds"(): long
public static "parser"(): $Parser<($Timestamp)>
public static "newBuilder"(): $Timestamp$Builder
public static "newBuilder"(arg0: $Timestamp$Type): $Timestamp$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Timestamp
public static "getDefaultInstance"(): $Timestamp
public "getNanos"(): integer
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseFrom"(arg0: $ByteBuffer$Type): $Timestamp
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseFrom"(arg0: (byte)[]): $Timestamp
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseFrom"(arg0: $InputStream$Type): $Timestamp
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Timestamp
public static "parseFrom"(arg0: $CodedInputStream$Type): $Timestamp
public static "parseFrom"(arg0: $ByteString$Type): $Timestamp
get "seconds"(): long
get "defaultInstance"(): $Timestamp
get "nanos"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Timestamp$Type = ($Timestamp);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Timestamp_ = $Timestamp$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$WindowStatisticsCollector$ExplicitTickCounter, $WindowStatisticsCollector$ExplicitTickCounter$Type} from "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$ExplicitTickCounter"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$SparkProtos$WindowStatistics, $SparkProtos$WindowStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $WindowStatisticsCollector {

constructor(arg0: $SparkPlatform$Type)

public "ensureHasStatisticsForAllWindows"(arg0: (integer)[]): void
public "recordWindowStartTime"(arg0: integer): void
public "startCountingTicksExplicit"(arg0: $TickHook$Type): $WindowStatisticsCollector$ExplicitTickCounter
public "stop"(): void
public "export"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
public "getTotalTicks"(): integer
public "measureNow"(arg0: integer): void
public "startCountingTicks"(arg0: $TickHook$Type): void
public "pruneStatistics"(arg0: $IntPredicate$Type): void
get "totalTicks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowStatisticsCollector$Type = ($WindowStatisticsCollector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowStatisticsCollector_ = $WindowStatisticsCollector$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EnumValue$Builder" {
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$EnumValueOrBuilder, $EnumValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValueOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$EnumValue, $EnumValue$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $EnumValue$Builder extends $GeneratedMessageLite$Builder<($EnumValue), ($EnumValue$Builder)> implements $EnumValueOrBuilder {


public "clearNumber"(): $EnumValue$Builder
public "getName"(): string
public "setName"(arg0: string): $EnumValue$Builder
public "getNumber"(): integer
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: integer, arg1: $Option$Type): $EnumValue$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $EnumValue$Builder
public "addOptions"(arg0: $Option$Builder$Type): $EnumValue$Builder
public "addOptions"(arg0: $Option$Type): $EnumValue$Builder
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $EnumValue$Builder
public "clearOptions"(): $EnumValue$Builder
public "removeOptions"(arg0: integer): $EnumValue$Builder
public "setNameBytes"(arg0: $ByteString$Type): $EnumValue$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $EnumValue$Builder
public "setNumber"(arg0: integer): $EnumValue$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $EnumValue$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $EnumValue$Builder
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
get "name"(): string
set "name"(value: string)
get "number"(): integer
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
set "number"(value: integer)
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumValue$Builder$Type = ($EnumValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumValue$Builder_ = $EnumValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/forge/plugin/$ForgeServerSparkPlugin" {
import {$Suggestions, $Suggestions$Type} from "packages/com/mojang/brigadier/suggestion/$Suggestions"
import {$CommandSourceStack, $CommandSourceStack$Type} from "packages/net/minecraft/commands/$CommandSourceStack"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$RegisterCommandsEvent, $RegisterCommandsEvent$Type} from "packages/net/minecraftforge/event/$RegisterCommandsEvent"
import {$PlatformInfo, $PlatformInfo$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo"
import {$ServerConfigProvider, $ServerConfigProvider$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ServerConfigProvider"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$MinecraftServer, $MinecraftServer$Type} from "packages/net/minecraft/server/$MinecraftServer"
import {$SuggestionsBuilder, $SuggestionsBuilder$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionsBuilder"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$ForgeCommandSender, $ForgeCommandSender$Type} from "packages/me/lucko/spark/forge/$ForgeCommandSender"
import {$CommandContext, $CommandContext$Type} from "packages/com/mojang/brigadier/context/$CommandContext"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"
import {$ForgeSparkPlugin, $ForgeSparkPlugin$Type} from "packages/me/lucko/spark/forge/plugin/$ForgeSparkPlugin"
import {$PermissionGatherEvent$Nodes, $PermissionGatherEvent$Nodes$Type} from "packages/net/minecraftforge/server/permission/events/$PermissionGatherEvent$Nodes"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$ServerStoppingEvent, $ServerStoppingEvent$Type} from "packages/net/minecraftforge/event/server/$ServerStoppingEvent"
import {$SuggestionProvider, $SuggestionProvider$Type} from "packages/com/mojang/brigadier/suggestion/$SuggestionProvider"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$Command, $Command$Type} from "packages/com/mojang/brigadier/$Command"
import {$ForgeSparkMod, $ForgeSparkMod$Type} from "packages/me/lucko/spark/forge/$ForgeSparkMod"
import {$ServerAboutToStartEvent, $ServerAboutToStartEvent$Type} from "packages/net/minecraftforge/event/server/$ServerAboutToStartEvent"
import {$PlayerPingProvider, $PlayerPingProvider$Type} from "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider"

export class $ForgeServerSparkPlugin extends $ForgeSparkPlugin implements $Command<($CommandSourceStack)>, $SuggestionProvider<($CommandSourceStack)> {

constructor(arg0: $ForgeSparkMod$Type, arg1: $MinecraftServer$Type)

public "run"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>): integer
public static "register"(arg0: $ForgeSparkMod$Type, arg1: $ServerAboutToStartEvent$Type): void
public "enable"(): void
public "onCommandRegister"(arg0: $RegisterCommandsEvent$Type): void
public "createTickHook"(): $TickHook
public "createTickReporter"(): $TickReporter
public "executeSync"(arg0: $Runnable$Type): void
public "getPlatformInfo"(): $PlatformInfo
public "getCommandSenders"(): $Stream<($ForgeCommandSender)>
public "createExtraMetadataProvider"(): $MetadataProvider
public "getDefaultThreadDumper"(): $ThreadDumper
public "createServerConfigProvider"(): $ServerConfigProvider
public "createPlayerPingProvider"(): $PlayerPingProvider
public "createWorldInfoProvider"(): $WorldInfoProvider
public "hasPermission"(arg0: $CommandSource$Type, arg1: string): boolean
public "onPermissionGather"(arg0: $PermissionGatherEvent$Nodes$Type): void
public "onDisable"(arg0: $ServerStoppingEvent$Type): void
public "disable"(): void
public "getSuggestions"(arg0: $CommandContext$Type<($CommandSourceStack$Type)>, arg1: $SuggestionsBuilder$Type): $CompletableFuture<($Suggestions)>
public "getCommandName"(): string
get "platformInfo"(): $PlatformInfo
get "commandSenders"(): $Stream<($ForgeCommandSender)>
get "defaultThreadDumper"(): $ThreadDumper
get "commandName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeServerSparkPlugin$Type = ($ForgeServerSparkPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeServerSparkPlugin_ = $ForgeServerSparkPlugin$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$FieldVisitor" {
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $FieldVisitor {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $FieldVisitor$Type)

public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldVisitor$Type = ($FieldVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldVisitor_ = $FieldVisitor$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketServerFactory" {
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$WebSocketImpl, $WebSocketImpl$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl"
import {$List, $List$Type} from "packages/java/util/$List"
import {$WebSocketFactory, $WebSocketFactory$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketFactory"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$WebSocketAdapter, $WebSocketAdapter$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketAdapter"

export interface $WebSocketServerFactory extends $WebSocketFactory {

 "close"(): void
 "createWebSocket"(arg0: $WebSocketAdapter$Type, arg1: $Draft$Type): $WebSocketImpl
 "createWebSocket"(arg0: $WebSocketAdapter$Type, arg1: $List$Type<($Draft$Type)>): $WebSocketImpl
 "wrapChannel"(arg0: $SocketChannel$Type, arg1: $SelectionKey$Type): $ByteChannel
}

export namespace $WebSocketServerFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketServerFactory$Type = ($WebSocketServerFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketServerFactory_ = $WebSocketServerFactory$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$AsyncWorldInfoProvider" {
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$WorldInfoProvider$ChunksResult, $WorldInfoProvider$ChunksResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$ChunksResult"
import {$WorldInfoProvider$CountsResult, $WorldInfoProvider$CountsResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$CountsResult"

export class $AsyncWorldInfoProvider {

constructor(arg0: $SparkPlatform$Type, arg1: $WorldInfoProvider$Type)

public "pollCounts"(): $CompletableFuture<($WorldInfoProvider$CountsResult)>
public "pollChunks"(): $CompletableFuture<($WorldInfoProvider$ChunksResult<(any)>)>
public "getCounts"(): $WorldInfoProvider$CountsResult
public "getChunks"(): $WorldInfoProvider$ChunksResult<(any)>
get "counts"(): $WorldInfoProvider$CountsResult
get "chunks"(): $WorldInfoProvider$ChunksResult<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncWorldInfoProvider$Type = ($AsyncWorldInfoProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncWorldInfoProvider_ = $AsyncWorldInfoProvider$Type;
}}
declare module "packages/me/lucko/spark/common/$SparkPlugin" {
import {$TickStatistics, $TickStatistics$Type} from "packages/me/lucko/spark/common/monitor/tick/$TickStatistics"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$Spark, $Spark$Type} from "packages/me/lucko/spark/api/$Spark"
import {$PlatformInfo, $PlatformInfo$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo"
import {$ServerConfigProvider, $ServerConfigProvider$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ServerConfigProvider"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Level, $Level$Type} from "packages/java/util/logging/$Level"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$SourceMetadata, $SourceMetadata$Type} from "packages/me/lucko/spark/common/sampler/source/$SourceMetadata"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$PlayerPingProvider, $PlayerPingProvider$Type} from "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ClassSourceLookup, $ClassSourceLookup$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"

export interface $SparkPlugin {

 "log"(arg0: $Level$Type, arg1: string): void
 "getVersion"(): string
 "getKnownSources"(): $Collection<($SourceMetadata)>
 "executeAsync"(arg0: $Runnable$Type): void
 "getPluginDirectory"(): $Path
 "createTickHook"(): $TickHook
 "createTickReporter"(): $TickReporter
 "registerApi"(arg0: $Spark$Type): void
 "executeSync"(arg0: $Runnable$Type): void
 "getPlatformInfo"(): $PlatformInfo
 "getCommandSenders"(): $Stream<(any)>
 "createExtraMetadataProvider"(): $MetadataProvider
 "getDefaultThreadDumper"(): $ThreadDumper
 "createServerConfigProvider"(): $ServerConfigProvider
 "createTickStatistics"(): $TickStatistics
 "createPlayerPingProvider"(): $PlayerPingProvider
 "createWorldInfoProvider"(): $WorldInfoProvider
 "createClassSourceLookup"(): $ClassSourceLookup
 "getCommandName"(): string
}

export namespace $SparkPlugin {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkPlugin$Type = ($SparkPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkPlugin_ = $SparkPlugin$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnectOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkWebSocketProtos$ClientConnectOrBuilder extends $MessageLiteOrBuilder {

 "getDescription"(): string
 "getClientId"(): string
 "getClientIdBytes"(): $ByteString
 "getDescriptionBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ClientConnectOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ClientConnectOrBuilder$Type = ($SparkWebSocketProtos$ClientConnectOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ClientConnectOrBuilder_ = $SparkWebSocketProtos$ClientConnectOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/asyncprofiler/$AsyncProfiler" {
import {$Counter, $Counter$Type} from "packages/me/lucko/spark/lib/asyncprofiler/$Counter"
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"
import {$AsyncProfilerMXBean, $AsyncProfilerMXBean$Type} from "packages/me/lucko/spark/lib/asyncprofiler/$AsyncProfilerMXBean"

export class $AsyncProfiler implements $AsyncProfilerMXBean {


public "start"(arg0: string, arg1: long): void
public static "getInstance"(arg0: string): $AsyncProfiler
public static "getInstance"(): $AsyncProfiler
public "execute"(arg0: string): string
public "resume"(arg0: string, arg1: long): void
public "stop"(): void
public "getVersion"(): string
public "getSamples"(): long
public "addThread"(arg0: $Thread$Type): void
public "dumpTraces"(arg0: integer): string
public "dumpCollapsed"(arg0: $Counter$Type): string
public "dumpFlat"(arg0: integer): string
public "removeThread"(arg0: $Thread$Type): void
get "instance"(): $AsyncProfiler
get "version"(): string
get "samples"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncProfiler$Type = ($AsyncProfiler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncProfiler_ = $AsyncProfiler$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$ChatTypeImpl" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound"
import {$ChatType, $ChatType$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"

export class $ChatTypeImpl implements $ChatType {


public "toString"(): string
public "key"(): $Key
public "bind"(name: $ComponentLike$Type, target: $ComponentLike$Type): $ChatType$Bound
public "bind"(name: $ComponentLike$Type): $ChatType$Bound
public "examinableProperties"(): $Stream<(any)>
public static "chatType"(key: $Keyed$Type): $ChatType
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChatTypeImpl$Type = ($ChatTypeImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChatTypeImpl_ = $ChatTypeImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Android" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Android {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Android$Type = ($Android);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Android_ = $Android$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkSamplerProtos$ThreadNode, $SparkSamplerProtos$ThreadNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$SamplerDataOrBuilder, $SparkSamplerProtos$SamplerDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerDataOrBuilder"
import {$SparkSamplerProtos$SamplerData$Builder, $SparkSamplerProtos$SamplerData$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData$Builder"
import {$SparkSamplerProtos$ThreadNodeOrBuilder, $SparkSamplerProtos$ThreadNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNodeOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$SparkSamplerProtos$SamplerMetadata, $SparkSamplerProtos$SamplerMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$WindowStatistics, $SparkProtos$WindowStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkSamplerProtos$SamplerData extends $GeneratedMessageLite<($SparkSamplerProtos$SamplerData), ($SparkSamplerProtos$SamplerData$Builder)> implements $SparkSamplerProtos$SamplerDataOrBuilder {
static readonly "METADATA_FIELD_NUMBER": integer
static readonly "THREADS_FIELD_NUMBER": integer
static readonly "CLASS_SOURCES_FIELD_NUMBER": integer
static readonly "METHOD_SOURCES_FIELD_NUMBER": integer
static readonly "LINE_SOURCES_FIELD_NUMBER": integer
static readonly "TIME_WINDOWS_FIELD_NUMBER": integer
static readonly "TIME_WINDOW_STATISTICS_FIELD_NUMBER": integer
static readonly "CHANNEL_INFO_FIELD_NUMBER": integer


public "getThreads"(arg0: integer): $SparkSamplerProtos$ThreadNode
public static "parser"(): $Parser<($SparkSamplerProtos$SamplerData)>
public static "newBuilder"(): $SparkSamplerProtos$SamplerData$Builder
public static "newBuilder"(arg0: $SparkSamplerProtos$SamplerData$Type): $SparkSamplerProtos$SamplerData$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerData
public "getClassSourcesMap"(): $Map<(string), (string)>
public "getThreadsCount"(): integer
public "getThreadsList"(): $List<($SparkSamplerProtos$ThreadNode)>
/**
 * 
 * @deprecated
 */
public "getMethodSources"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
public "getClassSources"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
public "getLineSources"(): $Map<(string), (string)>
public "getLineSourcesMap"(): $Map<(string), (string)>
public "getTimeWindows"(arg0: integer): integer
public "getChannelInfo"(): $SparkSamplerProtos$SocketChannelInfo
public "hasChannelInfo"(): boolean
public "getTimeWindowsList"(): $List<(integer)>
public static "getDefaultInstance"(): $SparkSamplerProtos$SamplerData
public "hasMetadata"(): boolean
public "getMethodSourcesOrDefault"(arg0: string, arg1: string): string
public "getLineSourcesCount"(): integer
public "getLineSourcesOrDefault"(arg0: string, arg1: string): string
public "getTimeWindowStatisticsOrDefault"(arg0: integer, arg1: $SparkProtos$WindowStatistics$Type): $SparkProtos$WindowStatistics
public "containsLineSources"(arg0: string): boolean
public "getMethodSourcesCount"(): integer
public "getThreadsOrBuilder"(arg0: integer): $SparkSamplerProtos$ThreadNodeOrBuilder
public "containsMethodSources"(arg0: string): boolean
public "getTimeWindowStatisticsCount"(): integer
public "getMethodSourcesMap"(): $Map<(string), (string)>
public "getTimeWindowStatisticsMap"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
public "getClassSourcesOrDefault"(arg0: string, arg1: string): string
public "getMethodSourcesOrThrow"(arg0: string): string
public "getTimeWindowsCount"(): integer
public "containsTimeWindowStatistics"(arg0: integer): boolean
public "getThreadsOrBuilderList"(): $List<(any)>
public "containsClassSources"(arg0: string): boolean
public "getClassSourcesCount"(): integer
public "getClassSourcesOrThrow"(arg0: string): string
public "getLineSourcesOrThrow"(arg0: string): string
/**
 * 
 * @deprecated
 */
public "getTimeWindowStatistics"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
public "getTimeWindowStatisticsOrThrow"(arg0: integer): $SparkProtos$WindowStatistics
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerData
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerData
get "classSourcesMap"(): $Map<(string), (string)>
get "threadsCount"(): integer
get "threadsList"(): $List<($SparkSamplerProtos$ThreadNode)>
get "methodSources"(): $Map<(string), (string)>
get "classSources"(): $Map<(string), (string)>
get "lineSources"(): $Map<(string), (string)>
get "lineSourcesMap"(): $Map<(string), (string)>
get "channelInfo"(): $SparkSamplerProtos$SocketChannelInfo
get "timeWindowsList"(): $List<(integer)>
get "defaultInstance"(): $SparkSamplerProtos$SamplerData
get "lineSourcesCount"(): integer
get "methodSourcesCount"(): integer
get "timeWindowStatisticsCount"(): integer
get "methodSourcesMap"(): $Map<(string), (string)>
get "timeWindowStatisticsMap"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
get "timeWindowsCount"(): integer
get "threadsOrBuilderList"(): $List<(any)>
get "classSourcesCount"(): integer
get "timeWindowStatistics"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
get "metadata"(): $SparkSamplerProtos$SamplerMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerData$Type = ($SparkSamplerProtos$SamplerData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerData_ = $SparkSamplerProtos$SamplerData$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$PlatformStatistics$TpsOrBuilder, $SparkProtos$PlatformStatistics$TpsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$TpsOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$PlatformStatistics$Tps$Builder, $SparkProtos$PlatformStatistics$Tps$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps$Builder"

export class $SparkProtos$PlatformStatistics$Tps extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Tps), ($SparkProtos$PlatformStatistics$Tps$Builder)> implements $SparkProtos$PlatformStatistics$TpsOrBuilder {
static readonly "LAST1M_FIELD_NUMBER": integer
static readonly "LAST5M_FIELD_NUMBER": integer
static readonly "LAST15M_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Tps)>
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Tps$Builder
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Tps$Type): $SparkProtos$PlatformStatistics$Tps$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Tps
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Tps
public "getLast5M"(): double
public "getLast1M"(): double
public "getLast15M"(): double
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Tps
get "last5M"(): double
get "last1M"(): double
get "last15M"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Tps$Type = ($SparkProtos$PlatformStatistics$Tps);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Tps_ = $SparkProtos$PlatformStatistics$Tps$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/chat/$ChatType" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"

export interface $ChatType extends $Examinable, $Keyed {

 "bind"(name: $ComponentLike$Type, target: $ComponentLike$Type): $ChatType$Bound
 "bind"(name: $ComponentLike$Type): $ChatType$Bound
 "examinableProperties"(): $Stream<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "key"(): $Key

(name: $ComponentLike$Type, target: $ComponentLike$Type): $ChatType$Bound
}

export namespace $ChatType {
const CHAT: $ChatType
const SAY_COMMAND: $ChatType
const MSG_COMMAND_INCOMING: $ChatType
const MSG_COMMAND_OUTGOING: $ChatType
const TEAM_MSG_COMMAND_INCOMING: $ChatType
const TEAM_MSG_COMMAND_OUTGOING: $ChatType
const EMOTE_COMMAND: $ChatType
function chatType(key: $Keyed$Type): $ChatType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChatType$Type = ($ChatType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChatType_ = $ChatType$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/$StatisticWindow$TicksPerSecond" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export class $StatisticWindow$TicksPerSecond extends $Enum<($StatisticWindow$TicksPerSecond)> implements $StatisticWindow {
static readonly "SECONDS_5": $StatisticWindow$TicksPerSecond
static readonly "SECONDS_10": $StatisticWindow$TicksPerSecond
static readonly "MINUTES_1": $StatisticWindow$TicksPerSecond
static readonly "MINUTES_5": $StatisticWindow$TicksPerSecond
static readonly "MINUTES_15": $StatisticWindow$TicksPerSecond


public "length"(): $Duration
public static "values"(): ($StatisticWindow$TicksPerSecond)[]
public static "valueOf"(arg0: string): $StatisticWindow$TicksPerSecond
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatisticWindow$TicksPerSecond$Type = (("minutes_5") | ("seconds_5") | ("minutes_1") | ("minutes_15") | ("seconds_10")) | ($StatisticWindow$TicksPerSecond);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatisticWindow$TicksPerSecond_ = $StatisticWindow$TicksPerSecond$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/signature/$SignatureReader" {
import {$SignatureVisitor, $SignatureVisitor$Type} from "packages/me/lucko/spark/lib/asm/signature/$SignatureVisitor"

export class $SignatureReader {

constructor(arg0: string)

public "accept"(arg0: $SignatureVisitor$Type): void
public "acceptType"(arg0: $SignatureVisitor$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignatureReader$Type = ($SignatureReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignatureReader_ = $SignatureReader$Type;
}}
declare module "packages/me/lucko/spark/forge/plugin/$ForgeSparkPlugin" {
import {$TickStatistics, $TickStatistics$Type} from "packages/me/lucko/spark/common/monitor/tick/$TickStatistics"
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$WorldInfoProvider, $WorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider"
import {$CommandSource, $CommandSource$Type} from "packages/net/minecraft/commands/$CommandSource"
import {$Spark, $Spark$Type} from "packages/me/lucko/spark/api/$Spark"
import {$PlatformInfo, $PlatformInfo$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo"
import {$SparkPlugin, $SparkPlugin$Type} from "packages/me/lucko/spark/common/$SparkPlugin"
import {$ServerConfigProvider, $ServerConfigProvider$Type} from "packages/me/lucko/spark/common/platform/serverconfig/$ServerConfigProvider"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Level, $Level$Type} from "packages/java/util/logging/$Level"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"
import {$SourceMetadata, $SourceMetadata$Type} from "packages/me/lucko/spark/common/sampler/source/$SourceMetadata"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$PlayerPingProvider, $PlayerPingProvider$Type} from "packages/me/lucko/spark/common/monitor/ping/$PlayerPingProvider"
import {$ClassSourceLookup, $ClassSourceLookup$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"

export class $ForgeSparkPlugin implements $SparkPlugin {


public "log"(arg0: $Level$Type, arg1: string): void
public "enable"(): void
public "getVersion"(): string
public "getKnownSources"(): $Collection<($SourceMetadata)>
public "executeAsync"(arg0: $Runnable$Type): void
public "getPluginDirectory"(): $Path
public "createClassSourceLookup"(): $ClassSourceLookup
public "hasPermission"(arg0: $CommandSource$Type, arg1: string): boolean
public "disable"(): void
public "createTickHook"(): $TickHook
public "createTickReporter"(): $TickReporter
public "registerApi"(arg0: $Spark$Type): void
public "executeSync"(arg0: $Runnable$Type): void
public "getPlatformInfo"(): $PlatformInfo
public "getCommandSenders"(): $Stream<(any)>
public "createExtraMetadataProvider"(): $MetadataProvider
public "getDefaultThreadDumper"(): $ThreadDumper
public "createServerConfigProvider"(): $ServerConfigProvider
public "createTickStatistics"(): $TickStatistics
public "createPlayerPingProvider"(): $PlayerPingProvider
public "createWorldInfoProvider"(): $WorldInfoProvider
public "getCommandName"(): string
get "version"(): string
get "knownSources"(): $Collection<($SourceMetadata)>
get "pluginDirectory"(): $Path
get "platformInfo"(): $PlatformInfo
get "commandSenders"(): $Stream<(any)>
get "defaultThreadDumper"(): $ThreadDumper
get "commandName"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeSparkPlugin$Type = ($ForgeSparkPlugin);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeSparkPlugin_ = $ForgeSparkPlugin$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $StorageNBTComponent extends $NBTComponent<($StorageNBTComponent), ($StorageNBTComponent$Builder)>, $ScopedComponent<($StorageNBTComponent)> {

 "examinableProperties"(): $Stream<(any)>
 "storage"(storage: $Key$Type): $StorageNBTComponent
 "storage"(): $Key
 "separator"(): $Component
 "separator"(separator: $ComponentLike$Type): $StorageNBTComponent
 "nbtPath"(nbtPath: string): $StorageNBTComponent
 "nbtPath"(): string
 "interpret"(): boolean
 "interpret"(interpret: boolean): $StorageNBTComponent
 "append"(component: $Component$Type): $StorageNBTComponent
 "append"(like: $ComponentLike$Type): $StorageNBTComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $StorageNBTComponent
 "color"(color: $TextColor$Type): $StorageNBTComponent
 "style"(style: $Style$Type): $StorageNBTComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $StorageNBTComponent
 "style"(style: $Style$Builder$Type): $StorageNBTComponent
 "children"(children: $List$Type<(any)>): $StorageNBTComponent
 "mergeStyle"(that: $Component$Type): $StorageNBTComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $StorageNBTComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $StorageNBTComponent
 "colorIfAbsent"(color: $TextColor$Type): $StorageNBTComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $StorageNBTComponent
 "clickEvent"(event: $ClickEvent$Type): $StorageNBTComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $StorageNBTComponent
 "toBuilder"(): $StorageNBTComponent$Builder
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $StorageNBTComponent {
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function configureAndBuild<R, B>(builder: $StorageNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StorageNBTComponent$Type = ($StorageNBTComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StorageNBTComponent_ = $StorageNBTComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BoolValue" {
import {$BoolValue$Builder, $BoolValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$BoolValue$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$BoolValueOrBuilder, $BoolValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$BoolValueOrBuilder"

export class $BoolValue extends $GeneratedMessageLite<($BoolValue), ($BoolValue$Builder)> implements $BoolValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): boolean
public static "of"(arg0: boolean): $BoolValue
public static "parser"(): $Parser<($BoolValue)>
public static "newBuilder"(arg0: $BoolValue$Type): $BoolValue$Builder
public static "newBuilder"(): $BoolValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $BoolValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $BoolValue
public static "getDefaultInstance"(): $BoolValue
public static "parseFrom"(arg0: $ByteString$Type): $BoolValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $BoolValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $BoolValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $BoolValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $BoolValue
public static "parseFrom"(arg0: $InputStream$Type): $BoolValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $BoolValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $BoolValue
public static "parseFrom"(arg0: (byte)[]): $BoolValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $BoolValue
get "value"(): boolean
get "defaultInstance"(): $BoolValue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoolValue$Type = ($BoolValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoolValue_ = $BoolValue$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder" {
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $MessageLiteOrBuilder {

 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $MessageLiteOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageLiteOrBuilder$Type = ($MessageLiteOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageLiteOrBuilder_ = $MessageLiteOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Internal$EnumVerifier {

 "isInRange"(arg0: integer): boolean

(arg0: integer): boolean
}

export namespace $Internal$EnumVerifier {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$EnumVerifier$Type = ($Internal$EnumVerifier);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$EnumVerifier_ = $Internal$EnumVerifier$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer$Builder" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$LegacyComponentSerializer, $LegacyComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$ComponentFlattener, $ComponentFlattener$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener"

export interface $LegacyComponentSerializer$Builder extends $AbstractBuilder<($LegacyComponentSerializer)>, $Buildable$Builder<($LegacyComponentSerializer)> {

 "character"(legacyCharacter: character): $LegacyComponentSerializer$Builder
 "useUnusualXRepeatedCharacterHexFormat"(): $LegacyComponentSerializer$Builder
 "extractUrls"(pattern: $Pattern$Type, style: $Style$Type): $LegacyComponentSerializer$Builder
 "extractUrls"(pattern: $Pattern$Type): $LegacyComponentSerializer$Builder
 "extractUrls"(style: $Style$Type): $LegacyComponentSerializer$Builder
 "extractUrls"(): $LegacyComponentSerializer$Builder
 "hexColors"(): $LegacyComponentSerializer$Builder
 "flattener"(flattener: $ComponentFlattener$Type): $LegacyComponentSerializer$Builder
 "hexCharacter"(legacyHexCharacter: character): $LegacyComponentSerializer$Builder
}

export namespace $LegacyComponentSerializer$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $LegacyComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyComponentSerializer$Builder$Type = ($LegacyComponentSerializer$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyComponentSerializer$Builder_ = $LegacyComponentSerializer$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$SoundImpl" {
import {$Sound$Builder, $Sound$Builder$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Builder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Sound$Type, $Sound$Type$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type"
import {$Sound$Source$Provider, $Sound$Source$Provider$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source$Provider"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OptionalLong, $OptionalLong$Type} from "packages/java/util/$OptionalLong"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Sound, $Sound$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound"

export class $SoundImpl implements $Sound {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "source"(): $Sound$Source
public "seed"(): $OptionalLong
public "examinableProperties"(): $Stream<(any)>
public "pitch"(): float
public "volume"(): float
public "asStop"(): $SoundStop
public "name"(): $Key
public static "sound"(type: $Sound$Type$Type, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
public static "sound"(type: $Supplier$Type<(any)>, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
public static "sound"(name: $Key$Type, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
public static "sound"(configurer: $Consumer$Type<($Sound$Builder$Type)>): $Sound
public static "sound"(existing: $Sound$Type): $Sound$Builder
public static "sound"(): $Sound$Builder
public static "sound"(name: $Key$Type, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
public static "sound"(type: $Supplier$Type<(any)>, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
public static "sound"(type: $Sound$Type$Type, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SoundImpl$Type = ($SoundImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SoundImpl_ = $SoundImpl$Type;
}}
declare module "packages/me/lucko/spark/common/command/sender/$CommandSender$Data" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"

export class $CommandSender$Data {

constructor(arg0: string, arg1: $UUID$Type)

public "getName"(): string
public "isPlayer"(): boolean
public static "deserialize"(arg0: $JsonElement$Type): $CommandSender$Data
public "toProto"(): $SparkProtos$CommandSenderMetadata
public "getUniqueId"(): $UUID
public "serialize"(): $JsonObject
get "name"(): string
get "player"(): boolean
get "uniqueId"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandSender$Data$Type = ($CommandSender$Data);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandSender$Data_ = $CommandSender$Data$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$WorldStatisticsProvider" {
import {$SparkProtos$WorldStatistics, $SparkProtos$WorldStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics"
import {$AsyncWorldInfoProvider, $AsyncWorldInfoProvider$Type} from "packages/me/lucko/spark/common/platform/world/$AsyncWorldInfoProvider"

export class $WorldStatisticsProvider {

constructor(arg0: $AsyncWorldInfoProvider$Type)

public "getWorldStatistics"(): $SparkProtos$WorldStatistics
get "worldStatistics"(): $SparkProtos$WorldStatistics
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldStatisticsProvider$Type = ($WorldStatisticsProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldStatisticsProvider_ = $WorldStatisticsProvider$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$ChunkInfo" {
import {$CountMap, $CountMap$Type} from "packages/me/lucko/spark/common/platform/world/$CountMap"

export interface $ChunkInfo<E> {

 "getZ"(): integer
 "getX"(): integer
 "getEntityCounts"(): $CountMap<(E)>
 "entityTypeName"(arg0: E): string
}

export namespace $ChunkInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ChunkInfo$Type<E> = ($ChunkInfo<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ChunkInfo_<E> = $ChunkInfo$Type<(E)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerDataOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkSamplerProtos$ThreadNode, $SparkSamplerProtos$ThreadNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$SparkSamplerProtos$SamplerMetadata, $SparkSamplerProtos$SamplerMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$WindowStatistics, $SparkProtos$WindowStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WindowStatistics"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SparkSamplerProtos$SamplerDataOrBuilder extends $MessageLiteOrBuilder {

 "getThreads"(arg0: integer): $SparkSamplerProtos$ThreadNode
 "getClassSourcesMap"(): $Map<(string), (string)>
 "getThreadsCount"(): integer
 "getThreadsList"(): $List<($SparkSamplerProtos$ThreadNode)>
/**
 * 
 * @deprecated
 */
 "getMethodSources"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
 "getClassSources"(): $Map<(string), (string)>
/**
 * 
 * @deprecated
 */
 "getLineSources"(): $Map<(string), (string)>
 "getLineSourcesMap"(): $Map<(string), (string)>
 "getTimeWindows"(arg0: integer): integer
 "getChannelInfo"(): $SparkSamplerProtos$SocketChannelInfo
 "hasChannelInfo"(): boolean
 "getTimeWindowsList"(): $List<(integer)>
 "hasMetadata"(): boolean
 "getMethodSourcesOrDefault"(arg0: string, arg1: string): string
 "getLineSourcesCount"(): integer
 "getLineSourcesOrDefault"(arg0: string, arg1: string): string
 "getTimeWindowStatisticsOrDefault"(arg0: integer, arg1: $SparkProtos$WindowStatistics$Type): $SparkProtos$WindowStatistics
 "containsLineSources"(arg0: string): boolean
 "getMethodSourcesCount"(): integer
 "containsMethodSources"(arg0: string): boolean
 "getTimeWindowStatisticsCount"(): integer
 "getMethodSourcesMap"(): $Map<(string), (string)>
 "getTimeWindowStatisticsMap"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
 "getClassSourcesOrDefault"(arg0: string, arg1: string): string
 "getMethodSourcesOrThrow"(arg0: string): string
 "getTimeWindowsCount"(): integer
 "containsTimeWindowStatistics"(arg0: integer): boolean
 "containsClassSources"(arg0: string): boolean
 "getClassSourcesCount"(): integer
 "getClassSourcesOrThrow"(arg0: string): string
 "getLineSourcesOrThrow"(arg0: string): string
/**
 * 
 * @deprecated
 */
 "getTimeWindowStatistics"(): $Map<(integer), ($SparkProtos$WindowStatistics)>
 "getTimeWindowStatisticsOrThrow"(arg0: integer): $SparkProtos$WindowStatistics
 "getMetadata"(): $SparkSamplerProtos$SamplerMetadata
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SamplerDataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerDataOrBuilder$Type = ($SparkSamplerProtos$SamplerDataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerDataOrBuilder_ = $SparkSamplerProtos$SamplerDataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$NotSendableException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $NotSendableException extends $RuntimeException {

constructor(arg0: string)
constructor(arg0: $Throwable$Type)
constructor(arg0: string, arg1: $Throwable$Type)

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NotSendableException$Type = ($NotSendableException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NotSendableException_ = $NotSendableException$Type;
}}
declare module "packages/me/lucko/spark/common/util/$SparkThreadFactory" {
import {$Thread$UncaughtExceptionHandler, $Thread$UncaughtExceptionHandler$Type} from "packages/java/lang/$Thread$UncaughtExceptionHandler"
import {$Thread, $Thread$Type} from "packages/java/lang/$Thread"
import {$ThreadFactory, $ThreadFactory$Type} from "packages/java/util/concurrent/$ThreadFactory"
import {$Runnable, $Runnable$Type} from "packages/java/lang/$Runnable"

export class $SparkThreadFactory implements $ThreadFactory {
static readonly "EXCEPTION_HANDLER": $Thread$UncaughtExceptionHandler

constructor()

public "newThread"(arg0: $Runnable$Type): $Thread
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkThreadFactory$Type = ($SparkThreadFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkThreadFactory_ = $SparkThreadFactory$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage$Builder" {
import {$SparkProtos$SystemStatistics$Cpu$UsageOrBuilder, $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$UsageOrBuilder"
import {$SparkProtos$SystemStatistics$Cpu$Usage, $SparkProtos$SystemStatistics$Cpu$Usage$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"

export class $SparkProtos$SystemStatistics$Cpu$Usage$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Cpu$Usage), ($SparkProtos$SystemStatistics$Cpu$Usage$Builder)> implements $SparkProtos$SystemStatistics$Cpu$UsageOrBuilder {


public "setLast1M"(arg0: double): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
public "setLast15M"(arg0: double): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
public "clearLast1M"(): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
public "getLast1M"(): double
public "getLast15M"(): double
public "clearLast15M"(): $SparkProtos$SystemStatistics$Cpu$Usage$Builder
set "last1M"(value: double)
set "last15M"(value: double)
get "last1M"(): double
get "last15M"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type = ($SparkProtos$SystemStatistics$Cpu$Usage$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Cpu$Usage$Builder_ = $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Field$Kind" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $Field$Kind extends $Enum<($Field$Kind)> implements $Internal$EnumLite {
static readonly "TYPE_UNKNOWN": $Field$Kind
static readonly "TYPE_DOUBLE": $Field$Kind
static readonly "TYPE_FLOAT": $Field$Kind
static readonly "TYPE_INT64": $Field$Kind
static readonly "TYPE_UINT64": $Field$Kind
static readonly "TYPE_INT32": $Field$Kind
static readonly "TYPE_FIXED64": $Field$Kind
static readonly "TYPE_FIXED32": $Field$Kind
static readonly "TYPE_BOOL": $Field$Kind
static readonly "TYPE_STRING": $Field$Kind
static readonly "TYPE_GROUP": $Field$Kind
static readonly "TYPE_MESSAGE": $Field$Kind
static readonly "TYPE_BYTES": $Field$Kind
static readonly "TYPE_UINT32": $Field$Kind
static readonly "TYPE_ENUM": $Field$Kind
static readonly "TYPE_SFIXED32": $Field$Kind
static readonly "TYPE_SFIXED64": $Field$Kind
static readonly "TYPE_SINT32": $Field$Kind
static readonly "TYPE_SINT64": $Field$Kind
static readonly "UNRECOGNIZED": $Field$Kind
static readonly "TYPE_UNKNOWN_VALUE": integer
static readonly "TYPE_DOUBLE_VALUE": integer
static readonly "TYPE_FLOAT_VALUE": integer
static readonly "TYPE_INT64_VALUE": integer
static readonly "TYPE_UINT64_VALUE": integer
static readonly "TYPE_INT32_VALUE": integer
static readonly "TYPE_FIXED64_VALUE": integer
static readonly "TYPE_FIXED32_VALUE": integer
static readonly "TYPE_BOOL_VALUE": integer
static readonly "TYPE_STRING_VALUE": integer
static readonly "TYPE_GROUP_VALUE": integer
static readonly "TYPE_MESSAGE_VALUE": integer
static readonly "TYPE_BYTES_VALUE": integer
static readonly "TYPE_UINT32_VALUE": integer
static readonly "TYPE_ENUM_VALUE": integer
static readonly "TYPE_SFIXED32_VALUE": integer
static readonly "TYPE_SFIXED64_VALUE": integer
static readonly "TYPE_SINT32_VALUE": integer
static readonly "TYPE_SINT64_VALUE": integer


public static "values"(): ($Field$Kind)[]
public static "valueOf"(arg0: string): $Field$Kind
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $Field$Kind
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($Field$Kind)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $Field$Kind
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Field$Kind$Type = (("type_bool") | ("type_sint32") | ("type_enum") | ("type_unknown") | ("type_uint64") | ("type_group") | ("type_uint32") | ("type_double") | ("type_message") | ("type_float") | ("type_string") | ("type_bytes") | ("type_fixed32") | ("type_fixed64") | ("type_int64") | ("type_sfixed32") | ("type_sint64") | ("type_int32") | ("type_sfixed64") | ("unrecognized")) | ($Field$Kind);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Field$Kind_ = $Field$Kind$Type;
}}
declare module "packages/me/lucko/spark/api/gc/$GarbageCollector" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $GarbageCollector {

 "avgFrequency"(): long
 "totalCollections"(): long
 "avgTime"(): double
 "name"(): string
 "totalTime"(): long
}

export namespace $GarbageCollector {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GarbageCollector$Type = ($GarbageCollector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GarbageCollector_ = $GarbageCollector$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Role" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Role extends $Enum<($Role)> {
static readonly "CLIENT": $Role
static readonly "SERVER": $Role


public static "values"(): ($Role)[]
public static "valueOf"(arg0: string): $Role
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Role$Type = (("server") | ("client")) | ($Role);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Role_ = $Role$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Command$Builder" {
import {$Command$TabCompleter, $Command$TabCompleter$Type} from "packages/me/lucko/spark/common/command/$Command$TabCompleter"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$Command$Executor, $Command$Executor$Type} from "packages/me/lucko/spark/common/command/$Command$Executor"

export class $Command$Builder {


public "build"(): $Command
public "aliases"(...arg0: (string)[]): $Command$Builder
public "executor"(arg0: $Command$Executor$Type): $Command$Builder
public "allowSubCommand"(arg0: boolean): $Command$Builder
public "tabCompleter"(arg0: $Command$TabCompleter$Type): $Command$Builder
public "argumentUsage"(arg0: string, arg1: string): $Command$Builder
public "argumentUsage"(arg0: string, arg1: string, arg2: string): $Command$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Command$Builder$Type = ($Command$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Command$Builder_ = $Command$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Syntax" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $Syntax extends $Enum<($Syntax)> implements $Internal$EnumLite {
static readonly "SYNTAX_PROTO2": $Syntax
static readonly "SYNTAX_PROTO3": $Syntax
static readonly "UNRECOGNIZED": $Syntax
static readonly "SYNTAX_PROTO2_VALUE": integer
static readonly "SYNTAX_PROTO3_VALUE": integer


public static "values"(): ($Syntax)[]
public static "valueOf"(arg0: string): $Syntax
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $Syntax
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($Syntax)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $Syntax
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Syntax$Type = (("syntax_proto3") | ("syntax_proto2") | ("unrecognized")) | ($Syntax);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Syntax_ = $Syntax$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$Visitor" {
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $ClassSourceLookup$Visitor {

 "hasClassSourceMappings"(): boolean
 "getClassSourceMapping"(): $Map<(string), (string)>
 "hasMethodSourceMappings"(): boolean
 "getMethodSourceMapping"(): $Map<(string), (string)>
 "getLineSourceMapping"(): $Map<(string), (string)>
 "hasLineSourceMappings"(): boolean
 "visit"(arg0: $ThreadNode$Type): void
}

export namespace $ClassSourceLookup$Visitor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassSourceLookup$Visitor$Type = ($ClassSourceLookup$Visitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassSourceLookup$Visitor_ = $ClassSourceLookup$Visitor$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$LazyField" {
import {$LazyFieldLite, $LazyFieldLite$Type} from "packages/me/lucko/spark/lib/protobuf/$LazyFieldLite"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $LazyField extends $LazyFieldLite {

constructor(arg0: $MessageLite$Type, arg1: $ExtensionRegistryLite$Type, arg2: $ByteString$Type)

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getValue"(): $MessageLite
public "containsDefaultInstance"(): boolean
get "value"(): $MessageLite
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyField$Type = ($LazyField);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyField_ = $LazyField$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextFormat" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $TextFormat {

}

export namespace $TextFormat {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextFormat$Type = ($TextFormat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextFormat_ = $TextFormat$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $SparkHeapProtos {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$Type = ($SparkHeapProtos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos_ = $SparkHeapProtos$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$LazyStringList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$ProtocolStringList, $ProtocolStringList$Type} from "packages/me/lucko/spark/lib/protobuf/$ProtocolStringList"

export interface $LazyStringList extends $ProtocolStringList {

 "getUnderlyingElements"(): $List<(any)>
 "getUnmodifiableView"(): $LazyStringList
 "add"(arg0: $ByteString$Type): void
 "add"(arg0: (byte)[]): void
 "set"(arg0: integer, arg1: (byte)[]): void
 "set"(arg0: integer, arg1: $ByteString$Type): void
 "getRaw"(arg0: integer): any
 "getByteArray"(arg0: integer): (byte)[]
 "mergeFrom"(arg0: $LazyStringList$Type): void
 "getByteString"(arg0: integer): $ByteString
 "asByteArrayList"(): $List<((byte)[])>
 "addAllByteString"(arg0: $Collection$Type<(any)>): boolean
 "addAllByteArray"(arg0: $Collection$Type<((byte)[])>): boolean
 "asByteStringList"(): $List<($ByteString)>
 "add"(arg0: integer, arg1: string): void
 "add"(arg0: string): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): string
 "get"(arg0: integer): string
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(string)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(string)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(string)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(string)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: string): string
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(string)>
 "listIterator"(): $ListIterator<(string)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(string)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(string)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $LazyStringList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string): $List<(string)>
function of<E>(arg0: string, arg1: string): $List<(string)>
function of<E>(arg0: string): $List<(string)>
function of<E>(): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string): $List<(string)>
function of<E>(...arg0: (string)[]): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LazyStringList$Type = ($LazyStringList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LazyStringList_ = $LazyStringList$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/os/$OperatingSystemInfo" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $OperatingSystemInfo {

constructor(arg0: string, arg1: string, arg2: string)

public "name"(): string
public "version"(): string
public static "poll"(): $OperatingSystemInfo
public "arch"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $OperatingSystemInfo$Type = ($OperatingSystemInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $OperatingSystemInfo_ = $OperatingSystemInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int32Value$Builder" {
import {$Int32ValueOrBuilder, $Int32ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int32ValueOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Int32Value, $Int32Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Int32Value"

export class $Int32Value$Builder extends $GeneratedMessageLite$Builder<($Int32Value), ($Int32Value$Builder)> implements $Int32ValueOrBuilder {


public "getValue"(): integer
public "setValue"(arg0: integer): $Int32Value$Builder
public "clearValue"(): $Int32Value$Builder
get "value"(): integer
set "value"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int32Value$Builder$Type = ($Int32Value$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int32Value$Builder_ = $Int32Value$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $BuildableComponent<C extends $BuildableComponent<(C), (B)>, B extends $ComponentBuilder<(C), (B)>> extends $Buildable<(C), (B)>, $Component {

 "toBuilder"(): B
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $Component
 "append"(like: $ComponentLike$Type): $Component
 "append"(component: $Component$Type): $Component
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(color: $TextColor$Type): $Component
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(style: $Style$Type): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "style"(style: $Style$Builder$Type): $Component
 "children"(): $List<($Component)>
 "children"(children: $List$Type<(any)>): $Component
 "appendNewline"(): $Component
 "mergeStyle"(that: $Component$Type): $Component
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $Component
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "colorIfAbsent"(color: $TextColor$Type): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "examinableProperties"(): $Stream<(any)>
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "decorate"(decoration: $TextDecoration$Type): $Component
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(event: $ClickEvent$Type): $Component
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Component
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $BuildableComponent {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): C
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BuildableComponent$Type<C, B> = ($BuildableComponent<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BuildableComponent_<C, B> = $BuildableComponent$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/inventory/$BookImpl" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Book$Builder, $Book$Builder$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Book, $Book$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export class $BookImpl implements $Book {


public "equals"(o: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "examinableProperties"(): $Stream<(any)>
public "title"(): $Component
public "title"(title: $Component$Type): $Book
public "pages"(): $List<($Component)>
public "pages"(pages: $List$Type<($Component$Type)>): $Book
public "author"(author: $Component$Type): $Book
public "author"(): $Component
public static "builder"(): $Book$Builder
public static "book"(title: $Component$Type, author: $Component$Type, pages: $Collection$Type<($Component$Type)>): $Book
public static "book"(title: $Component$Type, author: $Component$Type, ...pages: ($Component$Type)[]): $Book
public "toBuilder"(): $Book$Builder
public "pages"(...pages: ($Component$Type)[]): $Book
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $Book$Builder$Type, consumer: $Consumer$Type<(any)>): $Book
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BookImpl$Type = ($BookImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BookImpl_ = $BookImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$WebsocketNotConnectedException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $WebsocketNotConnectedException extends $RuntimeException {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebsocketNotConnectedException$Type = ($WebsocketNotConnectedException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebsocketNotConnectedException_ = $WebsocketNotConnectedException$Type;
}}
declare module "packages/me/lucko/spark/common/command/sender/$AbstractCommandSender" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"
import {$CommandSender$Data, $CommandSender$Data$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender$Data"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $AbstractCommandSender<S> implements $CommandSender {

constructor(arg0: S)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getName"(): string
public "toData"(): $CommandSender$Data
public "sendMessage"(arg0: $Component$Type): void
public "getUniqueId"(): $UUID
public "hasPermission"(arg0: string): boolean
get "name"(): string
get "uniqueId"(): $UUID
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractCommandSender$Type<S> = ($AbstractCommandSender<(S)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractCommandSender_<S> = $AbstractCommandSender$Type<(S)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FloatValue" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$FloatValue$Builder, $FloatValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$FloatValue$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$FloatValueOrBuilder, $FloatValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$FloatValueOrBuilder"

export class $FloatValue extends $GeneratedMessageLite<($FloatValue), ($FloatValue$Builder)> implements $FloatValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): float
public static "of"(arg0: float): $FloatValue
public static "parser"(): $Parser<($FloatValue)>
public static "newBuilder"(arg0: $FloatValue$Type): $FloatValue$Builder
public static "newBuilder"(): $FloatValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $FloatValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $FloatValue
public static "getDefaultInstance"(): $FloatValue
public static "parseFrom"(arg0: $ByteString$Type): $FloatValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $FloatValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $FloatValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $FloatValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $FloatValue
public static "parseFrom"(arg0: $InputStream$Type): $FloatValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $FloatValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $FloatValue
public static "parseFrom"(arg0: (byte)[]): $FloatValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $FloatValue
get "value"(): float
get "defaultInstance"(): $FloatValue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatValue$Type = ($FloatValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatValue_ = $FloatValue$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu" {
import {$SparkProtos$SystemStatistics$Cpu$Usage, $SparkProtos$SystemStatistics$Cpu$Usage$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Cpu$Builder, $SparkProtos$SystemStatistics$Cpu$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$SystemStatistics$CpuOrBuilder, $SparkProtos$SystemStatistics$CpuOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$CpuOrBuilder"

export class $SparkProtos$SystemStatistics$Cpu extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Cpu), ($SparkProtos$SystemStatistics$Cpu$Builder)> implements $SparkProtos$SystemStatistics$CpuOrBuilder {
static readonly "THREADS_FIELD_NUMBER": integer
static readonly "PROCESS_USAGE_FIELD_NUMBER": integer
static readonly "SYSTEM_USAGE_FIELD_NUMBER": integer
static readonly "MODEL_NAME_FIELD_NUMBER": integer


public "getThreads"(): integer
public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Cpu)>
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Cpu$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$Cpu$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Cpu
public "getModelName"(): string
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Cpu
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Cpu
public "hasProcessUsage"(): boolean
public "getProcessUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
public "hasSystemUsage"(): boolean
public "getSystemUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
public "getModelNameBytes"(): $ByteString
get "threads"(): integer
get "defaultInstance"(): $SparkProtos$SystemStatistics$Cpu
get "modelName"(): string
get "processUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
get "systemUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
get "modelNameBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Cpu$Type = ($SparkProtos$SystemStatistics$Cpu);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Cpu_ = $SparkProtos$SystemStatistics$Cpu$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$RollingAverageValues$Builder, $SparkProtos$RollingAverageValues$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues$Builder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$SparkProtos$PlatformStatistics$PingOrBuilder, $SparkProtos$PlatformStatistics$PingOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$PingOrBuilder"
import {$SparkProtos$PlatformStatistics$Ping, $SparkProtos$PlatformStatistics$Ping$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Ping"

export class $SparkProtos$PlatformStatistics$Ping$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Ping), ($SparkProtos$PlatformStatistics$Ping$Builder)> implements $SparkProtos$PlatformStatistics$PingOrBuilder {


public "setLast15M"(arg0: $SparkProtos$RollingAverageValues$Builder$Type): $SparkProtos$PlatformStatistics$Ping$Builder
public "setLast15M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Ping$Builder
public "getLast15M"(): $SparkProtos$RollingAverageValues
public "clearLast15M"(): $SparkProtos$PlatformStatistics$Ping$Builder
public "mergeLast15M"(arg0: $SparkProtos$RollingAverageValues$Type): $SparkProtos$PlatformStatistics$Ping$Builder
public "hasLast15M"(): boolean
set "last15M"(value: $SparkProtos$RollingAverageValues$Builder$Type)
set "last15M"(value: $SparkProtos$RollingAverageValues$Type)
get "last15M"(): $SparkProtos$RollingAverageValues
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Ping$Builder$Type = ($SparkProtos$PlatformStatistics$Ping$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Ping$Builder_ = $SparkProtos$PlatformStatistics$Ping$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BoolValue$Builder" {
import {$BoolValue, $BoolValue$Type} from "packages/me/lucko/spark/lib/protobuf/$BoolValue"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$BoolValueOrBuilder, $BoolValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$BoolValueOrBuilder"

export class $BoolValue$Builder extends $GeneratedMessageLite$Builder<($BoolValue), ($BoolValue$Builder)> implements $BoolValueOrBuilder {


public "getValue"(): boolean
public "setValue"(arg0: boolean): $BoolValue$Builder
public "clearValue"(): $BoolValue$Builder
get "value"(): boolean
set "value"(value: boolean)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BoolValue$Builder$Type = ($BoolValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BoolValue$Builder_ = $BoolValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$ConstantDynamic" {
import {$Handle, $Handle$Type} from "packages/me/lucko/spark/lib/asm/$Handle"

export class $ConstantDynamic {

constructor(arg0: string, arg1: string, arg2: $Handle$Type, ...arg3: (any)[])

public "getName"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getDescriptor"(): string
public "getSize"(): integer
public "getBootstrapMethod"(): $Handle
public "getBootstrapMethodArgumentCount"(): integer
public "getBootstrapMethodArgument"(arg0: integer): any
get "name"(): string
get "descriptor"(): string
get "size"(): integer
get "bootstrapMethod"(): $Handle
get "bootstrapMethodArgumentCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ConstantDynamic$Type = ($ConstantDynamic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ConstantDynamic_ = $ConstantDynamic$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$HandshakeBuilder, $HandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder"
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$WebSocketImpl, $WebSocketImpl$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"
import {$HandshakeState, $HandshakeState$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$HandshakeState"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$Role, $Role$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Role"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$CloseHandshakeType, $CloseHandshakeType$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$CloseHandshakeType"
import {$ClientHandshakeBuilder, $ClientHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshakeBuilder"
import {$ServerHandshakeBuilder, $ServerHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder"
import {$List, $List$Type} from "packages/java/util/$List"

export class $Draft {

constructor()

public "acceptHandshakeAsClient"(arg0: $ClientHandshake$Type, arg1: $ServerHandshake$Type): $HandshakeState
public "acceptHandshakeAsServer"(arg0: $ClientHandshake$Type): $HandshakeState
public "getCloseHandshakeType"(): $CloseHandshakeType
public static "translateHandshakeHttp"(arg0: $ByteBuffer$Type, arg1: $Role$Type): $HandshakeBuilder
public "toString"(): string
public static "readLine"(arg0: $ByteBuffer$Type): $ByteBuffer
public "reset"(): void
public "processFrame"(arg0: $WebSocketImpl$Type, arg1: $Framedata$Type): void
public "copyInstance"(): $Draft
public "postProcessHandshakeResponseAsServer"(arg0: $ClientHandshake$Type, arg1: $ServerHandshakeBuilder$Type): $HandshakeBuilder
public "postProcessHandshakeRequestAsClient"(arg0: $ClientHandshakeBuilder$Type): $ClientHandshakeBuilder
public "getRole"(): $Role
public "setParseMode"(arg0: $Role$Type): void
public "continuousFrame"(arg0: $Opcode$Type, arg1: $ByteBuffer$Type, arg2: boolean): $List<($Framedata)>
public static "readStringLine"(arg0: $ByteBuffer$Type): string
/**
 * 
 * @deprecated
 */
public "createHandshake"(arg0: $Handshakedata$Type, arg1: $Role$Type): $List<($ByteBuffer)>
public "createHandshake"(arg0: $Handshakedata$Type): $List<($ByteBuffer)>
public "createHandshake"(arg0: $Handshakedata$Type, arg1: boolean): $List<($ByteBuffer)>
/**
 * 
 * @deprecated
 */
public "createHandshake"(arg0: $Handshakedata$Type, arg1: $Role$Type, arg2: boolean): $List<($ByteBuffer)>
public "createBinaryFrame"(arg0: $Framedata$Type): $ByteBuffer
public "createFrames"(arg0: $ByteBuffer$Type, arg1: boolean): $List<($Framedata)>
public "createFrames"(arg0: string, arg1: boolean): $List<($Framedata)>
public "translateHandshake"(arg0: $ByteBuffer$Type): $Handshakedata
public "checkAlloc"(arg0: integer): integer
public "translateFrame"(arg0: $ByteBuffer$Type): $List<($Framedata)>
get "closeHandshakeType"(): $CloseHandshakeType
get "role"(): $Role
set "parseMode"(value: $Role$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Draft$Type = ($Draft);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Draft_ = $Draft$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageLite" {
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"

export interface $MessageLite extends $MessageLiteOrBuilder {

 "toByteArray"(): (byte)[]
 "writeTo"(arg0: $OutputStream$Type): void
 "writeTo"(arg0: $CodedOutputStream$Type): void
 "writeDelimitedTo"(arg0: $OutputStream$Type): void
 "getSerializedSize"(): integer
 "newBuilderForType"(): $MessageLite$Builder
 "getParserForType"(): $Parser<(any)>
 "toBuilder"(): $MessageLite$Builder
 "toByteString"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $MessageLite {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageLite$Type = ($MessageLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageLite_ = $MessageLite$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt32Value$Builder" {
import {$UInt32Value, $UInt32Value$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt32Value"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$UInt32ValueOrBuilder, $UInt32ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt32ValueOrBuilder"

export class $UInt32Value$Builder extends $GeneratedMessageLite$Builder<($UInt32Value), ($UInt32Value$Builder)> implements $UInt32ValueOrBuilder {


public "getValue"(): integer
public "setValue"(arg0: integer): $UInt32Value$Builder
public "clearValue"(): $UInt32Value$Builder
get "value"(): integer
set "value"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt32Value$Builder$Type = ($UInt32Value$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt32Value$Builder_ = $UInt32Value$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $KeybindComponent extends $BuildableComponent<($KeybindComponent), ($KeybindComponent$Builder)>, $ScopedComponent<($KeybindComponent)> {

 "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
 "keybind"(keybind: string): $KeybindComponent
 "keybind"(): string
 "examinableProperties"(): $Stream<(any)>
 "toBuilder"(): $KeybindComponent$Builder
 "append"(component: $Component$Type): $KeybindComponent
 "append"(like: $ComponentLike$Type): $KeybindComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $KeybindComponent
 "color"(color: $TextColor$Type): $KeybindComponent
 "style"(style: $Style$Type): $KeybindComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $KeybindComponent
 "style"(style: $Style$Builder$Type): $KeybindComponent
 "children"(children: $List$Type<(any)>): $KeybindComponent
 "mergeStyle"(that: $Component$Type): $KeybindComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $KeybindComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $KeybindComponent
 "colorIfAbsent"(color: $TextColor$Type): $KeybindComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $KeybindComponent
 "clickEvent"(event: $ClickEvent$Type): $KeybindComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $KeybindComponent
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $KeybindComponent {
function configureAndBuild<R, B>(builder: $KeybindComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $KeybindComponent
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindComponent$Type = ($KeybindComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeybindComponent_ = $KeybindComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/internal/properties/$AdventureProperties$Property" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $AdventureProperties$Property<T> {

 "value"(): T

(): T
}

export namespace $AdventureProperties$Property {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdventureProperties$Property$Type<T> = ($AdventureProperties$Property<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdventureProperties$Property_<T> = $AdventureProperties$Property$Type<(T)>;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$JfrReader$JfrClass, $JfrReader$JfrClass$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$JfrClass"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$AsyncStackTraceElement, $AsyncStackTraceElement$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncStackTraceElement"
import {$Dictionary, $Dictionary$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$Dictionary"
import {$JfrReader$StackTrace, $JfrReader$StackTrace$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$StackTrace"
import {$Closeable, $Closeable$Type} from "packages/java/io/$Closeable"
import {$List, $List$Type} from "packages/java/util/$List"
import {$JfrReader$ClassRef, $JfrReader$ClassRef$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$ClassRef"
import {$JfrReader$Event, $JfrReader$Event$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Event"
import {$JfrReader$MethodRef, $JfrReader$MethodRef$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$MethodRef"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $JfrReader implements $Closeable {
 "incomplete": boolean
 "startNanos": long
 "endNanos": long
 "startTicks": long
 "ticksPerSec": long
readonly "types": $Dictionary<($JfrReader$JfrClass)>
readonly "typesByName": $Map<(string), ($JfrReader$JfrClass)>
readonly "threads": $Map<(long), (string)>
readonly "classes": $Dictionary<($JfrReader$ClassRef)>
readonly "symbols": $Dictionary<((byte)[])>
readonly "methods": $Dictionary<($JfrReader$MethodRef)>
readonly "stackTraces": $Dictionary<($JfrReader$StackTrace)>
readonly "stackFrames": $Dictionary<($AsyncStackTraceElement)>
readonly "frameTypes": $Map<(integer), (string)>
readonly "threadStates": $Map<(integer), (string)>
readonly "settings": $Map<(string), (string)>

constructor(arg0: $Path$Type)

public "close"(): void
public "readAllEvents"<E extends $JfrReader$Event>(arg0: $Class$Type<(E)>): $List<(E)>
public "readAllEvents"(): $List<($JfrReader$Event)>
public "durationNanos"(): long
public "readEvent"(): $JfrReader$Event
public "readEvent"<E extends $JfrReader$Event>(arg0: $Class$Type<(E)>): E
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$Type = ($JfrReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader_ = $JfrReader$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$DefaultExtension" {
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$IExtension, $IExtension$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$IExtension"

export class $DefaultExtension implements $IExtension {

constructor()

public "acceptProvidedExtensionAsServer"(arg0: string): boolean
public "getProvidedExtensionAsServer"(): string
public "acceptProvidedExtensionAsClient"(arg0: string): boolean
public "getProvidedExtensionAsClient"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "reset"(): void
public "encodeFrame"(arg0: $Framedata$Type): void
public "decodeFrame"(arg0: $Framedata$Type): void
public "copyInstance"(): $IExtension
public "isFrameValid"(arg0: $Framedata$Type): void
get "providedExtensionAsServer"(): string
get "providedExtensionAsClient"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DefaultExtension$Type = ($DefaultExtension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DefaultExtension_ = $DefaultExtension$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate$Type" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BlockNBTComponent$WorldPos$Coordinate$Type extends $Enum<($BlockNBTComponent$WorldPos$Coordinate$Type)> {
static readonly "ABSOLUTE": $BlockNBTComponent$WorldPos$Coordinate$Type
static readonly "RELATIVE": $BlockNBTComponent$WorldPos$Coordinate$Type


public static "values"(): ($BlockNBTComponent$WorldPos$Coordinate$Type)[]
public static "valueOf"(name: string): $BlockNBTComponent$WorldPos$Coordinate$Type
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponent$WorldPos$Coordinate$Type$Type = (("absolute") | ("relative")) | ($BlockNBTComponent$WorldPos$Coordinate$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponent$WorldPos$Coordinate$Type_ = $BlockNBTComponent$WorldPos$Coordinate$Type$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/net/$NetworkMonitor" {
import {$NetworkInterfaceInfo, $NetworkInterfaceInfo$Type} from "packages/me/lucko/spark/common/monitor/net/$NetworkInterfaceInfo"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$NetworkInterfaceAverages, $NetworkInterfaceAverages$Type} from "packages/me/lucko/spark/common/monitor/net/$NetworkInterfaceAverages"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NetworkMonitor extends $Enum<($NetworkMonitor)> {


public static "values"(): ($NetworkMonitor)[]
public static "valueOf"(arg0: string): $NetworkMonitor
public static "ensureMonitoring"(): void
public static "systemAverages"(): $Map<(string), ($NetworkInterfaceAverages)>
public static "systemTotals"(): $Map<(string), ($NetworkInterfaceInfo)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkMonitor$Type = (never) | ($NetworkMonitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkMonitor_ = $NetworkMonitor$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type extends $Enum<($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type)> implements $Internal$EnumLite {
static readonly "ALL": $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
static readonly "SPECIFIC": $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
static readonly "REGEX": $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
static readonly "UNRECOGNIZED": $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
static readonly "ALL_VALUE": integer
static readonly "SPECIFIC_VALUE": integer
static readonly "REGEX_VALUE": integer


public static "values"(): ($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type)[]
public static "valueOf"(arg0: string): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type = (("all") | ("regex") | ("unrecognized") | ("specific")) | ($SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type_ = $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$ClassReader" {
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ClassVisitor, $ClassVisitor$Type} from "packages/me/lucko/spark/lib/asm/$ClassVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $ClassReader {
static readonly "SKIP_CODE": integer
static readonly "SKIP_DEBUG": integer
static readonly "SKIP_FRAMES": integer
static readonly "EXPAND_FRAMES": integer
/**
 * 
 * @deprecated
 */
readonly "b": (byte)[]
readonly "header": integer

constructor(arg0: string)
constructor(arg0: $InputStream$Type)
constructor(arg0: (byte)[], arg1: integer, arg2: integer)
constructor(arg0: (byte)[])

public "getInterfaces"(): (string)[]
public "accept"(arg0: $ClassVisitor$Type, arg1: ($Attribute$Type)[], arg2: integer): void
public "accept"(arg0: $ClassVisitor$Type, arg1: integer): void
public "readInt"(arg0: integer): integer
public "getClassName"(): string
public "readByte"(arg0: integer): integer
public "readShort"(arg0: integer): short
public "readUnsignedShort"(arg0: integer): integer
public "readLong"(arg0: integer): long
public "getMaxStringLength"(): integer
public "readConst"(arg0: integer, arg1: (character)[]): any
public "readModule"(arg0: integer, arg1: (character)[]): string
public "readClass"(arg0: integer, arg1: (character)[]): string
public "readUTF8"(arg0: integer, arg1: (character)[]): string
public "readPackage"(arg0: integer, arg1: (character)[]): string
public "getAccess"(): integer
public "getSuperName"(): string
public "getItemCount"(): integer
public "getItem"(arg0: integer): integer
get "interfaces"(): (string)[]
get "className"(): string
get "maxStringLength"(): integer
get "access"(): integer
get "superName"(): string
get "itemCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassReader$Type = ($ClassReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassReader_ = $ClassReader$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Schema" {
import {$ArrayDecoders$Registers, $ArrayDecoders$Registers$Type} from "packages/me/lucko/spark/lib/protobuf/$ArrayDecoders$Registers"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"

export interface $Schema<T> {

 "equals"(arg0: T, arg1: T): boolean
 "hashCode"(arg0: T): integer
 "newInstance"(): T
 "writeTo"(arg0: T, arg1: $Writer$Type): void
 "makeImmutable"(arg0: T): void
 "getSerializedSize"(arg0: T): integer
 "isInitialized"(arg0: T): boolean
 "mergeFrom"(arg0: T, arg1: (byte)[], arg2: integer, arg3: integer, arg4: $ArrayDecoders$Registers$Type): void
 "mergeFrom"(arg0: T, arg1: T): void
 "mergeFrom"(arg0: T, arg1: $Reader$Type, arg2: $ExtensionRegistryLite$Type): void
}

export namespace $Schema {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Schema$Type<T> = ($Schema<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Schema_<T> = $Schema$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CodedInputStreamReader" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $CodedInputStreamReader implements $Reader {


public "shouldDiscardUnknownFields"(): boolean
public "readStringRequireUtf8"(): string
public "readStringListRequireUtf8"(arg0: $List$Type<(string)>): void
/**
 * 
 * @deprecated
 */
public "readGroupBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readMessageBySchemaWithCheck"<T>(arg0: $Schema$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readBytes"(): $ByteString
public "readFloat"(): float
public "readDouble"(): double
public "readString"(): string
public "getTag"(): integer
public static "forCodedInput"(arg0: $CodedInputStream$Type): $CodedInputStreamReader
public "getFieldNumber"(): integer
public "skipField"(): boolean
public "readUInt64"(): long
public "readInt64"(): long
/**
 * 
 * @deprecated
 */
public "readGroup"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readSFixed64"(): long
public "readFloatList"(arg0: $List$Type<(float)>): void
public "readBoolList"(arg0: $List$Type<(boolean)>): void
public "readMessage"<T>(arg0: $Class$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readMessageList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readBool"(): boolean
public "readFixed32"(): integer
public "readDoubleList"(arg0: $List$Type<(double)>): void
public "readUInt32"(): integer
public "readSInt64"(): long
public "mergeGroupField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readInt64List"(arg0: $List$Type<(long)>): void
public "readFixed64List"(arg0: $List$Type<(long)>): void
public "readInt32List"(arg0: $List$Type<(integer)>): void
public "readFixed64"(): long
public "readSFixed32"(): integer
public "readSInt32"(): integer
public "readFixed32List"(arg0: $List$Type<(integer)>): void
public "readStringList"(arg0: $List$Type<(string)>): void
public "readUInt64List"(arg0: $List$Type<(long)>): void
public "readInt32"(): integer
public "mergeMessageField"<T>(arg0: T, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readSInt64List"(arg0: $List$Type<(long)>): void
public "readBytesList"(arg0: $List$Type<($ByteString$Type)>): void
public "readSInt32List"(arg0: $List$Type<(integer)>): void
public "readSFixed32List"(arg0: $List$Type<(integer)>): void
/**
 * 
 * @deprecated
 */
public "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Schema$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
/**
 * 
 * @deprecated
 */
public "readGroupList"<T>(arg0: $List$Type<(T)>, arg1: $Class$Type<(T)>, arg2: $ExtensionRegistryLite$Type): void
public "readEnumList"(arg0: $List$Type<(integer)>): void
public "readSFixed64List"(arg0: $List$Type<(long)>): void
public "readUInt32List"(arg0: $List$Type<(integer)>): void
public "readEnum"(): integer
public "readMap"<K, V>(arg0: $Map$Type<(K), (V)>, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $ExtensionRegistryLite$Type): void
public "readStringListInternal"(arg0: $List$Type<(string)>, arg1: boolean): void
get "tag"(): integer
get "fieldNumber"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodedInputStreamReader$Type = ($CodedInputStreamReader);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodedInputStreamReader_ = $CodedInputStreamReader$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Method$Builder" {
import {$Option$Builder, $Option$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Option$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Method, $Method$Type} from "packages/me/lucko/spark/lib/protobuf/$Method"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$MethodOrBuilder, $MethodOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MethodOrBuilder"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Method$Builder extends $GeneratedMessageLite$Builder<($Method), ($Method$Builder)> implements $MethodOrBuilder {


public "getName"(): string
public "setName"(arg0: string): $Method$Builder
public "getSyntax"(): $Syntax
public "getOptions"(arg0: integer): $Option
public "addOptions"(arg0: $Option$Type): $Method$Builder
public "addOptions"(arg0: integer, arg1: $Option$Builder$Type): $Method$Builder
public "addOptions"(arg0: $Option$Builder$Type): $Method$Builder
public "addOptions"(arg0: integer, arg1: $Option$Type): $Method$Builder
public "setRequestTypeUrl"(arg0: string): $Method$Builder
public "getResponseTypeUrl"(): string
public "getRequestTypeUrl"(): string
public "addAllOptions"(arg0: $Iterable$Type<(any)>): $Method$Builder
public "clearOptions"(): $Method$Builder
public "setResponseTypeUrl"(arg0: string): $Method$Builder
public "clearSyntax"(): $Method$Builder
public "removeOptions"(arg0: integer): $Method$Builder
public "setSyntaxValue"(arg0: integer): $Method$Builder
public "setSyntax"(arg0: $Syntax$Type): $Method$Builder
public "setNameBytes"(arg0: $ByteString$Type): $Method$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $Method$Builder
public "setOptions"(arg0: integer, arg1: $Option$Type): $Method$Builder
public "setOptions"(arg0: integer, arg1: $Option$Builder$Type): $Method$Builder
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getSyntaxValue"(): integer
public "setRequestStreaming"(arg0: boolean): $Method$Builder
public "getResponseStreaming"(): boolean
public "clearRequestTypeUrl"(): $Method$Builder
public "clearResponseTypeUrl"(): $Method$Builder
public "setResponseTypeUrlBytes"(arg0: $ByteString$Type): $Method$Builder
public "getRequestTypeUrlBytes"(): $ByteString
public "getResponseTypeUrlBytes"(): $ByteString
public "clearRequestStreaming"(): $Method$Builder
public "clearResponseStreaming"(): $Method$Builder
public "getRequestStreaming"(): boolean
public "setResponseStreaming"(arg0: boolean): $Method$Builder
public "setRequestTypeUrlBytes"(arg0: $ByteString$Type): $Method$Builder
get "name"(): string
set "name"(value: string)
get "syntax"(): $Syntax
set "requestTypeUrl"(value: string)
get "responseTypeUrl"(): string
get "requestTypeUrl"(): string
set "responseTypeUrl"(value: string)
set "syntaxValue"(value: integer)
set "syntax"(value: $Syntax$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
set "requestStreaming"(value: boolean)
get "responseStreaming"(): boolean
set "responseTypeUrlBytes"(value: $ByteString$Type)
get "requestTypeUrlBytes"(): $ByteString
get "responseTypeUrlBytes"(): $ByteString
get "requestStreaming"(): boolean
set "responseStreaming"(value: boolean)
set "requestTypeUrlBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Method$Builder$Type = ($Method$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Method$Builder_ = $Method$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc$Builder" {
import {$SparkProtos$SystemStatistics$GcOrBuilder, $SparkProtos$SystemStatistics$GcOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$GcOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$Gc, $SparkProtos$SystemStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc"

export class $SparkProtos$SystemStatistics$Gc$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Gc), ($SparkProtos$SystemStatistics$Gc$Builder)> implements $SparkProtos$SystemStatistics$GcOrBuilder {


public "getTotal"(): long
public "clearTotal"(): $SparkProtos$SystemStatistics$Gc$Builder
public "setTotal"(arg0: long): $SparkProtos$SystemStatistics$Gc$Builder
public "setAvgFrequency"(arg0: double): $SparkProtos$SystemStatistics$Gc$Builder
public "setAvgTime"(arg0: double): $SparkProtos$SystemStatistics$Gc$Builder
public "getAvgFrequency"(): double
public "getAvgTime"(): double
public "clearAvgFrequency"(): $SparkProtos$SystemStatistics$Gc$Builder
public "clearAvgTime"(): $SparkProtos$SystemStatistics$Gc$Builder
get "total"(): long
set "total"(value: long)
set "avgFrequency"(value: double)
set "avgTime"(value: double)
get "avgFrequency"(): double
get "avgTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Gc$Builder$Type = ($SparkProtos$SystemStatistics$Gc$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Gc$Builder_ = $SparkProtos$SystemStatistics$Gc$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SourceContextProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $SourceContextProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceContextProto$Type = ($SourceContextProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceContextProto_ = $SourceContextProto$Type;
}}
declare module "packages/me/lucko/spark/lib/asyncprofiler/$Events" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Events {
static readonly "CPU": string
static readonly "ALLOC": string
static readonly "LOCK": string
static readonly "WALL": string
static readonly "ITIMER": string

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Events$Type = ($Events);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Events_ = $Events$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$Builder" {
import {$SparkWebSocketProtos$ServerUpdateSamplerData$Builder, $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ServerConnectResponse, $SparkWebSocketProtos$ServerConnectResponse$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse"
import {$SparkWebSocketProtos$ServerPong, $SparkWebSocketProtos$ServerPong$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong"
import {$SparkWebSocketProtos$PacketWrapper$PacketCase, $SparkWebSocketProtos$PacketWrapper$PacketCase$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$PacketCase"
import {$SparkWebSocketProtos$ServerConnectResponse$Builder, $SparkWebSocketProtos$ServerConnectResponse$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Builder"
import {$SparkWebSocketProtos$ClientPing, $SparkWebSocketProtos$ClientPing$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing"
import {$SparkWebSocketProtos$ServerUpdateStatistics$Builder, $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics$Builder"
import {$SparkWebSocketProtos$ClientPing$Builder, $SparkWebSocketProtos$ClientPing$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing$Builder"
import {$SparkWebSocketProtos$ServerUpdateSamplerData, $SparkWebSocketProtos$ServerUpdateSamplerData$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData"
import {$SparkWebSocketProtos$PacketWrapper, $SparkWebSocketProtos$PacketWrapper$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper"
import {$SparkWebSocketProtos$ServerUpdateStatistics, $SparkWebSocketProtos$ServerUpdateStatistics$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics"
import {$SparkWebSocketProtos$ClientConnect$Builder, $SparkWebSocketProtos$ClientConnect$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect$Builder"
import {$SparkWebSocketProtos$ServerPong$Builder, $SparkWebSocketProtos$ServerPong$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong$Builder"
import {$SparkWebSocketProtos$PacketWrapperOrBuilder, $SparkWebSocketProtos$PacketWrapperOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapperOrBuilder"
import {$SparkWebSocketProtos$ClientConnect, $SparkWebSocketProtos$ClientConnect$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect"

export class $SparkWebSocketProtos$PacketWrapper$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$PacketWrapper), ($SparkWebSocketProtos$PacketWrapper$Builder)> implements $SparkWebSocketProtos$PacketWrapperOrBuilder {


public "getPacketCase"(): $SparkWebSocketProtos$PacketWrapper$PacketCase
public "getClientPing"(): $SparkWebSocketProtos$ClientPing
public "getClientConnect"(): $SparkWebSocketProtos$ClientConnect
public "setServerPong"(arg0: $SparkWebSocketProtos$ServerPong$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerPong"(arg0: $SparkWebSocketProtos$ServerPong$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerConnectResponse"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerConnectResponse"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerUpdateSampler"(arg0: $SparkWebSocketProtos$ServerUpdateSamplerData$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerUpdateSampler"(arg0: $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerUpdateStatistics"(arg0: $SparkWebSocketProtos$ServerUpdateStatistics$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setServerUpdateStatistics"(arg0: $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "mergeServerPong"(arg0: $SparkWebSocketProtos$ServerPong$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "hasServerPong"(): boolean
public "getServerPong"(): $SparkWebSocketProtos$ServerPong
public "clearPacket"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "clearServerPong"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "hasClientPing"(): boolean
public "clearClientConnect"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "setClientConnect"(arg0: $SparkWebSocketProtos$ClientConnect$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setClientConnect"(arg0: $SparkWebSocketProtos$ClientConnect$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "clearClientPing"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "mergeClientConnect"(arg0: $SparkWebSocketProtos$ClientConnect$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "hasClientConnect"(): boolean
public "setClientPing"(arg0: $SparkWebSocketProtos$ClientPing$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "setClientPing"(arg0: $SparkWebSocketProtos$ClientPing$Builder$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "mergeClientPing"(arg0: $SparkWebSocketProtos$ClientPing$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "mergeServerUpdateStatistics"(arg0: $SparkWebSocketProtos$ServerUpdateStatistics$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "getServerConnectResponse"(): $SparkWebSocketProtos$ServerConnectResponse
public "mergeServerUpdateSampler"(arg0: $SparkWebSocketProtos$ServerUpdateSamplerData$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "getServerUpdateStatistics"(): $SparkWebSocketProtos$ServerUpdateStatistics
public "hasServerConnectResponse"(): boolean
public "hasServerUpdateStatistics"(): boolean
public "mergeServerConnectResponse"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Type): $SparkWebSocketProtos$PacketWrapper$Builder
public "hasServerUpdateSampler"(): boolean
public "getServerUpdateSampler"(): $SparkWebSocketProtos$ServerUpdateSamplerData
public "clearServerUpdateStatistics"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "clearServerConnectResponse"(): $SparkWebSocketProtos$PacketWrapper$Builder
public "clearServerUpdateSampler"(): $SparkWebSocketProtos$PacketWrapper$Builder
get "packetCase"(): $SparkWebSocketProtos$PacketWrapper$PacketCase
get "clientPing"(): $SparkWebSocketProtos$ClientPing
get "clientConnect"(): $SparkWebSocketProtos$ClientConnect
set "serverPong"(value: $SparkWebSocketProtos$ServerPong$Type)
set "serverPong"(value: $SparkWebSocketProtos$ServerPong$Builder$Type)
set "serverConnectResponse"(value: $SparkWebSocketProtos$ServerConnectResponse$Type)
set "serverConnectResponse"(value: $SparkWebSocketProtos$ServerConnectResponse$Builder$Type)
set "serverUpdateSampler"(value: $SparkWebSocketProtos$ServerUpdateSamplerData$Type)
set "serverUpdateSampler"(value: $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type)
set "serverUpdateStatistics"(value: $SparkWebSocketProtos$ServerUpdateStatistics$Type)
set "serverUpdateStatistics"(value: $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type)
get "serverPong"(): $SparkWebSocketProtos$ServerPong
set "clientConnect"(value: $SparkWebSocketProtos$ClientConnect$Builder$Type)
set "clientConnect"(value: $SparkWebSocketProtos$ClientConnect$Type)
set "clientPing"(value: $SparkWebSocketProtos$ClientPing$Type)
set "clientPing"(value: $SparkWebSocketProtos$ClientPing$Builder$Type)
get "serverConnectResponse"(): $SparkWebSocketProtos$ServerConnectResponse
get "serverUpdateStatistics"(): $SparkWebSocketProtos$ServerUpdateStatistics
get "serverUpdateSampler"(): $SparkWebSocketProtos$ServerUpdateSamplerData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$PacketWrapper$Builder$Type = ($SparkWebSocketProtos$PacketWrapper$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$PacketWrapper$Builder_ = $SparkWebSocketProtos$PacketWrapper$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/platform/$PlatformInfo$Data" {
import {$PlatformInfo$Type, $PlatformInfo$Type$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo$Type"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"

export class $PlatformInfo$Data {

constructor(arg0: $PlatformInfo$Type$Type, arg1: string, arg2: string, arg3: string, arg4: integer)

public "getName"(): string
public "getType"(): $PlatformInfo$Type
public "getVersion"(): string
public "getSparkVersion"(): integer
public "toProto"(): $SparkProtos$PlatformMetadata
public "getMinecraftVersion"(): string
get "name"(): string
get "type"(): $PlatformInfo$Type
get "version"(): string
get "sparkVersion"(): integer
get "minecraftVersion"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PlatformInfo$Data$Type = ($PlatformInfo$Data);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PlatformInfo$Data_ = $PlatformInfo$Data$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$NBTComponentImpl, $NBTComponentImpl$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentImpl"

export class $EntityNBTComponentImpl extends $NBTComponentImpl<($EntityNBTComponent), ($EntityNBTComponent$Builder)> implements $EntityNBTComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "separator"(): $Component
public "style"(style: $Style$Type): $EntityNBTComponent
public "selector"(): string
public "selector"(selector: string): $EntityNBTComponent
public "toBuilder"(): $EntityNBTComponent$Builder
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $EntityNBTComponent
public "append"(like: $ComponentLike$Type): $EntityNBTComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $EntityNBTComponent
public "color"(color: $TextColor$Type): $EntityNBTComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $EntityNBTComponent
public "style"(style: $Style$Builder$Type): $EntityNBTComponent
public "mergeStyle"(that: $Component$Type): $EntityNBTComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $EntityNBTComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $EntityNBTComponent
public "colorIfAbsent"(color: $TextColor$Type): $EntityNBTComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $EntityNBTComponent
public "clickEvent"(event: $ClickEvent$Type): $EntityNBTComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $EntityNBTComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $EntityNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EntityNBTComponentImpl$Type = ($EntityNBTComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EntityNBTComponentImpl_ = $EntityNBTComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/ping/$PingSummary" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PingSummary {

constructor(arg0: (integer)[])

public "min"(): integer
public "max"(): integer
public "total"(): integer
public "mean"(): double
public "percentile95th"(): double
public "median"(): double
public "percentile"(arg0: double): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PingSummary$Type = ($PingSummary);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PingSummary_ = $PingSummary$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk" {
import {$SparkProtos$WorldStatistics$Chunk$Builder, $SparkProtos$WorldStatistics$Chunk$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkProtos$WorldStatistics$ChunkOrBuilder, $SparkProtos$WorldStatistics$ChunkOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$ChunkOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$WorldStatistics$Chunk extends $GeneratedMessageLite<($SparkProtos$WorldStatistics$Chunk), ($SparkProtos$WorldStatistics$Chunk$Builder)> implements $SparkProtos$WorldStatistics$ChunkOrBuilder {
static readonly "X_FIELD_NUMBER": integer
static readonly "Z_FIELD_NUMBER": integer
static readonly "TOTAL_ENTITIES_FIELD_NUMBER": integer
static readonly "ENTITY_COUNTS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$WorldStatistics$Chunk)>
public static "newBuilder"(): $SparkProtos$WorldStatistics$Chunk$Builder
public static "newBuilder"(arg0: $SparkProtos$WorldStatistics$Chunk$Type): $SparkProtos$WorldStatistics$Chunk$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$Chunk
public static "getDefaultInstance"(): $SparkProtos$WorldStatistics$Chunk
public "getZ"(): integer
public "getX"(): integer
public "containsEntityCounts"(arg0: string): boolean
public "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
public "getEntityCountsCount"(): integer
public "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
public "getEntityCounts"(): $Map<(string), (integer)>
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$WorldStatistics$Chunk
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Chunk
public "getEntityCountsMap"(): $Map<(string), (integer)>
public "getTotalEntities"(): integer
get "defaultInstance"(): $SparkProtos$WorldStatistics$Chunk
get "z"(): integer
get "x"(): integer
get "entityCountsCount"(): integer
get "entityCounts"(): $Map<(string), (integer)>
get "entityCountsMap"(): $Map<(string), (integer)>
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Chunk$Type = ($SparkProtos$WorldStatistics$Chunk);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$Chunk_ = $SparkProtos$WorldStatistics$Chunk$Type;
}}
declare module "packages/me/lucko/spark/common/util/$MethodDisambiguator$MethodDescription" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MethodDisambiguator$MethodDescription {


public "getName"(): string
public "toString"(): string
public "getDesc"(): string
get "name"(): string
get "desc"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodDisambiguator$MethodDescription$Type = ($MethodDisambiguator$MethodDescription);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodDisambiguator$MethodDescription_ = $MethodDisambiguator$MethodDescription$Type;
}}
declare module "packages/me/lucko/spark/common/heapdump/$HeapDump" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $HeapDump extends $Enum<($HeapDump)> {


public static "values"(): ($HeapDump)[]
public static "valueOf"(arg0: string): $HeapDump
public static "isOpenJ9"(): boolean
public static "dumpHeap"(arg0: $Path$Type, arg1: boolean): void
get "openJ9"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeapDump$Type = (never) | ($HeapDump);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeapDump_ = $HeapDump$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer" {
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Pagination$Renderer {

 "renderEmpty"(): $Component
 "renderUnknownPage"(page: integer, pages: integer): $Component
 "renderHeader"(title: $Component$Type, page: integer, pages: integer): $Component
 "renderPreviousPageButton"(character: character, style: $Style$Type, clickEvent: $ClickEvent$Type): $Component
 "renderNextPageButton"(character: character, style: $Style$Type, clickEvent: $ClickEvent$Type): $Component
}

export namespace $Pagination$Renderer {
const GRAY_LEFT_ROUND_BRACKET: $Component
const GRAY_LEFT_SQUARE_BRACKET: $Component
const GRAY_RIGHT_ROUND_BRACKET: $Component
const GRAY_RIGHT_SQUARE_BRACKET: $Component
const GRAY_FORWARD_SLASH: $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$Renderer$Type = ($Pagination$Renderer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination$Renderer_ = $Pagination$Renderer$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/cpu/$CpuInfo" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $CpuInfo extends $Enum<($CpuInfo)> {


public static "values"(): ($CpuInfo)[]
public static "valueOf"(arg0: string): $CpuInfo
public static "queryCpuModel"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CpuInfo$Type = (never) | ($CpuInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CpuInfo_ = $CpuInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ComponentSerializer, $ComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/$ComponentSerializer"
import {$LegacyComponentSerializer$Builder, $LegacyComponentSerializer$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyComponentSerializer$Builder"
import {$LegacyFormat, $LegacyFormat$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/legacy/$LegacyFormat"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $LegacyComponentSerializer extends $ComponentSerializer<($Component), ($TextComponent), (string)>, $Buildable<($LegacyComponentSerializer), ($LegacyComponentSerializer$Builder)> {

 "deserialize"(input: string): $TextComponent
 "serialize"(component: $Component$Type): string
 "deserializeOrNull"(input: string): $TextComponent
 "serializeOr"(component: $Component$Type, fallback: string): string
 "serializeOrNull"(component: $Component$Type): string
/**
 * 
 * @deprecated
 */
 "deseializeOrNull"(input: string): $TextComponent
 "deserializeOr"(input: string, fallback: $TextComponent$Type): $TextComponent
 "toBuilder"(): $LegacyComponentSerializer$Builder
}

export namespace $LegacyComponentSerializer {
const SECTION_CHAR: character
const AMPERSAND_CHAR: character
const HEX_CHAR: character
function builder(): $LegacyComponentSerializer$Builder
function legacy(legacyCharacter: character): $LegacyComponentSerializer
function parseChar(character: character): $LegacyFormat
function legacySection(): $LegacyComponentSerializer
function legacyAmpersand(): $LegacyComponentSerializer
function configureAndBuild<R, B>(builder: $LegacyComponentSerializer$Builder$Type, consumer: $Consumer$Type<(any)>): $LegacyComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyComponentSerializer$Type = ($LegacyComponentSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyComponentSerializer_ = $LegacyComponentSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata" {
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Handshakedata {

 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $Handshakedata {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Handshakedata$Type = ($Handshakedata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Handshakedata_ = $Handshakedata$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$LegacyFormattingDetected" {
import {$Nag, $Nag$Type} from "packages/me/lucko/spark/lib/adventure/util/$Nag"

export class $LegacyFormattingDetected extends $Nag {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LegacyFormattingDetected$Type = ($LegacyFormattingDetected);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LegacyFormattingDetected_ = $LegacyFormattingDetected$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound" {
import {$Sound$Builder, $Sound$Builder$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Builder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Sound$Type, $Sound$Type$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type"
import {$Sound$Source$Provider, $Sound$Source$Provider$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source$Provider"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OptionalLong, $OptionalLong$Type} from "packages/java/util/$OptionalLong"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"

export interface $Sound extends $Examinable {

 "name"(): $Key
 "source"(): $Sound$Source
 "seed"(): $OptionalLong
 "pitch"(): float
 "volume"(): float
 "asStop"(): $SoundStop
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $Sound {
function sound(type: $Sound$Type$Type, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
function sound(type: $Supplier$Type<(any)>, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
function sound(name: $Key$Type, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
function sound(configurer: $Consumer$Type<($Sound$Builder$Type)>): $Sound
function sound(existing: $Sound$Type): $Sound$Builder
function sound(): $Sound$Builder
function sound(name: $Key$Type, source: $Sound$Source$Provider$Type, volume: float, pitch: float): $Sound
function sound(type: $Supplier$Type<(any)>, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
function sound(type: $Sound$Type$Type, source: $Sound$Source$Type, volume: float, pitch: float): $Sound
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Type = ($Sound);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound_ = $Sound$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BinaryWriter" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$BufferAllocator, $BufferAllocator$Type} from "packages/me/lucko/spark/lib/protobuf/$BufferAllocator"
import {$ByteOutput, $ByteOutput$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteOutput"
import {$List, $List$Type} from "packages/java/util/$List"
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"
import {$Queue, $Queue$Type} from "packages/java/util/$Queue"
import {$Writer$FieldOrder, $Writer$FieldOrder$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer$FieldOrder"
import {$AllocatedBuffer, $AllocatedBuffer$Type} from "packages/me/lucko/spark/lib/protobuf/$AllocatedBuffer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $BinaryWriter extends $ByteOutput implements $Writer {
static readonly "DEFAULT_CHUNK_SIZE": integer


public "writeMessageSetItem"(arg0: integer, arg1: any): void
public "writeFloat"(arg0: integer, arg1: float): void
public "writeDouble"(arg0: integer, arg1: double): void
public "complete"(): $Queue<($AllocatedBuffer)>
public "writeInt64"(arg0: integer, arg1: long): void
public "writeSFixed32"(arg0: integer, arg1: integer): void
public "writeSFixed64"(arg0: integer, arg1: long): void
public "writeUInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeFloatList"(arg0: integer, arg1: $List$Type<(float)>, arg2: boolean): void
public "writeDoubleList"(arg0: integer, arg1: $List$Type<(double)>, arg2: boolean): void
public "writeUInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeSFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeBoolList"(arg0: integer, arg1: $List$Type<(boolean)>, arg2: boolean): void
/**
 * 
 * @deprecated
 */
public "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "writeGroupList"(arg0: integer, arg1: $List$Type<(any)>): void
public "writeSFixed64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeSInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeFixed32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeBytesList"(arg0: integer, arg1: $List$Type<($ByteString$Type)>): void
public "writeStringList"(arg0: integer, arg1: $List$Type<(string)>): void
public "writeInt32List"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>): void
public "writeMessageList"(arg0: integer, arg1: $List$Type<(any)>, arg2: $Schema$Type<(any)>): void
public "writeSInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeInt64List"(arg0: integer, arg1: $List$Type<(long)>, arg2: boolean): void
public "writeEnumList"(arg0: integer, arg1: $List$Type<(integer)>, arg2: boolean): void
public "writeEnum"(arg0: integer, arg1: integer): void
public "fieldOrder"(): $Writer$FieldOrder
public "writeMap"<K, V>(arg0: integer, arg1: $MapEntryLite$Metadata$Type<(K), (V)>, arg2: $Map$Type<(K), (V)>): void
public static "newDirectInstance"(arg0: $BufferAllocator$Type): $BinaryWriter
public static "newDirectInstance"(arg0: $BufferAllocator$Type, arg1: integer): $BinaryWriter
public static "newHeapInstance"(arg0: $BufferAllocator$Type): $BinaryWriter
public static "newHeapInstance"(arg0: $BufferAllocator$Type, arg1: integer): $BinaryWriter
public "getTotalBytesWritten"(): integer
public "writeBytes"(arg0: integer, arg1: $ByteString$Type): void
public "writeString"(arg0: integer, arg1: string): void
public "writeSInt64"(arg0: integer, arg1: long): void
public "writeMessage"(arg0: integer, arg1: any): void
public "writeMessage"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
public "writeUInt64"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
public "writeStartGroup"(arg0: integer): void
public "writeInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "writeEndGroup"(arg0: integer): void
public "writeFixed32"(arg0: integer, arg1: integer): void
public "writeUInt32"(arg0: integer, arg1: integer): void
public "writeFixed64"(arg0: integer, arg1: long): void
public "writeSInt32"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
public "writeGroup"(arg0: integer, arg1: any, arg2: $Schema$Type<(any)>): void
/**
 * 
 * @deprecated
 */
public "writeGroup"(arg0: integer, arg1: any): void
public "writeBool"(arg0: integer, arg1: boolean): void
get "totalBytesWritten"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryWriter$Type = ($BinaryWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryWriter_ = $BinaryWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$CompressionExtension" {
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$DefaultExtension, $DefaultExtension$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$DefaultExtension"

export class $CompressionExtension extends $DefaultExtension {

constructor()

public "isFrameValid"(arg0: $Framedata$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CompressionExtension$Type = ($CompressionExtension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CompressionExtension_ = $CompressionExtension$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ListFieldSchema" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ListFieldSchema {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ListFieldSchema$Type = ($ListFieldSchema);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ListFieldSchema_ = $ListFieldSchema$Type;
}}
declare module "packages/me/lucko/spark/common/command/sender/$CommandSender" {
import {$UUID, $UUID$Type} from "packages/java/util/$UUID"
import {$CommandSender$Data, $CommandSender$Data$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender$Data"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $CommandSender {

 "getName"(): string
 "toData"(): $CommandSender$Data
 "sendMessage"(arg0: $Component$Type): void
 "getUniqueId"(): $UUID
 "hasPermission"(arg0: string): boolean
}

export namespace $CommandSender {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandSender$Type = ($CommandSender);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandSender_ = $CommandSender$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$ProcessProvider" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $ByteBuddyAgent$ProcessProvider {

 "resolve"(): string

(): string
}

export namespace $ByteBuddyAgent$ProcessProvider {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBuddyAgent$ProcessProvider$Type = ($ByteBuddyAgent$ProcessProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBuddyAgent$ProcessProvider_ = $ByteBuddyAgent$ProcessProvider$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder, $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata"

export class $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SamplerMetadata$SourceMetadata), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder)> implements $SparkSamplerProtos$SamplerMetadata$SourceMetadataOrBuilder {


public "getName"(): string
public "setName"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public "getVersion"(): string
public "setVersion"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public "setNameBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public "getVersionBytes"(): $ByteString
public "clearVersion"(): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
public "setVersionBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder
get "name"(): string
set "name"(value: string)
get "version"(): string
set "version"(value: string)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "versionBytes"(): $ByteString
set "versionBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder$Type = ($SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder_ = $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/ws/$CryptoAlgorithm" {
import {$PublicKey, $PublicKey$Type} from "packages/java/security/$PublicKey"
import {$KeyPair, $KeyPair$Type} from "packages/java/security/$KeyPair"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Signature, $Signature$Type} from "packages/java/security/$Signature"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$KeyFactory, $KeyFactory$Type} from "packages/java/security/$KeyFactory"
import {$KeyPairGenerator, $KeyPairGenerator$Type} from "packages/java/security/$KeyPairGenerator"

export class $CryptoAlgorithm extends $Enum<($CryptoAlgorithm)> {
static readonly "Ed25519": $CryptoAlgorithm
static readonly "RSA2048": $CryptoAlgorithm


public static "values"(): ($CryptoAlgorithm)[]
public static "valueOf"(arg0: string): $CryptoAlgorithm
public "generateKeyPair"(): $KeyPair
public "createKeyPairGenerator"(): $KeyPairGenerator
public "decodePublicKey"(arg0: $ByteString$Type): $PublicKey
public "decodePublicKey"(arg0: (byte)[]): $PublicKey
public "createSignature"(): $Signature
public "createKeyFactory"(): $KeyFactory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CryptoAlgorithm$Type = (("rsa2048") | ("ed25519")) | ($CryptoAlgorithm);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CryptoAlgorithm_ = $CryptoAlgorithm$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar" {
import {$BossBar$Listener, $BossBar$Listener$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Listener"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$BossBar$Color, $BossBar$Color$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Color"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$BossBar$Flag, $BossBar$Flag$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Flag"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$BossBar$Overlay, $BossBar$Overlay$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Overlay"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $BossBar extends $Examinable {

 "removeFlag"(flag: $BossBar$Flag$Type): $BossBar
 "name"(): $Component
 "name"(name: $ComponentLike$Type): $BossBar
 "name"(name: $Component$Type): $BossBar
 "flags"(): $Set<($BossBar$Flag)>
 "flags"(flags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
 "color"(): $BossBar$Color
 "color"(color: $BossBar$Color$Type): $BossBar
/**
 * 
 * @deprecated
 */
 "percent"(): float
/**
 * 
 * @deprecated
 */
 "percent"(progress: float): $BossBar
 "addFlag"(flag: $BossBar$Flag$Type): $BossBar
 "hasFlag"(flag: $BossBar$Flag$Type): boolean
 "removeListener"(listener: $BossBar$Listener$Type): $BossBar
 "overlay"(overlay: $BossBar$Overlay$Type): $BossBar
 "overlay"(): $BossBar$Overlay
 "addFlags"(flags: $Iterable$Type<($BossBar$Flag$Type)>): $BossBar
 "addFlags"(...flags: ($BossBar$Flag$Type)[]): $BossBar
 "progress"(progress: float): $BossBar
 "progress"(): float
 "addListener"(listener: $BossBar$Listener$Type): $BossBar
 "removeFlags"(flags: $Iterable$Type<($BossBar$Flag$Type)>): $BossBar
 "removeFlags"(...flags: ($BossBar$Flag$Type)[]): $BossBar
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $BossBar {
const MIN_PROGRESS: float
const MAX_PROGRESS: float
const MIN_PERCENT: float
const MAX_PERCENT: float
function bossBar(name: $ComponentLike$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type): $BossBar
function bossBar(name: $Component$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type, flags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
function bossBar(name: $Component$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type): $BossBar
function bossBar(name: $ComponentLike$Type, progress: float, color: $BossBar$Color$Type, overlay: $BossBar$Overlay$Type, flags: $Set$Type<($BossBar$Flag$Type)>): $BossBar
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBar$Type = ($BossBar);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBar_ = $BossBar$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ProtoSyntax" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ProtoSyntax extends $Enum<($ProtoSyntax)> {
static readonly "PROTO2": $ProtoSyntax
static readonly "PROTO3": $ProtoSyntax


public static "values"(): ($ProtoSyntax)[]
public static "valueOf"(arg0: string): $ProtoSyntax
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtoSyntax$Type = (("proto3") | ("proto2")) | ($ProtoSyntax);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtoSyntax_ = $ProtoSyntax$Type;
}}
declare module "packages/me/lucko/spark/common/util/$ClassFinder" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ClassFinder {

constructor()

public "findClass"(arg0: string): $Class<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassFinder$Type = ($ClassFinder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassFinder_ = $ClassFinder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Socket" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $BytesocksClient$Socket {

 "isOpen"(): boolean
 "close"(arg0: integer, arg1: string): void
 "send"(arg0: string): void
 "channelId"(): string
}

export namespace $BytesocksClient$Socket {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesocksClient$Socket$Type = ($BytesocksClient$Socket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesocksClient$Socket_ = $BytesocksClient$Socket$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Command$Executor" {
import {$Arguments, $Arguments$Type} from "packages/me/lucko/spark/common/command/$Arguments"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"
import {$CommandResponseHandler, $CommandResponseHandler$Type} from "packages/me/lucko/spark/common/command/$CommandResponseHandler"

export interface $Command$Executor {

 "execute"(arg0: $SparkPlatform$Type, arg1: $CommandSender$Type, arg2: $CommandResponseHandler$Type, arg3: $Arguments$Type): void

(arg0: $SparkPlatform$Type, arg1: $CommandSender$Type, arg2: $CommandResponseHandler$Type, arg3: $Arguments$Type): void
}

export namespace $Command$Executor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Command$Executor$Type = ($Command$Executor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Command$Executor_ = $Command$Executor$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/translation/$TranslationLocales" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TranslationLocales {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslationLocales$Type = ($TranslationLocales);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslationLocales_ = $TranslationLocales$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$MessageType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

/**
 * 
 * @deprecated
 */
export class $MessageType extends $Enum<($MessageType)> {
/**
 * 
 * @deprecated
 */
static readonly "CHAT": $MessageType
/**
 * 
 * @deprecated
 */
static readonly "SYSTEM": $MessageType


public static "values"(): ($MessageType)[]
public static "valueOf"(name: string): $MessageType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageType$Type = (("system") | ("chat")) | ($MessageType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageType_ = $MessageType$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WrappedByteChannel" {
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export interface $WrappedByteChannel extends $ByteChannel {

 "isBlocking"(): boolean
 "isNeedWrite"(): boolean
 "writeMore"(): void
 "isNeedRead"(): boolean
 "readMore"(arg0: $ByteBuffer$Type): integer
 "read"(arg0: $ByteBuffer$Type): integer
 "write"(arg0: $ByteBuffer$Type): integer
 "isOpen"(): boolean
 "close"(): void
}

export namespace $WrappedByteChannel {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedByteChannel$Type = ($WrappedByteChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedByteChannel_ = $WrappedByteChannel$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$IntArrayList" {
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PrimitiveNonBoxingCollection, $PrimitiveNonBoxingCollection$Type} from "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection"
import {$Internal$IntList, $Internal$IntList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$IntList"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"

export class $IntArrayList extends $AbstractProtobufList<(integer)> implements $Internal$IntList, $RandomAccess, $PrimitiveNonBoxingCollection {


public "add"(arg0: integer): boolean
public "add"(arg0: integer, arg1: integer): void
public "remove"(arg0: integer): integer
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "getInt"(arg0: integer): integer
public "size"(): integer
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: integer): integer
public static "emptyList"(): $IntArrayList
public "setInt"(arg0: integer, arg1: integer): integer
public "addInt"(arg0: integer): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $List<(integer)>
public static "of"<E>(arg0: integer): $List<(integer)>
public static "of"<E>(): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
public static "of"<E>(...arg0: (integer)[]): $List<(integer)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntArrayList$Type = ($IntArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntArrayList_ = $IntArrayList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$HackyBossBarPlatformBridge" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
/**
 * 
 * @deprecated
 */
export class $HackyBossBarPlatformBridge {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HackyBossBarPlatformBridge$Type = ($HackyBossBarPlatformBridge);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HackyBossBarPlatformBridge_ = $HackyBossBarPlatformBridge$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$SparkWebSocketProtos$ServerPong$Builder, $SparkWebSocketProtos$ServerPong$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong$Builder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkWebSocketProtos$ServerPongOrBuilder, $SparkWebSocketProtos$ServerPongOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPongOrBuilder"

export class $SparkWebSocketProtos$ServerPong extends $GeneratedMessageLite<($SparkWebSocketProtos$ServerPong), ($SparkWebSocketProtos$ServerPong$Builder)> implements $SparkWebSocketProtos$ServerPongOrBuilder {
static readonly "OK_FIELD_NUMBER": integer
static readonly "DATA_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ServerPong)>
public "getData"(): integer
public static "newBuilder"(arg0: $SparkWebSocketProtos$ServerPong$Type): $SparkWebSocketProtos$ServerPong$Builder
public static "newBuilder"(): $SparkWebSocketProtos$ServerPong$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerPong
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public static "getDefaultInstance"(): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ServerPong
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerPong
public "getOk"(): boolean
get "data"(): integer
get "defaultInstance"(): $SparkWebSocketProtos$ServerPong
get "ok"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerPong$Type = ($SparkWebSocketProtos$ServerPong);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerPong_ = $SparkWebSocketProtos$ServerPong$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$SelectorComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $SelectorComponentImpl extends $AbstractComponent implements $SelectorComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "separator"(separator: $ComponentLike$Type): $SelectorComponent
public "separator"(): $Component
public "style"(style: $Style$Type): $SelectorComponent
public "pattern"(): string
public "pattern"(pattern: string): $SelectorComponent
public "toBuilder"(): $SelectorComponent$Builder
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $SelectorComponent
public "append"(like: $ComponentLike$Type): $SelectorComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $SelectorComponent
public "color"(color: $TextColor$Type): $SelectorComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $SelectorComponent
public "style"(style: $Style$Builder$Type): $SelectorComponent
public "mergeStyle"(that: $Component$Type): $SelectorComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $SelectorComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $SelectorComponent
public "colorIfAbsent"(color: $TextColor$Type): $SelectorComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $SelectorComponent
public "clickEvent"(event: $ClickEvent$Type): $SelectorComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $SelectorComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $SelectorComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectorComponentImpl$Type = ($SelectorComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectorComponentImpl_ = $SelectorComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/common/activitylog/$ActivityLog" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Activity, $Activity$Type} from "packages/me/lucko/spark/common/activitylog/$Activity"

export class $ActivityLog {

constructor(arg0: $Path$Type)

public "load"(): void
public "save"(): void
public "addToLog"(arg0: $Activity$Type): void
public "getLog"(): $List<($Activity)>
get "log"(): $List<($Activity)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ActivityLog$Type = ($ActivityLog);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ActivityLog_ = $ActivityLog$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig" {
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $TextReplacementConfig extends $Buildable<($TextReplacementConfig), ($TextReplacementConfig$Builder)>, $Examinable {

 "matchPattern"(): $Pattern
 "toBuilder"(): $TextReplacementConfig$Builder
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $TextReplacementConfig {
function builder(): $TextReplacementConfig$Builder
function configureAndBuild<R, B>(builder: $TextReplacementConfig$Builder$Type, consumer: $Consumer$Type<(any)>): $TextReplacementConfig
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementConfig$Type = ($TextReplacementConfig);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementConfig_ = $TextReplacementConfig$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Builder" {
import {$SparkProtos$SystemStatistics$Cpu$Usage$Builder, $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage$Builder"
import {$SparkProtos$SystemStatistics$Cpu$Usage, $SparkProtos$SystemStatistics$Cpu$Usage$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Usage"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$SystemStatistics$CpuOrBuilder, $SparkProtos$SystemStatistics$CpuOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$CpuOrBuilder"
import {$SparkProtos$SystemStatistics$Cpu, $SparkProtos$SystemStatistics$Cpu$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu"

export class $SparkProtos$SystemStatistics$Cpu$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics$Cpu), ($SparkProtos$SystemStatistics$Cpu$Builder)> implements $SparkProtos$SystemStatistics$CpuOrBuilder {


public "getThreads"(): integer
public "clearThreads"(): $SparkProtos$SystemStatistics$Cpu$Builder
public "setThreads"(arg0: integer): $SparkProtos$SystemStatistics$Cpu$Builder
public "getModelName"(): string
public "setSystemUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "setSystemUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "setProcessUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "setProcessUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "setModelName"(arg0: string): $SparkProtos$SystemStatistics$Cpu$Builder
public "hasProcessUsage"(): boolean
public "getProcessUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
public "mergeProcessUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "hasSystemUsage"(): boolean
public "getSystemUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
public "clearSystemUsage"(): $SparkProtos$SystemStatistics$Cpu$Builder
public "clearProcessUsage"(): $SparkProtos$SystemStatistics$Cpu$Builder
public "mergeSystemUsage"(arg0: $SparkProtos$SystemStatistics$Cpu$Usage$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "getModelNameBytes"(): $ByteString
public "setModelNameBytes"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Cpu$Builder
public "clearModelName"(): $SparkProtos$SystemStatistics$Cpu$Builder
get "threads"(): integer
set "threads"(value: integer)
get "modelName"(): string
set "systemUsage"(value: $SparkProtos$SystemStatistics$Cpu$Usage$Type)
set "systemUsage"(value: $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type)
set "processUsage"(value: $SparkProtos$SystemStatistics$Cpu$Usage$Type)
set "processUsage"(value: $SparkProtos$SystemStatistics$Cpu$Usage$Builder$Type)
set "modelName"(value: string)
get "processUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
get "systemUsage"(): $SparkProtos$SystemStatistics$Cpu$Usage
get "modelNameBytes"(): $ByteString
set "modelNameBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Cpu$Builder$Type = ($SparkProtos$SystemStatistics$Cpu$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Cpu$Builder_ = $SparkProtos$SystemStatistics$Cpu$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener" {
import {$FlattenerListener, $FlattenerListener$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$FlattenerListener"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ComponentFlattener$Builder, $ComponentFlattener$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener$Builder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $ComponentFlattener extends $Buildable<($ComponentFlattener), ($ComponentFlattener$Builder)> {

 "flatten"(input: $Component$Type, listener: $FlattenerListener$Type): void
 "toBuilder"(): $ComponentFlattener$Builder
}

export namespace $ComponentFlattener {
function textOnly(): $ComponentFlattener
function builder(): $ComponentFlattener$Builder
function basic(): $ComponentFlattener
function configureAndBuild<R, B>(builder: $ComponentFlattener$Builder$Type, consumer: $Consumer$Type<(any)>): $ComponentFlattener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFlattener$Type = ($ComponentFlattener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentFlattener_ = $ComponentFlattener$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UninitializedMessageException" {
import {$List, $List$Type} from "packages/java/util/$List"
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$InvalidProtocolBufferException, $InvalidProtocolBufferException$Type} from "packages/me/lucko/spark/lib/protobuf/$InvalidProtocolBufferException"

export class $UninitializedMessageException extends $RuntimeException {

constructor(arg0: $MessageLite$Type)
constructor(arg0: $List$Type<(string)>)

public "getMissingFields"(): $List<(string)>
public "asInvalidProtocolBufferException"(): $InvalidProtocolBufferException
get "missingFields"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UninitializedMessageException$Type = ($UninitializedMessageException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UninitializedMessageException_ = $UninitializedMessageException$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeTickReporter" {
import {$TickEvent, $TickEvent$Type} from "packages/net/minecraftforge/event/$TickEvent"
import {$TickEvent$Type, $TickEvent$Type$Type} from "packages/net/minecraftforge/event/$TickEvent$Type"
import {$TickReporter$Callback, $TickReporter$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickReporter$Callback"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"
import {$SimpleTickReporter, $SimpleTickReporter$Type} from "packages/me/lucko/spark/common/tick/$SimpleTickReporter"

export class $ForgeTickReporter extends $SimpleTickReporter implements $TickReporter {

constructor(arg0: $TickEvent$Type$Type)

public "start"(): void
public "close"(): void
public "onTick"(arg0: $TickEvent$Type): void
public "removeCallback"(arg0: $TickReporter$Callback$Type): void
public "addCallback"(arg0: $TickReporter$Callback$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeTickReporter$Type = ($ForgeTickReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeTickReporter_ = $ForgeTickReporter$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidDataException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $InvalidDataException extends $Exception {

constructor(arg0: integer, arg1: string, arg2: $Throwable$Type)
constructor(arg0: integer, arg1: $Throwable$Type)
constructor(arg0: integer, arg1: string)
constructor(arg0: integer)

public "getCloseCode"(): integer
get "closeCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidDataException$Type = ($InvalidDataException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidDataException_ = $InvalidDataException$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformMetadata$Type, $SparkProtos$PlatformMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Type"
import {$SparkProtos$PlatformMetadataOrBuilder, $SparkProtos$PlatformMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadataOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"

export class $SparkProtos$PlatformMetadata$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformMetadata), ($SparkProtos$PlatformMetadata$Builder)> implements $SparkProtos$PlatformMetadataOrBuilder {


public "getName"(): string
public "setName"(arg0: string): $SparkProtos$PlatformMetadata$Builder
public "getType"(): $SparkProtos$PlatformMetadata$Type
public "getVersion"(): string
public "setType"(arg0: $SparkProtos$PlatformMetadata$Type$Type): $SparkProtos$PlatformMetadata$Builder
public "setVersion"(arg0: string): $SparkProtos$PlatformMetadata$Builder
public "getSparkVersion"(): integer
public "setNameBytes"(arg0: $ByteString$Type): $SparkProtos$PlatformMetadata$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkProtos$PlatformMetadata$Builder
public "setSparkVersion"(arg0: integer): $SparkProtos$PlatformMetadata$Builder
public "getMinecraftVersion"(): string
public "setMinecraftVersion"(arg0: string): $SparkProtos$PlatformMetadata$Builder
public "getMinecraftVersionBytes"(): $ByteString
public "setMinecraftVersionBytes"(arg0: $ByteString$Type): $SparkProtos$PlatformMetadata$Builder
public "clearMinecraftVersion"(): $SparkProtos$PlatformMetadata$Builder
public "getTypeValue"(): integer
public "getVersionBytes"(): $ByteString
public "clearSparkVersion"(): $SparkProtos$PlatformMetadata$Builder
public "clearVersion"(): $SparkProtos$PlatformMetadata$Builder
public "setVersionBytes"(arg0: $ByteString$Type): $SparkProtos$PlatformMetadata$Builder
public "clearType"(): $SparkProtos$PlatformMetadata$Builder
public "setTypeValue"(arg0: integer): $SparkProtos$PlatformMetadata$Builder
get "name"(): string
set "name"(value: string)
get "type"(): $SparkProtos$PlatformMetadata$Type
get "version"(): string
set "type"(value: $SparkProtos$PlatformMetadata$Type$Type)
set "version"(value: string)
get "sparkVersion"(): integer
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
set "sparkVersion"(value: integer)
get "minecraftVersion"(): string
set "minecraftVersion"(value: string)
get "minecraftVersionBytes"(): $ByteString
set "minecraftVersionBytes"(value: $ByteString$Type)
get "typeValue"(): integer
get "versionBytes"(): $ByteString
set "versionBytes"(value: $ByteString$Type)
set "typeValue"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformMetadata$Builder$Type = ($SparkProtos$PlatformMetadata$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformMetadata$Builder_ = $SparkProtos$PlatformMetadata$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/$AbstractExaminer" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $AbstractExaminer<R> implements $Examiner<(R)> {

constructor()

public "examine"(values: (float)[]): R
public "examine"(values: (double)[]): R
public "examine"(values: (character)[]): R
public "examine"(values: (integer)[]): R
public "examine"(values: (short)[]): R
public "examine"(values: (long)[]): R
public "examine"(name: string, properties: $Stream$Type<(any)>): R
public "examine"(value: any): R
public "examine"(values: (byte)[]): R
public "examine"(values: (boolean)[]): R
public "examine"(value: integer): R
public "examine"(value: float): R
public "examine"(value: string): R
public "examine"(value: short): R
public "examine"(value: long): R
public "examine"(value: boolean): R
public "examine"(examinable: $Examinable$Type): R
public "examine"(value: double): R
public "examine"(value: character): R
public "examine"(value: byte): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractExaminer$Type<R> = ($AbstractExaminer<(R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractExaminer_<R> = $AbstractExaminer$Type<(R)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StringValue" {
import {$StringValueOrBuilder, $StringValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$StringValueOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$StringValue$Builder, $StringValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$StringValue$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $StringValue extends $GeneratedMessageLite<($StringValue), ($StringValue$Builder)> implements $StringValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): string
public static "of"(arg0: string): $StringValue
public static "parser"(): $Parser<($StringValue)>
public static "newBuilder"(): $StringValue$Builder
public static "newBuilder"(arg0: $StringValue$Type): $StringValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $StringValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $StringValue
public static "getDefaultInstance"(): $StringValue
public static "parseFrom"(arg0: $InputStream$Type): $StringValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $StringValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $StringValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $StringValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $StringValue
public static "parseFrom"(arg0: (byte)[]): $StringValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $StringValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $StringValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $StringValue
public static "parseFrom"(arg0: $ByteString$Type): $StringValue
public "getValueBytes"(): $ByteString
get "value"(): string
get "defaultInstance"(): $StringValue
get "valueBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringValue$Type = ($StringValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringValue_ = $StringValue$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$Gson, $Gson$Type} from "packages/com/google/gson/$Gson"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$GsonComponentSerializer$Builder, $GsonComponentSerializer$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer$Builder"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$ComponentSerializer, $ComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/$ComponentSerializer"
import {$GsonBuilder, $GsonBuilder$Type} from "packages/com/google/gson/$GsonBuilder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $GsonComponentSerializer extends $ComponentSerializer<($Component), ($Component), (string)>, $Buildable<($GsonComponentSerializer), ($GsonComponentSerializer$Builder)> {

 "populator"(): $UnaryOperator<($GsonBuilder)>
 "serializer"(): $Gson
 "serializeToTree"(component: $Component$Type): $JsonElement
 "deserializeFromTree"(input: $JsonElement$Type): $Component
 "deserialize"(input: string): $Component
 "serialize"(component: $Component$Type): string
 "deserializeOrNull"(input: string): $Component
 "serializeOr"(component: $Component$Type, fallback: string): string
 "serializeOrNull"(component: $Component$Type): string
/**
 * 
 * @deprecated
 */
 "deseializeOrNull"(input: string): $Component
 "deserializeOr"(input: string, fallback: $Component$Type): $Component
 "toBuilder"(): $GsonComponentSerializer$Builder
}

export namespace $GsonComponentSerializer {
function builder(): $GsonComponentSerializer$Builder
function gson(): $GsonComponentSerializer
function colorDownsamplingGson(): $GsonComponentSerializer
function configureAndBuild<R, B>(builder: $GsonComponentSerializer$Builder$Type, consumer: $Consumer$Type<(any)>): $GsonComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GsonComponentSerializer$Type = ($GsonComponentSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GsonComponentSerializer_ = $GsonComponentSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Listenable" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Listenable<L> {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Listenable$Type<L> = ($Listenable<(L)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Listenable_<L> = $Listenable$Type<(L)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$HSVLikeImpl" {
import {$HSVLike, $HSVLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$HSVLike"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $HSVLikeImpl implements $HSVLike {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "s"(): float
public "h"(): float
public "v"(): float
/**
 * 
 * @deprecated
 */
public static "of"(h: float, s: float, v: float): $HSVLike
public "examinableProperties"(): $Stream<(any)>
public static "hsvLike"(h: float, s: float, v: float): $HSVLike
public static "fromRGB"(red: integer, green: integer, blue: integer): $HSVLike
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HSVLikeImpl$Type = ($HSVLikeImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HSVLikeImpl_ = $HSVLikeImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Builder" {
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$SparkProtos$CommandSenderMetadata$Type, $SparkProtos$CommandSenderMetadata$Type$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Type"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$CommandSenderMetadataOrBuilder, $SparkProtos$CommandSenderMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadataOrBuilder"

export class $SparkProtos$CommandSenderMetadata$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$CommandSenderMetadata), ($SparkProtos$CommandSenderMetadata$Builder)> implements $SparkProtos$CommandSenderMetadataOrBuilder {


public "setUniqueIdBytes"(arg0: $ByteString$Type): $SparkProtos$CommandSenderMetadata$Builder
public "clearUniqueId"(): $SparkProtos$CommandSenderMetadata$Builder
public "getUniqueIdBytes"(): $ByteString
public "getName"(): string
public "setName"(arg0: string): $SparkProtos$CommandSenderMetadata$Builder
public "getType"(): $SparkProtos$CommandSenderMetadata$Type
public "setType"(arg0: $SparkProtos$CommandSenderMetadata$Type$Type): $SparkProtos$CommandSenderMetadata$Builder
public "setNameBytes"(arg0: $ByteString$Type): $SparkProtos$CommandSenderMetadata$Builder
public "getNameBytes"(): $ByteString
public "clearName"(): $SparkProtos$CommandSenderMetadata$Builder
public "getUniqueId"(): string
public "getTypeValue"(): integer
public "setUniqueId"(arg0: string): $SparkProtos$CommandSenderMetadata$Builder
public "clearType"(): $SparkProtos$CommandSenderMetadata$Builder
public "setTypeValue"(arg0: integer): $SparkProtos$CommandSenderMetadata$Builder
set "uniqueIdBytes"(value: $ByteString$Type)
get "uniqueIdBytes"(): $ByteString
get "name"(): string
set "name"(value: string)
get "type"(): $SparkProtos$CommandSenderMetadata$Type
set "type"(value: $SparkProtos$CommandSenderMetadata$Type$Type)
set "nameBytes"(value: $ByteString$Type)
get "nameBytes"(): $ByteString
get "uniqueId"(): string
get "typeValue"(): integer
set "uniqueId"(value: string)
set "typeValue"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$CommandSenderMetadata$Builder$Type = ($SparkProtos$CommandSenderMetadata$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$CommandSenderMetadata$Builder_ = $SparkProtos$CommandSenderMetadata$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FloatValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $FloatValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): float
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $FloatValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatValueOrBuilder$Type = ($FloatValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatValueOrBuilder_ = $FloatValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup" {
import {$ClassSourceLookup$MethodCallByLine, $ClassSourceLookup$MethodCallByLine$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCallByLine"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$ClassSourceLookup$MethodCall, $ClassSourceLookup$MethodCall$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$MethodCall"
import {$ClassSourceLookup$Visitor, $ClassSourceLookup$Visitor$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup$Visitor"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $ClassSourceLookup {

 "identify"(arg0: $Class$Type<(any)>): string
 "identify"(arg0: $ClassSourceLookup$MethodCall$Type): string
 "identify"(arg0: $ClassSourceLookup$MethodCallByLine$Type): string

(arg0: $SparkPlatform$Type): $ClassSourceLookup
}

export namespace $ClassSourceLookup {
const NO_OP: $ClassSourceLookup
function create(arg0: $SparkPlatform$Type): $ClassSourceLookup
function createVisitor(arg0: $ClassSourceLookup$Type): $ClassSourceLookup$Visitor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassSourceLookup$Type = ($ClassSourceLookup);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassSourceLookup_ = $ClassSourceLookup$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/tick/$SparkTickStatistics" {
import {$TickHook$Callback, $TickHook$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickHook$Callback"
import {$TickStatistics, $TickStatistics$Type} from "packages/me/lucko/spark/common/monitor/tick/$TickStatistics"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"
import {$TickReporter$Callback, $TickReporter$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickReporter$Callback"

export class $SparkTickStatistics implements $TickHook$Callback, $TickReporter$Callback, $TickStatistics {

constructor()

public "duration1Min"(): $DoubleAverageInfo
public "tps15Min"(): double
public "duration10Sec"(): $DoubleAverageInfo
public "duration5Min"(): $DoubleAverageInfo
public "tps5Sec"(): double
public "tps10Sec"(): double
public "tps1Min"(): double
public "tps5Min"(): double
public "isDurationSupported"(): boolean
public "onTick"(arg0: integer): void
public "onTick"(arg0: double): void
get "durationSupported"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkTickStatistics$Type = ($SparkTickStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkTickStatistics_ = $SparkTickStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ManifestSchemaFactory" {
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$SchemaFactory, $SchemaFactory$Type} from "packages/me/lucko/spark/lib/protobuf/$SchemaFactory"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export class $ManifestSchemaFactory implements $SchemaFactory {

constructor()

public "createSchema"<T>(arg0: $Class$Type<(T)>): $Schema<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ManifestSchemaFactory$Type = ($ManifestSchemaFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ManifestSchemaFactory_ = $ManifestSchemaFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $TextComponent extends $BuildableComponent<($TextComponent), ($TextComponent$Builder)>, $ScopedComponent<($TextComponent)> {

 "content"(content: string): $TextComponent
 "content"(): string
 "examinableProperties"(): $Stream<(any)>
 "toBuilder"(): $TextComponent$Builder
 "append"(component: $Component$Type): $TextComponent
 "append"(like: $ComponentLike$Type): $TextComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TextComponent
 "color"(color: $TextColor$Type): $TextComponent
 "style"(style: $Style$Type): $TextComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $TextComponent
 "style"(style: $Style$Builder$Type): $TextComponent
 "children"(children: $List$Type<(any)>): $TextComponent
 "mergeStyle"(that: $Component$Type): $TextComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TextComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TextComponent
 "colorIfAbsent"(color: $TextColor$Type): $TextComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TextComponent
 "clickEvent"(event: $ClickEvent$Type): $TextComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $TextComponent
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $TextComponent {
function ofChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function configureAndBuild<R, B>(builder: $TextComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $TextComponent
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextComponent$Type = ($TextComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextComponent_ = $TextComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/sound/$Sound$Builder" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$OptionalLong, $OptionalLong$Type} from "packages/java/util/$OptionalLong"
import {$Sound$Source, $Sound$Source$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Sound$Type, $Sound$Type$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Type"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Sound, $Sound$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound"
import {$Sound$Source$Provider, $Sound$Source$Provider$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Source$Provider"

export interface $Sound$Builder extends $AbstractBuilder<($Sound)> {

 "type"(typeSupplier: $Supplier$Type<(any)>): $Sound$Builder
 "type"(type: $Sound$Type$Type): $Sound$Builder
 "type"(type: $Key$Type): $Sound$Builder
 "source"(source: $Sound$Source$Provider$Type): $Sound$Builder
 "source"(source: $Sound$Source$Type): $Sound$Builder
 "seed"(seed: long): $Sound$Builder
 "seed"(seed: $OptionalLong$Type): $Sound$Builder
 "pitch"(pitch: float): $Sound$Builder
 "volume"(volume: float): $Sound$Builder
 "build"(): $Sound
}

export namespace $Sound$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $Sound
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sound$Builder$Type = ($Sound$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sound$Builder_ = $Sound$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapEntryLite" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MapFieldLite, $MapFieldLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MapFieldLite"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $MapEntryLite<K, V> {


public "getValue"(): V
public "getKey"(): K
public static "newDefaultInstance"<K, V>(arg0: $WireFormat$FieldType$Type, arg1: K, arg2: $WireFormat$FieldType$Type, arg3: V): $MapEntryLite<(K), (V)>
public "serializeTo"(arg0: $CodedOutputStream$Type, arg1: integer, arg2: K, arg3: V): void
public "parseInto"(arg0: $MapFieldLite$Type<(K), (V)>, arg1: $CodedInputStream$Type, arg2: $ExtensionRegistryLite$Type): void
public "parseEntry"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Map$Entry<(K), (V)>
public "computeMessageSize"(arg0: integer, arg1: K, arg2: V): integer
get "value"(): V
get "key"(): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapEntryLite$Type<K, V> = ($MapEntryLite<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapEntryLite_<K, V> = $MapEntryLite$Type<(K), (V)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$MethodVisitor" {
import {$Handle, $Handle$Type} from "packages/me/lucko/spark/lib/asm/$Handle"
import {$Label, $Label$Type} from "packages/me/lucko/spark/lib/asm/$Label"
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"

export class $MethodVisitor {

constructor(arg0: integer, arg1: $MethodVisitor$Type)
constructor(arg0: integer)

public "visitFrame"(arg0: integer, arg1: integer, arg2: (any)[], arg3: integer, arg4: (any)[]): void
public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitCode"(): void
public "visitFieldInsn"(arg0: integer, arg1: string, arg2: string, arg3: string): void
public "visitInsn"(arg0: integer): void
public "visitMaxs"(arg0: integer, arg1: integer): void
public "visitVarInsn"(arg0: integer, arg1: integer): void
public "visitMethodInsn"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: boolean): void
/**
 * 
 * @deprecated
 */
public "visitMethodInsn"(arg0: integer, arg1: string, arg2: string, arg3: string): void
public "visitTypeInsn"(arg0: integer, arg1: string): void
public "visitIntInsn"(arg0: integer, arg1: integer): void
public "visitLdcInsn"(arg0: any): void
public "visitParameter"(arg0: string, arg1: integer): void
public "visitAnnotationDefault"(): $AnnotationVisitor
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAnnotableParameterCount"(arg0: integer, arg1: boolean): void
public "visitParameterAnnotation"(arg0: integer, arg1: string, arg2: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
public "visitInvokeDynamicInsn"(arg0: string, arg1: string, arg2: $Handle$Type, ...arg3: (any)[]): void
public "visitJumpInsn"(arg0: integer, arg1: $Label$Type): void
public "visitLabel"(arg0: $Label$Type): void
public "visitIincInsn"(arg0: integer, arg1: integer): void
public "visitTableSwitchInsn"(arg0: integer, arg1: integer, arg2: $Label$Type, ...arg3: ($Label$Type)[]): void
public "visitLookupSwitchInsn"(arg0: $Label$Type, arg1: (integer)[], arg2: ($Label$Type)[]): void
public "visitMultiANewArrayInsn"(arg0: string, arg1: integer): void
public "visitInsnAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitTryCatchBlock"(arg0: $Label$Type, arg1: $Label$Type, arg2: $Label$Type, arg3: string): void
public "visitTryCatchAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitLocalVariable"(arg0: string, arg1: string, arg2: string, arg3: $Label$Type, arg4: $Label$Type, arg5: integer): void
public "visitLocalVariableAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: ($Label$Type)[], arg3: ($Label$Type)[], arg4: (integer)[], arg5: string, arg6: boolean): $AnnotationVisitor
public "visitLineNumber"(arg0: integer, arg1: $Label$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MethodVisitor$Type = ($MethodVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MethodVisitor_ = $MethodVisitor$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadataOrBuilder" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkSamplerProtos$SamplerMetadata$SamplerMode, $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SamplerMode"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SparkSamplerProtos$SamplerMetadataOrBuilder extends $MessageLiteOrBuilder {

 "getSourcesOrThrow"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
 "containsSources"(arg0: string): boolean
 "getSourcesCount"(): integer
 "getSamplerMode"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
 "getSourcesMap"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
 "getComment"(): string
 "getStartTime"(): long
 "getInterval"(): integer
 "getCreator"(): $SparkProtos$CommandSenderMetadata
 "getEndTime"(): long
/**
 * 
 * @deprecated
 */
 "getSources"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
 "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
 "getSystemStatistics"(): $SparkProtos$SystemStatistics
 "getNumberOfTicks"(): integer
 "getServerConfigurationsOrDefault"(arg0: string, arg1: string): string
 "hasPlatformMetadata"(): boolean
/**
 * 
 * @deprecated
 */
 "getServerConfigurations"(): $Map<(string), (string)>
 "getServerConfigurationsOrThrow"(arg0: string): string
 "getServerConfigurationsMap"(): $Map<(string), (string)>
 "containsServerConfigurations"(arg0: string): boolean
 "hasSystemStatistics"(): boolean
 "getExtraPlatformMetadataOrDefault"(arg0: string, arg1: string): string
 "hasPlatformStatistics"(): boolean
 "getExtraPlatformMetadataCount"(): integer
/**
 * 
 * @deprecated
 */
 "getExtraPlatformMetadata"(): $Map<(string), (string)>
 "getExtraPlatformMetadataOrThrow"(arg0: string): string
 "getSourcesOrDefault"(arg0: string, arg1: $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
 "getServerConfigurationsCount"(): integer
 "containsExtraPlatformMetadata"(arg0: string): boolean
 "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
 "getExtraPlatformMetadataMap"(): $Map<(string), (string)>
 "getSamplerModeValue"(): integer
 "hasThreadDumper"(): boolean
 "hasCreator"(): boolean
 "getThreadDumper"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
 "hasDataAggregator"(): boolean
 "getDataAggregator"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
 "getCommentBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SamplerMetadataOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadataOrBuilder$Type = ($SparkSamplerProtos$SamplerMetadataOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadataOrBuilder_ = $SparkSamplerProtos$SamplerMetadataOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$State" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $SparkWebSocketProtos$ServerConnectResponse$State extends $Enum<($SparkWebSocketProtos$ServerConnectResponse$State)> implements $Internal$EnumLite {
static readonly "ACCEPTED": $SparkWebSocketProtos$ServerConnectResponse$State
static readonly "UNTRUSTED": $SparkWebSocketProtos$ServerConnectResponse$State
static readonly "REJECTED": $SparkWebSocketProtos$ServerConnectResponse$State
static readonly "UNRECOGNIZED": $SparkWebSocketProtos$ServerConnectResponse$State
static readonly "ACCEPTED_VALUE": integer
static readonly "UNTRUSTED_VALUE": integer
static readonly "REJECTED_VALUE": integer


public static "values"(): ($SparkWebSocketProtos$ServerConnectResponse$State)[]
public static "valueOf"(arg0: string): $SparkWebSocketProtos$ServerConnectResponse$State
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $SparkWebSocketProtos$ServerConnectResponse$State
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($SparkWebSocketProtos$ServerConnectResponse$State)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $SparkWebSocketProtos$ServerConnectResponse$State
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$State$Type = (("untrusted") | ("rejected") | ("accepted") | ("unrecognized")) | ($SparkWebSocketProtos$ServerConnectResponse$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse$State_ = $SparkWebSocketProtos$ServerConnectResponse$State$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StructProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $StructProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StructProto$Type = ($StructProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StructProto_ = $StructProto$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$EmptyAudience" {
import {$SignedMessage, $SignedMessage$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage"
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$SignedMessage$Signature, $SignedMessage$Signature$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ForwardingAudience, $ForwardingAudience$Type} from "packages/me/lucko/spark/lib/adventure/audience/$ForwardingAudience"
import {$TitlePart, $TitlePart$Type} from "packages/me/lucko/spark/lib/adventure/title/$TitlePart"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Book$Builder, $Book$Builder$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder"
import {$Sound$Emitter, $Sound$Emitter$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Emitter"
import {$Identified, $Identified$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identified"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$MessageType, $MessageType$Type} from "packages/me/lucko/spark/lib/adventure/audience/$MessageType"
import {$Title, $Title$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title"
import {$Audience, $Audience$Type} from "packages/me/lucko/spark/lib/adventure/audience/$Audience"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Book, $Book$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book"
import {$Sound, $Sound$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound"

export class $EmptyAudience implements $Audience {


public "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
public "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
public "equals"(that: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T
public "sendMessage"(signedMessage: $SignedMessage$Type, boundChatType: $ChatType$Bound$Type): void
public "sendMessage"(message: $Component$Type, boundChatType: $ChatType$Bound$Type): void
public "sendMessage"(message: $ComponentLike$Type): void
public "sendMessage"(message: $Component$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identified$Type, message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identity$Type, message: $Component$Type, type: $MessageType$Type): void
public "forEachAudience"(action: $Consumer$Type<(any)>): void
public "filterAudience"(filter: $Predicate$Type<(any)>): $Audience
public "deleteMessage"(signature: $SignedMessage$Signature$Type): void
public "sendActionBar"(message: $ComponentLike$Type): void
public "openBook"(book: $Book$Builder$Type): void
public "sendPlayerListHeaderAndFooter"(header: $ComponentLike$Type, footer: $ComponentLike$Type): void
public "sendPlayerListHeader"(header: $ComponentLike$Type): void
public "sendPlayerListFooter"(footer: $ComponentLike$Type): void
public static "empty"(): $Audience
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identity$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identified$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type): void
public "sendMessage"(message: $ComponentLike$Type, boundChatType: $ChatType$Bound$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
public "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type): void
public static "audience"(audiences: $Iterable$Type<(any)>): $ForwardingAudience
public static "audience"(...audiences: ($Audience$Type)[]): $Audience
public static "toAudience"(): $Collector<(any), (any), ($ForwardingAudience)>
public "deleteMessage"(signedMessage: $SignedMessage$Type): void
public "clearTitle"(): void
public "sendActionBar"(message: $Component$Type): void
public "showBossBar"(bar: $BossBar$Type): void
public "hideBossBar"(bar: $BossBar$Type): void
public "resetTitle"(): void
public "openBook"(book: $Book$Type): void
public "sendTitlePart"<T>(part: $TitlePart$Type<(T)>, value: T): void
public "stopSound"(stop: $SoundStop$Type): void
public "stopSound"(sound: $Sound$Type): void
public "showTitle"(title: $Title$Type): void
public "playSound"(sound: $Sound$Type, emitter: $Sound$Emitter$Type): void
public "playSound"(sound: $Sound$Type, x: double, y: double, z: double): void
public "playSound"(sound: $Sound$Type): void
public "sendPlayerListHeaderAndFooter"(header: $Component$Type, footer: $Component$Type): void
public "sendPlayerListHeader"(header: $Component$Type): void
public "sendPlayerListFooter"(footer: $Component$Type): void
public "pointers"(): $Pointers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyAudience$Type = ($EmptyAudience);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyAudience_ = $EmptyAudience$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$Audiences" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Audiences {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Audiences$Type = ($Audiences);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Audiences_ = $Audiences$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics" {
import {$SparkProtos$SystemStatistics$Memory, $SparkProtos$SystemStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory"
import {$SparkProtos$SystemStatistics$Os, $SparkProtos$SystemStatistics$Os$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Builder, $SparkProtos$SystemStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Builder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$SystemStatistics$Disk, $SparkProtos$SystemStatistics$Disk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk"
import {$SparkProtos$SystemStatistics$Java, $SparkProtos$SystemStatistics$Java$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java"
import {$SparkProtos$SystemStatistics$NetInterface, $SparkProtos$SystemStatistics$NetInterface$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface"
import {$SparkProtos$SystemStatisticsOrBuilder, $SparkProtos$SystemStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatisticsOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$SystemStatistics$Gc, $SparkProtos$SystemStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc"
import {$SparkProtos$SystemStatistics$Cpu, $SparkProtos$SystemStatistics$Cpu$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$SystemStatistics extends $GeneratedMessageLite<($SparkProtos$SystemStatistics), ($SparkProtos$SystemStatistics$Builder)> implements $SparkProtos$SystemStatisticsOrBuilder {
static readonly "CPU_FIELD_NUMBER": integer
static readonly "MEMORY_FIELD_NUMBER": integer
static readonly "GC_FIELD_NUMBER": integer
static readonly "DISK_FIELD_NUMBER": integer
static readonly "OS_FIELD_NUMBER": integer
static readonly "JAVA_FIELD_NUMBER": integer
static readonly "UPTIME_FIELD_NUMBER": integer
static readonly "NET_FIELD_NUMBER": integer


public "getOs"(): $SparkProtos$SystemStatistics$Os
public static "parser"(): $Parser<($SparkProtos$SystemStatistics)>
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Type): $SparkProtos$SystemStatistics$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics
public "getUptime"(): long
public "getMemory"(): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics
public "getGcOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$Gc$Type): $SparkProtos$SystemStatistics$Gc
public "hasMemory"(): boolean
public "getGcCount"(): integer
public "getGcMap"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
/**
 * 
 * @deprecated
 */
public "getGc"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
public "getGcOrThrow"(arg0: string): $SparkProtos$SystemStatistics$Gc
public "containsGc"(arg0: string): boolean
public "hasJava"(): boolean
/**
 * 
 * @deprecated
 */
public "getNet"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
public "containsNet"(arg0: string): boolean
public "getNetMap"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
public "getCpu"(): $SparkProtos$SystemStatistics$Cpu
public "hasDisk"(): boolean
public "getJava"(): $SparkProtos$SystemStatistics$Java
public "hasCpu"(): boolean
public "hasOs"(): boolean
public "getNetCount"(): integer
public "getDisk"(): $SparkProtos$SystemStatistics$Disk
public "getNetOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$NetInterface$Type): $SparkProtos$SystemStatistics$NetInterface
public "getNetOrThrow"(arg0: string): $SparkProtos$SystemStatistics$NetInterface
get "os"(): $SparkProtos$SystemStatistics$Os
get "defaultInstance"(): $SparkProtos$SystemStatistics
get "uptime"(): long
get "memory"(): $SparkProtos$SystemStatistics$Memory
get "gcCount"(): integer
get "gcMap"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
get "gc"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
get "net"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
get "netMap"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
get "cpu"(): $SparkProtos$SystemStatistics$Cpu
get "java"(): $SparkProtos$SystemStatistics$Java
get "netCount"(): integer
get "disk"(): $SparkProtos$SystemStatistics$Disk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Type = ($SparkProtos$SystemStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics_ = $SparkProtos$SystemStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$NewInstanceSchemaLite" {
import {$NewInstanceSchema, $NewInstanceSchema$Type} from "packages/me/lucko/spark/lib/protobuf/$NewInstanceSchema"

export class $NewInstanceSchemaLite implements $NewInstanceSchema {


public "newInstance"(arg0: any): any
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NewInstanceSchemaLite$Type = ($NewInstanceSchemaLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NewInstanceSchemaLite_ = $NewInstanceSchemaLite$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$ThreadNode" {
import {$ProtoTimeEncoder, $ProtoTimeEncoder$Type} from "packages/me/lucko/spark/common/sampler/window/$ProtoTimeEncoder"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$StackTraceNode$Describer, $StackTraceNode$Describer$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode$Describer"
import {$SparkSamplerProtos$ThreadNode, $SparkSamplerProtos$ThreadNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$ThreadNode"
import {$MergeMode, $MergeMode$Type} from "packages/me/lucko/spark/common/sampler/node/$MergeMode"
import {$AbstractNode, $AbstractNode$Type} from "packages/me/lucko/spark/common/sampler/node/$AbstractNode"

export class $ThreadNode extends $AbstractNode {
 "label": string

constructor(arg0: string)

public "removeTimeWindowsRecursively"(arg0: $IntPredicate$Type): boolean
public "log"<T>(arg0: $StackTraceNode$Describer$Type<(T)>, arg1: (T)[], arg2: long, arg3: integer): void
public "getThreadGroup"(): string
public "getThreadLabel"(): string
public "setThreadLabel"(arg0: string): void
public "toProto"(arg0: $MergeMode$Type, arg1: $ProtoTimeEncoder$Type): $SparkSamplerProtos$ThreadNode
get "threadGroup"(): string
get "threadLabel"(): string
set "threadLabel"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadNode$Type = ($ThreadNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadNode_ = $ThreadNode$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $SparkSamplerProtos {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$Type = ($SparkSamplerProtos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos_ = $SparkSamplerProtos$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteString$LeafByteString" {
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $ByteString$LeafByteString extends $ByteString {
static readonly "EMPTY": $ByteString


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteString$LeafByteString$Type = ($ByteString$LeafByteString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteString$LeafByteString_ = $ByteString$LeafByteString$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$AbstractChunkInfo" {
import {$CountMap, $CountMap$Type} from "packages/me/lucko/spark/common/platform/world/$CountMap"
import {$ChunkInfo, $ChunkInfo$Type} from "packages/me/lucko/spark/common/platform/world/$ChunkInfo"

export class $AbstractChunkInfo<E> implements $ChunkInfo<(E)> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "getZ"(): integer
public "getX"(): integer
public "getEntityCounts"(): $CountMap<(E)>
public "entityTypeName"(arg0: E): string
get "z"(): integer
get "x"(): integer
get "entityCounts"(): $CountMap<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractChunkInfo$Type<E> = ($AbstractChunkInfo<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractChunkInfo_<E> = $AbstractChunkInfo$Type<(E)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$ClassVisitor" {
import {$MethodVisitor, $MethodVisitor$Type} from "packages/me/lucko/spark/lib/asm/$MethodVisitor"
import {$RecordComponentVisitor, $RecordComponentVisitor$Type} from "packages/me/lucko/spark/lib/asm/$RecordComponentVisitor"
import {$ModuleVisitor, $ModuleVisitor$Type} from "packages/me/lucko/spark/lib/asm/$ModuleVisitor"
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"
import {$FieldVisitor, $FieldVisitor$Type} from "packages/me/lucko/spark/lib/asm/$FieldVisitor"

export class $ClassVisitor {

constructor(arg0: integer)
constructor(arg0: integer, arg1: $ClassVisitor$Type)

public "visit"(arg0: integer, arg1: integer, arg2: string, arg3: string, arg4: string, arg5: (string)[]): void
public "visitSource"(arg0: string, arg1: string): void
public "visitField"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: any): $FieldVisitor
public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitMethod"(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: (string)[]): $MethodVisitor
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
public "visitNestHost"(arg0: string): void
public "visitOuterClass"(arg0: string, arg1: string, arg2: string): void
public "visitNestMember"(arg0: string): void
public "visitInnerClass"(arg0: string, arg1: string, arg2: string, arg3: integer): void
public "visitModule"(arg0: string, arg1: integer, arg2: string): $ModuleVisitor
public "visitRecordComponent"(arg0: string, arg1: string, arg2: string): $RecordComponentVisitor
public "visitPermittedSubclass"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassVisitor$Type = ($ClassVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassVisitor_ = $ClassVisitor$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$Pointer" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $Pointer<V> extends $Examinable {

 "type"(): $Class<(V)>
 "key"(): $Key
 "examinableProperties"(): $Stream<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
}

export namespace $Pointer {
function pointer<V>(type: $Class$Type<(V)>, key: $Key$Type): $Pointer<(V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pointer$Type<V> = ($Pointer<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pointer_<V> = $Pointer$Type<(V)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextDecorationAndStateImpl" {
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TextDecorationAndState, $TextDecorationAndState$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecorationAndState"

export class $TextDecorationAndStateImpl implements $TextDecorationAndState {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "state"(): $TextDecoration$State
public "decoration"(): $TextDecoration
public "styleApply"(style: $Style$Builder$Type): void
public "examinableProperties"(): $Stream<(any)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextDecorationAndStateImpl$Type = ($TextDecorationAndStateImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextDecorationAndStateImpl_ = $TextDecorationAndStateImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$IterableByteBufferInputStream" {
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"

export class $IterableByteBufferInputStream extends $InputStream {


public "read"(): integer
public "read"(arg0: (byte)[], arg1: integer, arg2: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IterableByteBufferInputStream$Type = ($IterableByteBufferInputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IterableByteBufferInputStream_ = $IterableByteBufferInputStream$Type;
}}
declare module "packages/me/lucko/spark/lib/asyncprofiler/$Counter" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Counter extends $Enum<($Counter)> {
static readonly "SAMPLES": $Counter
static readonly "TOTAL": $Counter


public static "values"(): ($Counter)[]
public static "valueOf"(arg0: string): $Counter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Counter$Type = (("total") | ("samples")) | ($Counter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Counter_ = $Counter$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$Sampler" {
import {$ViewerSocket, $ViewerSocket$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocket"
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$CompletableFuture, $CompletableFuture$Type} from "packages/java/util/concurrent/$CompletableFuture"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Sampler$ExportProps, $Sampler$ExportProps$Type} from "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps"
import {$SparkSamplerProtos$SamplerData, $SparkSamplerProtos$SamplerData$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData"

export interface $Sampler {

 "start"(): void
 "stop"(arg0: boolean): void
 "getFuture"(): $CompletableFuture<($Sampler)>
 "getAttachedSockets"(): $Collection<($ViewerSocket)>
 "getAutoEndTime"(): long
 "toProto"(arg0: $SparkPlatform$Type, arg1: $Sampler$ExportProps$Type): $SparkSamplerProtos$SamplerData
 "attachSocket"(arg0: $ViewerSocket$Type): void
 "getMode"(): $SamplerMode
 "isRunningInBackground"(): boolean
 "getStartTime"(): long
}

export namespace $Sampler {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sampler$Type = ($Sampler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sampler_ = $Sampler$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$CountsResult" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $WorldInfoProvider$CountsResult {

constructor(arg0: integer, arg1: integer, arg2: integer, arg3: integer)

public "players"(): integer
public "entities"(): integer
public "tileEntities"(): integer
public "chunks"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldInfoProvider$CountsResult$Type = ($WorldInfoProvider$CountsResult);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldInfoProvider$CountsResult_ = $WorldInfoProvider$CountsResult$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$BinaryFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$DataFrame"

export class $BinaryFrame extends $DataFrame {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryFrame$Type = ($BinaryFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryFrame_ = $BinaryFrame$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapData" {
import {$SparkHeapProtos$HeapDataOrBuilder, $SparkHeapProtos$HeapDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapDataOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkHeapProtos$HeapEntry, $SparkHeapProtos$HeapEntry$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry"
import {$SparkHeapProtos$HeapEntryOrBuilder, $SparkHeapProtos$HeapEntryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntryOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$SparkHeapProtos$HeapMetadata, $SparkHeapProtos$HeapMetadata$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkHeapProtos$HeapData$Builder, $SparkHeapProtos$HeapData$Builder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapData$Builder"

export class $SparkHeapProtos$HeapData extends $GeneratedMessageLite<($SparkHeapProtos$HeapData), ($SparkHeapProtos$HeapData$Builder)> implements $SparkHeapProtos$HeapDataOrBuilder {
static readonly "METADATA_FIELD_NUMBER": integer
static readonly "ENTRIES_FIELD_NUMBER": integer


public "getEntries"(arg0: integer): $SparkHeapProtos$HeapEntry
public static "parser"(): $Parser<($SparkHeapProtos$HeapData)>
public static "newBuilder"(): $SparkHeapProtos$HeapData$Builder
public static "newBuilder"(arg0: $SparkHeapProtos$HeapData$Type): $SparkHeapProtos$HeapData$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapData
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public "getEntriesList"(): $List<($SparkHeapProtos$HeapEntry)>
public "getEntriesCount"(): integer
public static "getDefaultInstance"(): $SparkHeapProtos$HeapData
public "hasMetadata"(): boolean
public "getEntriesOrBuilder"(arg0: integer): $SparkHeapProtos$HeapEntryOrBuilder
public "getEntriesOrBuilderList"(): $List<(any)>
public "getMetadata"(): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: (byte)[]): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $ByteString$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapData
public static "parseFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapData
get "entriesList"(): $List<($SparkHeapProtos$HeapEntry)>
get "entriesCount"(): integer
get "defaultInstance"(): $SparkHeapProtos$HeapData
get "entriesOrBuilderList"(): $List<(any)>
get "metadata"(): $SparkHeapProtos$HeapMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapData$Type = ($SparkHeapProtos$HeapData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapData_ = $SparkHeapProtos$HeapData$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/title/$Title$Times" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"

export interface $Title$Times extends $Examinable {

 "fadeIn"(): $Duration
 "stay"(): $Duration
 "fadeOut"(): $Duration
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $Title$Times {
function of(fadeIn: $Duration$Type, stay: $Duration$Type, fadeOut: $Duration$Type): $Title$Times
function times(fadeIn: $Duration$Type, stay: $Duration$Type, fadeOut: $Duration$Type): $Title$Times
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Title$Times$Type = ($Title$Times);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Title$Times_ = $Title$Times$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$Key" {
import {$Namespaced, $Namespaced$Type} from "packages/me/lucko/spark/lib/adventure/key/$Namespaced"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $Key extends $Comparable<($Key)>, $Examinable, $Namespaced, $Keyed {

 "value"(): string
 "compareTo"(that: $Key$Type): integer
 "key"(): $Key
 "examinableProperties"(): $Stream<(any)>
 "namespace"(): string
 "asString"(): string
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
}

export namespace $Key {
const MINECRAFT_NAMESPACE: string
const DEFAULT_SEPARATOR: character
function key(string: string): $Key
function key(namespaced: $Namespaced$Type, value: string): $Key
function key(string: string, character: character): $Key
function key(namespace: string, value: string): $Key
function comparator(): $Comparator<(any)>
function parseableValue(value: string): boolean
function parseable(string: string): boolean
function allowedInNamespace(character: character): boolean
function allowedInValue(character: character): boolean
function parseableNamespace(namespace: string): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Key$Type = ($Key);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Key_ = $Key$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$RGBLike" {
import {$HSVLike, $HSVLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$HSVLike"

export interface $RGBLike {

 "red"(): integer
 "blue"(): integer
 "green"(): integer
 "asHSV"(): $HSVLike
}

export namespace $RGBLike {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RGBLike$Type = ($RGBLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RGBLike_ = $RGBLike$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $MessageLite$Builder extends $MessageLiteOrBuilder, $Cloneable {

 "clone"(): $MessageLite$Builder
 "clear"(): $MessageLite$Builder
 "build"(): $MessageLite
 "buildPartial"(): $MessageLite
 "mergeDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): boolean
 "mergeDelimitedFrom"(arg0: $InputStream$Type): boolean
 "mergeFrom"(arg0: (byte)[], arg1: integer, arg2: integer, arg3: $ExtensionRegistryLite$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $InputStream$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $MessageLite$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $CodedInputStream$Type): $MessageLite$Builder
 "mergeFrom"(arg0: (byte)[]): $MessageLite$Builder
 "mergeFrom"(arg0: $ByteString$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $MessageLite$Builder
 "mergeFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $MessageLite$Builder
 "mergeFrom"(arg0: (byte)[], arg1: integer, arg2: integer): $MessageLite$Builder
 "mergeFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $MessageLite$Builder
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $MessageLite$Builder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageLite$Builder$Type = ($MessageLite$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageLite$Builder_ = $MessageLite$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Nag" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $Nag extends $RuntimeException {


public static "print"(nag: $Nag$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Nag$Type = ($Nag);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Nag_ = $Nag$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar$Overlay" {
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $BossBar$Overlay extends $Enum<($BossBar$Overlay)> {
static readonly "PROGRESS": $BossBar$Overlay
static readonly "NOTCHED_6": $BossBar$Overlay
static readonly "NOTCHED_10": $BossBar$Overlay
static readonly "NOTCHED_12": $BossBar$Overlay
static readonly "NOTCHED_20": $BossBar$Overlay
static readonly "NAMES": $Index<(string), ($BossBar$Overlay)>


public static "values"(): ($BossBar$Overlay)[]
public static "valueOf"(name: string): $BossBar$Overlay
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBar$Overlay$Type = (("notched_20") | ("notched_10") | ("progress") | ("notched_6") | ("notched_12")) | ($BossBar$Overlay);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBar$Overlay_ = $BossBar$Overlay$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EnumValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $EnumValueOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getNumber"(): integer
 "getOptions"(arg0: integer): $Option
 "getNameBytes"(): $ByteString
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $EnumValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumValueOrBuilder$Type = ($EnumValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumValueOrBuilder_ = $EnumValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$FieldWriter" {
import {$TypePath, $TypePath$Type} from "packages/me/lucko/spark/lib/asm/$TypePath"
import {$AnnotationVisitor, $AnnotationVisitor$Type} from "packages/me/lucko/spark/lib/asm/$AnnotationVisitor"
import {$Attribute, $Attribute$Type} from "packages/me/lucko/spark/lib/asm/$Attribute"
import {$FieldVisitor, $FieldVisitor$Type} from "packages/me/lucko/spark/lib/asm/$FieldVisitor"

export class $FieldWriter extends $FieldVisitor {


public "visitAnnotation"(arg0: string, arg1: boolean): $AnnotationVisitor
public "visitEnd"(): void
public "visitTypeAnnotation"(arg0: integer, arg1: $TypePath$Type, arg2: string, arg3: boolean): $AnnotationVisitor
public "visitAttribute"(arg0: $Attribute$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldWriter$Type = ($FieldWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldWriter_ = $FieldWriter$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$StackTraceNode$Description" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $StackTraceNode$Description {

constructor(arg0: string, arg1: string, arg2: integer, arg3: integer)
constructor(arg0: string, arg1: string, arg2: string)

public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackTraceNode$Description$Type = ($StackTraceNode$Description);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackTraceNode$Description_ = $StackTraceNode$Description$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UInt64Value$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$UInt64ValueOrBuilder, $UInt64ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt64ValueOrBuilder"
import {$UInt64Value, $UInt64Value$Type} from "packages/me/lucko/spark/lib/protobuf/$UInt64Value"

export class $UInt64Value$Builder extends $GeneratedMessageLite$Builder<($UInt64Value), ($UInt64Value$Builder)> implements $UInt64ValueOrBuilder {


public "getValue"(): long
public "setValue"(arg0: long): $UInt64Value$Builder
public "clearValue"(): $UInt64Value$Builder
get "value"(): long
set "value"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UInt64Value$Builder$Type = ($UInt64Value$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UInt64Value$Builder_ = $UInt64Value$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncStackTraceElement" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AsyncStackTraceElement {
static readonly "NATIVE_CALL": string

constructor(arg0: string, arg1: string, arg2: string)

public "getClassName"(): string
public "getMethodName"(): string
public "getMethodDescription"(): string
get "className"(): string
get "methodName"(): string
get "methodDescription"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncStackTraceElement$Type = ($AsyncStackTraceElement);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncStackTraceElement_ = $AsyncStackTraceElement$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponseOrBuilder" {
import {$SparkWebSocketProtos$ServerConnectResponse$Settings, $SparkWebSocketProtos$ServerConnectResponse$Settings$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkWebSocketProtos$ServerConnectResponse$State, $SparkWebSocketProtos$ServerConnectResponse$State$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$State"

export interface $SparkWebSocketProtos$ServerConnectResponseOrBuilder extends $MessageLiteOrBuilder {

 "getState"(): $SparkWebSocketProtos$ServerConnectResponse$State
 "getClientId"(): string
 "getSettings"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
 "getClientIdBytes"(): $ByteString
 "hasSettings"(): boolean
 "getStateValue"(): integer
 "getLastPayloadId"(): string
 "getLastPayloadIdBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ServerConnectResponseOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponseOrBuilder$Type = ($SparkWebSocketProtos$ServerConnectResponseOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponseOrBuilder_ = $SparkWebSocketProtos$ServerConnectResponseOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Struct$Builder" {
import {$Struct, $Struct$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$StructOrBuilder, $StructOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$StructOrBuilder"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Struct$Builder extends $GeneratedMessageLite$Builder<($Struct), ($Struct$Builder)> implements $StructOrBuilder {


public "getFieldsOrDefault"(arg0: string, arg1: $Value$Type): $Value
public "containsFields"(arg0: string): boolean
public "getFieldsOrThrow"(arg0: string): $Value
public "getFieldsCount"(): integer
public "getFieldsMap"(): $Map<(string), ($Value)>
/**
 * 
 * @deprecated
 */
public "getFields"(): $Map<(string), ($Value)>
public "putFields"(arg0: string, arg1: $Value$Type): $Struct$Builder
public "putAllFields"(arg0: $Map$Type<(string), ($Value$Type)>): $Struct$Builder
public "clearFields"(): $Struct$Builder
public "removeFields"(arg0: string): $Struct$Builder
get "fieldsCount"(): integer
get "fieldsMap"(): $Map<(string), ($Value)>
get "fields"(): $Map<(string), ($Value)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Struct$Builder$Type = ($Struct$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Struct$Builder_ = $Struct$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos" {
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $BlockNBTComponent$Pos extends $Examinable {

 "asString"(): string
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>

(input: string): $BlockNBTComponent$Pos
}

export namespace $BlockNBTComponent$Pos {
function fromString(input: string): $BlockNBTComponent$Pos
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponent$Pos$Type = ($BlockNBTComponent$Pos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponent$Pos_ = $BlockNBTComponent$Pos$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Codec$Encoder" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"

export interface $Codec$Encoder<D, E, X extends $Throwable> {

 "encode"(decoded: D): E

(decoded: D): E
}

export namespace $Codec$Encoder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Codec$Encoder$Type<D, E, X> = ($Codec$Encoder<(D), (E), (X)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Codec$Encoder_<D, E, X> = $Codec$Encoder$Type<(D), (E), (X)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc$Builder" {
import {$SparkProtos$PlatformStatistics$Gc, $SparkProtos$PlatformStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Gc"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformStatistics$GcOrBuilder, $SparkProtos$PlatformStatistics$GcOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$GcOrBuilder"

export class $SparkProtos$PlatformStatistics$Gc$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Gc), ($SparkProtos$PlatformStatistics$Gc$Builder)> implements $SparkProtos$PlatformStatistics$GcOrBuilder {


public "getTotal"(): long
public "clearTotal"(): $SparkProtos$PlatformStatistics$Gc$Builder
public "setTotal"(arg0: long): $SparkProtos$PlatformStatistics$Gc$Builder
public "setAvgFrequency"(arg0: double): $SparkProtos$PlatformStatistics$Gc$Builder
public "setAvgTime"(arg0: double): $SparkProtos$PlatformStatistics$Gc$Builder
public "getAvgFrequency"(): double
public "getAvgTime"(): double
public "clearAvgFrequency"(): $SparkProtos$PlatformStatistics$Gc$Builder
public "clearAvgTime"(): $SparkProtos$PlatformStatistics$Gc$Builder
get "total"(): long
set "total"(value: long)
set "avgFrequency"(value: double)
set "avgTime"(value: double)
get "avgFrequency"(): double
get "avgTime"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Gc$Builder$Type = ($SparkProtos$PlatformStatistics$Gc$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Gc$Builder_ = $SparkProtos$PlatformStatistics$Gc$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder" {
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $HandshakeBuilder extends $Handshakedata {

 "put"(arg0: string, arg1: string): void
 "setContent"(arg0: (byte)[]): void
 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $HandshakeBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HandshakeBuilder$Type = ($HandshakeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HandshakeBuilder_ = $HandshakeBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/window/$ProfilingWindowUtils" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $ProfilingWindowUtils extends $Enum<($ProfilingWindowUtils)> {
static readonly "WINDOW_SIZE_SECONDS": integer
static readonly "HISTORY_SIZE": integer


public static "values"(): ($ProfilingWindowUtils)[]
public static "valueOf"(arg0: string): $ProfilingWindowUtils
public static "unixMillisToWindow"(arg0: long): integer
public static "keepHistoryBefore"(arg0: integer): $IntPredicate
public static "windowNow"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProfilingWindowUtils$Type = (never) | ($ProfilingWindowUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProfilingWindowUtils_ = $ProfilingWindowUtils$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $ScoreComponent$Builder extends $ComponentBuilder<($ScoreComponent), ($ScoreComponent$Builder)> {

 "name"(name: string): $ScoreComponent$Builder
/**
 * 
 * @deprecated
 */
 "value"(value: string): $ScoreComponent$Builder
 "objective"(objective: string): $ScoreComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $ScoreComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $ScoreComponent$Builder
 "append"(...components: ($Component$Type)[]): $ScoreComponent$Builder
 "append"(component: $Component$Type): $ScoreComponent$Builder
 "append"(component: $ComponentLike$Type): $ScoreComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $ScoreComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $ScoreComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $ScoreComponent$Builder
 "style"(style: $Style$Type): $ScoreComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $ScoreComponent$Builder
 "mergeStyle"(that: $Component$Type): $ScoreComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $ScoreComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $ScoreComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $ScoreComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $ScoreComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $ScoreComponent$Builder
 "resetStyle"(): $ScoreComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $ScoreComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $ScoreComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $ScoreComponent$Builder
 "font"(font: $Key$Type): $ScoreComponent$Builder
 "appendSpace"(): $ScoreComponent$Builder
 "insertion"(insertion: string): $ScoreComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $ScoreComponent$Builder
}

export namespace $ScoreComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $ScoreComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ScoreComponent$Builder$Type = ($ScoreComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ScoreComponent$Builder_ = $ScoreComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$WorldStatistics$WorldOrBuilder, $SparkProtos$WorldStatistics$WorldOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$WorldOrBuilder"
import {$SparkProtos$WorldStatistics$RegionOrBuilder, $SparkProtos$WorldStatistics$RegionOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$RegionOrBuilder"
import {$SparkProtos$WorldStatistics$Region, $SparkProtos$WorldStatistics$Region$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region"
import {$SparkProtos$WorldStatistics$World$Builder, $SparkProtos$WorldStatistics$World$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkProtos$WorldStatistics$World extends $GeneratedMessageLite<($SparkProtos$WorldStatistics$World), ($SparkProtos$WorldStatistics$World$Builder)> implements $SparkProtos$WorldStatistics$WorldOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "TOTAL_ENTITIES_FIELD_NUMBER": integer
static readonly "REGIONS_FIELD_NUMBER": integer


public "getRegionsList"(): $List<($SparkProtos$WorldStatistics$Region)>
public "getRegionsCount"(): integer
public "getName"(): string
public static "parser"(): $Parser<($SparkProtos$WorldStatistics$World)>
public static "newBuilder"(): $SparkProtos$WorldStatistics$World$Builder
public static "newBuilder"(arg0: $SparkProtos$WorldStatistics$World$Type): $SparkProtos$WorldStatistics$World$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$World
public static "getDefaultInstance"(): $SparkProtos$WorldStatistics$World
public "getNameBytes"(): $ByteString
public "getRegions"(arg0: integer): $SparkProtos$WorldStatistics$Region
public "getRegionsOrBuilderList"(): $List<(any)>
public "getRegionsOrBuilder"(arg0: integer): $SparkProtos$WorldStatistics$RegionOrBuilder
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$WorldStatistics$World
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$World
public "getTotalEntities"(): integer
get "regionsList"(): $List<($SparkProtos$WorldStatistics$Region)>
get "regionsCount"(): integer
get "name"(): string
get "defaultInstance"(): $SparkProtos$WorldStatistics$World
get "nameBytes"(): $ByteString
get "regionsOrBuilderList"(): $List<(any)>
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$World$Type = ($SparkProtos$WorldStatistics$World);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$World_ = $SparkProtos$WorldStatistics$World$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TextReplacementRenderer$State" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TextReplacementRenderer$State {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextReplacementRenderer$State$Type = ($TextReplacementRenderer$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextReplacementRenderer$State_ = $TextReplacementRenderer$State$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/examination/string/$StringExaminer" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractExaminer, $AbstractExaminer$Type} from "packages/me/lucko/spark/lib/adventure/examination/$AbstractExaminer"

export class $StringExaminer extends $AbstractExaminer<(string)> {

constructor(escaper: $Function$Type<(string), (string)>)

public static "simpleEscaping"(): $StringExaminer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringExaminer$Type = ($StringExaminer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringExaminer_ = $StringExaminer$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata" {
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkHeapProtos$HeapMetadataOrBuilder, $SparkHeapProtos$HeapMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadataOrBuilder"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkHeapProtos$HeapMetadata$Builder, $SparkHeapProtos$HeapMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapMetadata$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"

export class $SparkHeapProtos$HeapMetadata extends $GeneratedMessageLite<($SparkHeapProtos$HeapMetadata), ($SparkHeapProtos$HeapMetadata$Builder)> implements $SparkHeapProtos$HeapMetadataOrBuilder {
static readonly "CREATOR_FIELD_NUMBER": integer
static readonly "PLATFORM_METADATA_FIELD_NUMBER": integer
static readonly "PLATFORM_STATISTICS_FIELD_NUMBER": integer
static readonly "SYSTEM_STATISTICS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkHeapProtos$HeapMetadata)>
public static "newBuilder"(): $SparkHeapProtos$HeapMetadata$Builder
public static "newBuilder"(arg0: $SparkHeapProtos$HeapMetadata$Type): $SparkHeapProtos$HeapMetadata$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapMetadata
public static "getDefaultInstance"(): $SparkHeapProtos$HeapMetadata
public "getCreator"(): $SparkProtos$CommandSenderMetadata
public "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
public "getSystemStatistics"(): $SparkProtos$SystemStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $ByteString$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $InputStream$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkHeapProtos$HeapMetadata
public static "parseFrom"(arg0: (byte)[]): $SparkHeapProtos$HeapMetadata
public "hasPlatformMetadata"(): boolean
public "hasSystemStatistics"(): boolean
public "hasPlatformStatistics"(): boolean
public "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
public "hasCreator"(): boolean
get "defaultInstance"(): $SparkHeapProtos$HeapMetadata
get "creator"(): $SparkProtos$CommandSenderMetadata
get "platformStatistics"(): $SparkProtos$PlatformStatistics
get "systemStatistics"(): $SparkProtos$SystemStatistics
get "platformMetadata"(): $SparkProtos$PlatformMetadata
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapMetadata$Type = ($SparkHeapProtos$HeapMetadata);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapMetadata_ = $SparkHeapProtos$HeapMetadata$Type;
}}
declare module "packages/me/lucko/spark/forge/$ForgeExtraMetadataProvider" {
import {$PackRepository, $PackRepository$Type} from "packages/net/minecraft/server/packs/repository/$PackRepository"
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$MetadataProvider, $MetadataProvider$Type} from "packages/me/lucko/spark/common/platform/$MetadataProvider"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ForgeExtraMetadataProvider implements $MetadataProvider {

constructor(arg0: $PackRepository$Type)

public "get"(): $Map<(string), ($JsonElement)>
public "export"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgeExtraMetadataProvider$Type = ($ForgeExtraMetadataProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgeExtraMetadataProvider_ = $ForgeExtraMetadataProvider$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/types/$GenericStatistic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Statistic, $Statistic$Type} from "packages/me/lucko/spark/api/statistic/$Statistic"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export interface $GenericStatistic<T, W extends ($Enum<(W)>) & ($StatisticWindow)> extends $Statistic<(W)> {

 "poll"(arg0: W): T
 "poll"(): (T)[]
 "name"(): string
 "getWindows"(): (W)[]
}

export namespace $GenericStatistic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GenericStatistic$Type<T, W> = ($GenericStatistic<(T), (W)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GenericStatistic_<T, W> = $GenericStatistic$Type<(T), (W)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry$Builder" {
import {$SparkHeapProtos$HeapEntry, $SparkHeapProtos$HeapEntry$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntry"
import {$SparkHeapProtos$HeapEntryOrBuilder, $SparkHeapProtos$HeapEntryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapEntryOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"

export class $SparkHeapProtos$HeapEntry$Builder extends $GeneratedMessageLite$Builder<($SparkHeapProtos$HeapEntry), ($SparkHeapProtos$HeapEntry$Builder)> implements $SparkHeapProtos$HeapEntryOrBuilder {


public "getType"(): string
public "getSize"(): long
public "setSize"(arg0: long): $SparkHeapProtos$HeapEntry$Builder
public "setType"(arg0: string): $SparkHeapProtos$HeapEntry$Builder
public "setOrder"(arg0: integer): $SparkHeapProtos$HeapEntry$Builder
public "getOrder"(): integer
public "clearOrder"(): $SparkHeapProtos$HeapEntry$Builder
public "clearInstances"(): $SparkHeapProtos$HeapEntry$Builder
public "clearSize"(): $SparkHeapProtos$HeapEntry$Builder
public "setTypeBytes"(arg0: $ByteString$Type): $SparkHeapProtos$HeapEntry$Builder
public "getTypeBytes"(): $ByteString
public "getInstances"(): integer
public "setInstances"(arg0: integer): $SparkHeapProtos$HeapEntry$Builder
public "clearType"(): $SparkHeapProtos$HeapEntry$Builder
get "type"(): string
get "size"(): long
set "size"(value: long)
set "type"(value: string)
set "order"(value: integer)
get "order"(): integer
set "typeBytes"(value: $ByteString$Type)
get "typeBytes"(): $ByteString
get "instances"(): integer
set "instances"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkHeapProtos$HeapEntry$Builder$Type = ($SparkHeapProtos$HeapEntry$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkHeapProtos$HeapEntry$Builder_ = $SparkHeapProtos$HeapEntry$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/util/$ByteBufferUtils" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $ByteBufferUtils {


public static "getEmptyByteBuffer"(): $ByteBuffer
public static "transferByteBuffer"(arg0: $ByteBuffer$Type, arg1: $ByteBuffer$Type): integer
get "emptyByteBuffer"(): $ByteBuffer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBufferUtils$Type = ($ByteBufferUtils);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBufferUtils_ = $ByteBufferUtils$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$DecorationMap" {
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$AbstractMap, $AbstractMap$Type} from "packages/java/util/$AbstractMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $DecorationMap extends $AbstractMap<($TextDecoration), ($TextDecoration$State)> implements $Examinable {


public "get"(o: any): $TextDecoration$State
public "equals"(other: any): boolean
public "values"(): $Collection<($TextDecoration$State)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "size"(): integer
public "entrySet"(): $Set<($Map$Entry<($TextDecoration), ($TextDecoration$State)>)>
public "containsKey"(key: any): boolean
public "keySet"(): $Set<($TextDecoration)>
public "with"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $DecorationMap
public "examinableProperties"(): $Stream<(any)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DecorationMap$Type = ($DecorationMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DecorationMap_ = $DecorationMap$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$WorldStatistics$ChunkOrBuilder, $SparkProtos$WorldStatistics$ChunkOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$ChunkOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$WorldStatistics$RegionOrBuilder, $SparkProtos$WorldStatistics$RegionOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$RegionOrBuilder"
import {$SparkProtos$WorldStatistics$Region$Builder, $SparkProtos$WorldStatistics$Region$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$WorldStatistics$Chunk, $SparkProtos$WorldStatistics$Chunk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk"

export class $SparkProtos$WorldStatistics$Region extends $GeneratedMessageLite<($SparkProtos$WorldStatistics$Region), ($SparkProtos$WorldStatistics$Region$Builder)> implements $SparkProtos$WorldStatistics$RegionOrBuilder {
static readonly "TOTAL_ENTITIES_FIELD_NUMBER": integer
static readonly "CHUNKS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$WorldStatistics$Region)>
public static "newBuilder"(arg0: $SparkProtos$WorldStatistics$Region$Type): $SparkProtos$WorldStatistics$Region$Builder
public static "newBuilder"(): $SparkProtos$WorldStatistics$Region$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$Region
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "getDefaultInstance"(): $SparkProtos$WorldStatistics$Region
public "getChunks"(arg0: integer): $SparkProtos$WorldStatistics$Chunk
public "getChunksList"(): $List<($SparkProtos$WorldStatistics$Chunk)>
public "getChunksOrBuilderList"(): $List<(any)>
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics$Region
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$WorldStatistics$Region
public "getChunksOrBuilder"(arg0: integer): $SparkProtos$WorldStatistics$ChunkOrBuilder
public "getChunksCount"(): integer
public "getTotalEntities"(): integer
get "defaultInstance"(): $SparkProtos$WorldStatistics$Region
get "chunksList"(): $List<($SparkProtos$WorldStatistics$Chunk)>
get "chunksOrBuilderList"(): $List<(any)>
get "chunksCount"(): integer
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Region$Type = ($SparkProtos$WorldStatistics$Region);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$Region_ = $SparkProtos$WorldStatistics$Region$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentInternals" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ComponentInternals {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentInternals$Type = ($ComponentInternals);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentInternals_ = $ComponentInternals$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$GeneratedExtension" {
import {$ExtensionLite, $ExtensionLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionLite"
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $GeneratedMessageLite$GeneratedExtension<ContainingType extends $MessageLite, Type> extends $ExtensionLite<(ContainingType), (Type)> {


public "getDefaultValue"(): Type
public "getNumber"(): integer
public "getMessageDefaultInstance"(): $MessageLite
public "isRepeated"(): boolean
public "getLiteType"(): $WireFormat$FieldType
public "getContainingTypeDefaultInstance"(): ContainingType
get "defaultValue"(): Type
get "number"(): integer
get "messageDefaultInstance"(): $MessageLite
get "repeated"(): boolean
get "liteType"(): $WireFormat$FieldType
get "containingTypeDefaultInstance"(): ContainingType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedMessageLite$GeneratedExtension$Type<ContainingType, Type> = ($GeneratedMessageLite$GeneratedExtension<(ContainingType), (Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedMessageLite$GeneratedExtension_<ContainingType, Type> = $GeneratedMessageLite$GeneratedExtension$Type<(ContainingType), (Type)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SelectorComponent extends $BuildableComponent<($SelectorComponent), ($SelectorComponent$Builder)>, $ScopedComponent<($SelectorComponent)> {

 "separator"(): $Component
 "separator"(separator: $ComponentLike$Type): $SelectorComponent
 "pattern"(): string
 "pattern"(pattern: string): $SelectorComponent
 "examinableProperties"(): $Stream<(any)>
 "toBuilder"(): $SelectorComponent$Builder
 "append"(component: $Component$Type): $SelectorComponent
 "append"(like: $ComponentLike$Type): $SelectorComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $SelectorComponent
 "color"(color: $TextColor$Type): $SelectorComponent
 "style"(style: $Style$Type): $SelectorComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $SelectorComponent
 "style"(style: $Style$Builder$Type): $SelectorComponent
 "children"(children: $List$Type<(any)>): $SelectorComponent
 "mergeStyle"(that: $Component$Type): $SelectorComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $SelectorComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $SelectorComponent
 "colorIfAbsent"(color: $TextColor$Type): $SelectorComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $SelectorComponent
 "clickEvent"(event: $ClickEvent$Type): $SelectorComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $SelectorComponent
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $SelectorComponent {
function configureAndBuild<R, B>(builder: $SelectorComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $SelectorComponent
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectorComponent$Type = ($SelectorComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectorComponent_ = $SelectorComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$Pointers" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Pointers$Builder, $Pointers$Builder$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"

export interface $Pointers extends $Buildable<($Pointers), ($Pointers$Builder)> {

 "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
 "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
 "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T
 "supports"<T>(pointer: $Pointer$Type<(T)>): boolean
 "toBuilder"(): $Pointers$Builder
}

export namespace $Pointers {
function builder(): $Pointers$Builder
function empty(): $Pointers
function configureAndBuild<R, B>(builder: $Pointers$Builder$Type, consumer: $Consumer$Type<(any)>): $Pointers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pointers$Type = ($Pointers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pointers_ = $Pointers$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode$Builder" {
import {$SparkSamplerProtos$StackTraceNodeOrBuilder, $SparkSamplerProtos$StackTraceNodeOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNodeOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkSamplerProtos$StackTraceNode, $SparkSamplerProtos$StackTraceNode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$StackTraceNode"

export class $SparkSamplerProtos$StackTraceNode$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$StackTraceNode), ($SparkSamplerProtos$StackTraceNode$Builder)> implements $SparkSamplerProtos$StackTraceNodeOrBuilder {


public "getTimesList"(): $List<(double)>
public "setChildrenRefs"(arg0: integer, arg1: integer): $SparkSamplerProtos$StackTraceNode$Builder
public "clearChildrenRefs"(): $SparkSamplerProtos$StackTraceNode$Builder
public "getChildrenRefs"(arg0: integer): integer
public "addAllTimes"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$StackTraceNode$Builder
public "addChildrenRefs"(arg0: integer): $SparkSamplerProtos$StackTraceNode$Builder
public "clearTimes"(): $SparkSamplerProtos$StackTraceNode$Builder
public "getTimesCount"(): integer
public "getLineNumber"(): integer
public "getClassName"(): string
public "getMethodName"(): string
public "setTimes"(arg0: integer, arg1: double): $SparkSamplerProtos$StackTraceNode$Builder
public "setClassName"(arg0: string): $SparkSamplerProtos$StackTraceNode$Builder
public "getTimes"(arg0: integer): double
public "getMethodDesc"(): string
public "setLineNumber"(arg0: integer): $SparkSamplerProtos$StackTraceNode$Builder
public "setMethodName"(arg0: string): $SparkSamplerProtos$StackTraceNode$Builder
public "addTimes"(arg0: double): $SparkSamplerProtos$StackTraceNode$Builder
public "setMethodDesc"(arg0: string): $SparkSamplerProtos$StackTraceNode$Builder
public "addAllChildrenRefs"(arg0: $Iterable$Type<(any)>): $SparkSamplerProtos$StackTraceNode$Builder
public "getParentLineNumber"(): integer
public "setParentLineNumber"(arg0: integer): $SparkSamplerProtos$StackTraceNode$Builder
public "getClassNameBytes"(): $ByteString
public "clearClassName"(): $SparkSamplerProtos$StackTraceNode$Builder
public "setMethodDescBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$StackTraceNode$Builder
public "getMethodNameBytes"(): $ByteString
public "getMethodDescBytes"(): $ByteString
public "clearMethodDesc"(): $SparkSamplerProtos$StackTraceNode$Builder
public "setClassNameBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$StackTraceNode$Builder
public "clearLineNumber"(): $SparkSamplerProtos$StackTraceNode$Builder
public "clearMethodName"(): $SparkSamplerProtos$StackTraceNode$Builder
public "setMethodNameBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$StackTraceNode$Builder
public "clearParentLineNumber"(): $SparkSamplerProtos$StackTraceNode$Builder
public "getChildrenRefsList"(): $List<(integer)>
public "getChildrenRefsCount"(): integer
get "timesList"(): $List<(double)>
get "timesCount"(): integer
get "lineNumber"(): integer
get "className"(): string
get "methodName"(): string
set "className"(value: string)
get "methodDesc"(): string
set "lineNumber"(value: integer)
set "methodName"(value: string)
set "methodDesc"(value: string)
get "parentLineNumber"(): integer
set "parentLineNumber"(value: integer)
get "classNameBytes"(): $ByteString
set "methodDescBytes"(value: $ByteString$Type)
get "methodNameBytes"(): $ByteString
get "methodDescBytes"(): $ByteString
set "classNameBytes"(value: $ByteString$Type)
set "methodNameBytes"(value: $ByteString$Type)
get "childrenRefsList"(): $List<(integer)>
get "childrenRefsCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$StackTraceNode$Builder$Type = ($SparkSamplerProtos$StackTraceNode$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$StackTraceNode$Builder_ = $SparkSamplerProtos$StackTraceNode$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$TriState, $TriState$Type} from "packages/me/lucko/spark/lib/adventure/util/$TriState"

export class $TextDecoration$State extends $Enum<($TextDecoration$State)> {
static readonly "NOT_SET": $TextDecoration$State
static readonly "FALSE": $TextDecoration$State
static readonly "TRUE": $TextDecoration$State


public "toString"(): string
public static "values"(): ($TextDecoration$State)[]
public static "valueOf"(name: string): $TextDecoration$State
public static "byBoolean"(flag: boolean): $TextDecoration$State
public static "byBoolean"(flag: boolean): $TextDecoration$State
public static "byTriState"(flag: $TriState$Type): $TextDecoration$State
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextDecoration$State$Type = (("not_set") | ("false") | ("true")) | ($TextDecoration$State);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextDecoration$State_ = $TextDecoration$State$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkWebSocketProtos$ServerConnectResponse$Settings, $SparkWebSocketProtos$ServerConnectResponse$Settings$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings"
import {$SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder, $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder"

export class $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ServerConnectResponse$Settings), ($SparkWebSocketProtos$ServerConnectResponse$Settings$Builder)> implements $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder {


public "setSamplerInterval"(arg0: integer): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
public "setStatisticsInterval"(arg0: integer): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
public "getSamplerInterval"(): integer
public "clearSamplerInterval"(): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
public "getStatisticsInterval"(): integer
public "clearStatisticsInterval"(): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
set "samplerInterval"(value: integer)
set "statisticsInterval"(value: integer)
get "samplerInterval"(): integer
get "statisticsInterval"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type = ($SparkWebSocketProtos$ServerConnectResponse$Settings$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder_ = $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination" {
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Pagination$Renderer, $Pagination$Renderer$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Renderer"
import {$Pagination$Builder, $Pagination$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Pagination<T> {

 "render"(content: $Collection$Type<(any)>, page: integer): $List<($Component)>

(): $Pagination$Builder
}

export namespace $Pagination {
const WIDTH: integer
const RESULTS_PER_PAGE: integer
const LINE_CHARACTER: character
const LINE_STYLE: $Style
const PREVIOUS_PAGE_BUTTON_CHARACTER: character
const PREVIOUS_PAGE_BUTTON_STYLE: $Style
const NEXT_PAGE_BUTTON_CHARACTER: character
const NEXT_PAGE_BUTTON_STYLE: $Style
const DEFAULT_RENDERER: $Pagination$Renderer
function builder(): $Pagination$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pagination$Type<T> = ($Pagination<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pagination_<T> = $Pagination$Type<(T)>;
}}
declare module "packages/me/lucko/spark/common/activitylog/$Activity" {
import {$JsonElement, $JsonElement$Type} from "packages/com/google/gson/$JsonElement"
import {$JsonObject, $JsonObject$Type} from "packages/com/google/gson/$JsonObject"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"
import {$CommandSender$Data, $CommandSender$Data$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender$Data"

export class $Activity {
static readonly "DATA_TYPE_URL": string
static readonly "DATA_TYPE_FILE": string


public "getType"(): string
public "getTime"(): long
public static "deserialize"(arg0: $JsonElement$Type): $Activity
public "getUser"(): $CommandSender$Data
public "getDataValue"(): string
public "shouldExpire"(): boolean
public static "fileActivity"(arg0: $CommandSender$Type, arg1: long, arg2: string, arg3: string): $Activity
public static "urlActivity"(arg0: $CommandSender$Type, arg1: long, arg2: string, arg3: string): $Activity
public "getDataType"(): string
public "serialize"(): $JsonObject
get "type"(): string
get "time"(): long
get "user"(): $CommandSender$Data
get "dataValue"(): string
get "dataType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Activity$Type = ($Activity);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Activity_ = $Activity$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Internal$EnumLite {

 "getNumber"(): integer

(): integer
}

export namespace $Internal$EnumLite {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$EnumLite$Type = ($Internal$EnumLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$EnumLite_ = $Internal$EnumLite$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$NioByteString" {
import {$ByteString$LeafByteString, $ByteString$LeafByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString$LeafByteString"
import {$OutputStream, $OutputStream$Type} from "packages/java/io/$OutputStream"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$List, $List$Type} from "packages/java/util/$List"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $NioByteString extends $ByteString$LeafByteString {
static readonly "EMPTY": $ByteString


public "equals"(arg0: any): boolean
public "substring"(arg0: integer, arg1: integer): $ByteString
public "size"(): integer
public "writeTo"(arg0: $OutputStream$Type): void
public "newCodedInput"(): $CodedInputStream
public "isValidUtf8"(): boolean
public "copyTo"(arg0: $ByteBuffer$Type): void
public "byteAt"(arg0: integer): byte
public "asReadOnlyByteBufferList"(): $List<($ByteBuffer)>
public "asReadOnlyByteBuffer"(): $ByteBuffer
public "internalByteAt"(arg0: integer): byte
public "newInput"(): $InputStream
get "validUtf8"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NioByteString$Type = ($NioByteString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NioByteString_ = $NioByteString$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$TpsOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$TpsOrBuilder extends $MessageLiteOrBuilder {

 "getLast5M"(): double
 "getLast1M"(): double
 "getLast15M"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$TpsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$TpsOrBuilder$Type = ($SparkProtos$PlatformStatistics$TpsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$TpsOrBuilder_ = $SparkProtos$PlatformStatistics$TpsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$ExtensionRequestData" {
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $ExtensionRequestData {
static readonly "EMPTY_VALUE": string


public "getExtensionName"(): string
public "getExtensionParameters"(): $Map<(string), (string)>
public static "parseExtensionRequest"(arg0: string): $ExtensionRequestData
get "extensionName"(): string
get "extensionParameters"(): $Map<(string), (string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionRequestData$Type = ($ExtensionRequestData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionRequestData_ = $ExtensionRequestData$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$Attacher" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Attacher {


public static "main"(arg0: (string)[]): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Attacher$Type = ($Attacher);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Attacher_ = $Attacher$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/internal/properties/$AdventurePropertiesImpl" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $AdventurePropertiesImpl {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AdventurePropertiesImpl$Type = ($AdventurePropertiesImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AdventurePropertiesImpl_ = $AdventurePropertiesImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$AbstractNBTComponentBuilder" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$AbstractComponentBuilder, $AbstractComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponentBuilder"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $AbstractNBTComponentBuilder<C extends $NBTComponent<(C), (B)>, B extends $NBTComponentBuilder<(C), (B)>> extends $AbstractComponentBuilder<(C), (B)> implements $NBTComponentBuilder<(C), (B)> {


public "separator"(separator: $ComponentLike$Type): B
public "nbtPath"(nbtPath: string): B
public "interpret"(interpret: boolean): B
public static "configureAndBuild"<R, B extends $AbstractBuilder<(R)>>(builder: B, consumer: $Consumer$Type<(any)>): C
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractNBTComponentBuilder$Type<C, B> = ($AbstractNBTComponentBuilder<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractNBTComponentBuilder_<C, B> = $AbstractNBTComponentBuilder$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Field$Cardinality" {
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$Internal$EnumLite, $Internal$EnumLite$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLite"

export class $Field$Cardinality extends $Enum<($Field$Cardinality)> implements $Internal$EnumLite {
static readonly "CARDINALITY_UNKNOWN": $Field$Cardinality
static readonly "CARDINALITY_OPTIONAL": $Field$Cardinality
static readonly "CARDINALITY_REQUIRED": $Field$Cardinality
static readonly "CARDINALITY_REPEATED": $Field$Cardinality
static readonly "UNRECOGNIZED": $Field$Cardinality
static readonly "CARDINALITY_UNKNOWN_VALUE": integer
static readonly "CARDINALITY_OPTIONAL_VALUE": integer
static readonly "CARDINALITY_REQUIRED_VALUE": integer
static readonly "CARDINALITY_REPEATED_VALUE": integer


public static "values"(): ($Field$Cardinality)[]
public static "valueOf"(arg0: string): $Field$Cardinality
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $Field$Cardinality
public "getNumber"(): integer
public static "internalGetValueMap"(): $Internal$EnumLiteMap<($Field$Cardinality)>
public static "internalGetVerifier"(): $Internal$EnumVerifier
public static "forNumber"(arg0: integer): $Field$Cardinality
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Field$Cardinality$Type = (("cardinality_optional") | ("cardinality_unknown") | ("cardinality_repeated") | ("unrecognized") | ("cardinality_required")) | ($Field$Cardinality);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Field$Cardinality_ = $Field$Cardinality$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder extends $MessageLiteOrBuilder {

 "getSamplerInterval"(): integer
 "getStatisticsInterval"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder$Type = ($SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder_ = $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$ThreadGrouper" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper, $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper"

export interface $ThreadGrouper {

 "asProto"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
 "getLabel"(arg0: string): string
 "getGroup"(arg0: long, arg1: string): string
}

export namespace $ThreadGrouper {
const BY_NAME: $ThreadGrouper
const BY_POOL: $ThreadGrouper
const AS_ONE: $ThreadGrouper
function parseConfigSetting(arg0: string): $ThreadGrouper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ThreadGrouper$Type = ($ThreadGrouper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ThreadGrouper_ = $ThreadGrouper$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldSet$FieldDescriptorLite" {
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$WireFormat$JavaType, $WireFormat$JavaType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$JavaType"
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"

export interface $FieldSet$FieldDescriptorLite<T extends $FieldSet$FieldDescriptorLite<(T)>> extends $Comparable<(T)> {

 "getNumber"(): integer
 "internalMergeFrom"(arg0: $MessageLite$Builder$Type, arg1: $MessageLite$Type): $MessageLite$Builder
 "isPacked"(): boolean
 "isRepeated"(): boolean
 "getEnumType"(): $Internal$EnumLiteMap<(any)>
 "getLiteType"(): $WireFormat$FieldType
 "getLiteJavaType"(): $WireFormat$JavaType
 "compareTo"(arg0: T): integer
}

export namespace $FieldSet$FieldDescriptorLite {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldSet$FieldDescriptorLite$Type<T> = ($FieldSet$FieldDescriptorLite<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldSet$FieldDescriptorLite_<T> = $FieldSet$FieldDescriptorLite$Type<(T)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Builder" {
import {$SparkProtos$SystemStatistics$Memory, $SparkProtos$SystemStatistics$Memory$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory"
import {$SparkProtos$SystemStatistics$Os, $SparkProtos$SystemStatistics$Os$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$Cpu$Builder, $SparkProtos$SystemStatistics$Cpu$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu$Builder"
import {$SparkProtos$SystemStatistics$Disk$Builder, $SparkProtos$SystemStatistics$Disk$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk$Builder"
import {$SparkProtos$SystemStatistics$Disk, $SparkProtos$SystemStatistics$Disk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Disk"
import {$SparkProtos$SystemStatistics$Java, $SparkProtos$SystemStatistics$Java$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java"
import {$SparkProtos$SystemStatistics$Os$Builder, $SparkProtos$SystemStatistics$Os$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Os$Builder"
import {$SparkProtos$SystemStatistics$NetInterface, $SparkProtos$SystemStatistics$NetInterface$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$NetInterface"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkProtos$SystemStatisticsOrBuilder, $SparkProtos$SystemStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatisticsOrBuilder"
import {$SparkProtos$SystemStatistics$Memory$Builder, $SparkProtos$SystemStatistics$Memory$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$Builder"
import {$SparkProtos$SystemStatistics$Java$Builder, $SparkProtos$SystemStatistics$Java$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java$Builder"
import {$SparkProtos$SystemStatistics$Gc, $SparkProtos$SystemStatistics$Gc$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Gc"
import {$SparkProtos$SystemStatistics$Cpu, $SparkProtos$SystemStatistics$Cpu$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Cpu"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkProtos$SystemStatistics$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$SystemStatistics), ($SparkProtos$SystemStatistics$Builder)> implements $SparkProtos$SystemStatisticsOrBuilder {


public "getOs"(): $SparkProtos$SystemStatistics$Os
public "setMemory"(arg0: $SparkProtos$SystemStatistics$Memory$Builder$Type): $SparkProtos$SystemStatistics$Builder
public "setMemory"(arg0: $SparkProtos$SystemStatistics$Memory$Type): $SparkProtos$SystemStatistics$Builder
public "getUptime"(): long
public "getMemory"(): $SparkProtos$SystemStatistics$Memory
public "setDisk"(arg0: $SparkProtos$SystemStatistics$Disk$Builder$Type): $SparkProtos$SystemStatistics$Builder
public "setDisk"(arg0: $SparkProtos$SystemStatistics$Disk$Type): $SparkProtos$SystemStatistics$Builder
public "setJava"(arg0: $SparkProtos$SystemStatistics$Java$Builder$Type): $SparkProtos$SystemStatistics$Builder
public "setJava"(arg0: $SparkProtos$SystemStatistics$Java$Type): $SparkProtos$SystemStatistics$Builder
public "setCpu"(arg0: $SparkProtos$SystemStatistics$Cpu$Builder$Type): $SparkProtos$SystemStatistics$Builder
public "setCpu"(arg0: $SparkProtos$SystemStatistics$Cpu$Type): $SparkProtos$SystemStatistics$Builder
public "setOs"(arg0: $SparkProtos$SystemStatistics$Os$Type): $SparkProtos$SystemStatistics$Builder
public "setOs"(arg0: $SparkProtos$SystemStatistics$Os$Builder$Type): $SparkProtos$SystemStatistics$Builder
public "setUptime"(arg0: long): $SparkProtos$SystemStatistics$Builder
public "putNet"(arg0: string, arg1: $SparkProtos$SystemStatistics$NetInterface$Type): $SparkProtos$SystemStatistics$Builder
public "putGc"(arg0: string, arg1: $SparkProtos$SystemStatistics$Gc$Type): $SparkProtos$SystemStatistics$Builder
public "getGcOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$Gc$Type): $SparkProtos$SystemStatistics$Gc
public "hasMemory"(): boolean
public "clearMemory"(): $SparkProtos$SystemStatistics$Builder
public "clearUptime"(): $SparkProtos$SystemStatistics$Builder
public "getGcCount"(): integer
public "getGcMap"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
public "mergeMemory"(arg0: $SparkProtos$SystemStatistics$Memory$Type): $SparkProtos$SystemStatistics$Builder
/**
 * 
 * @deprecated
 */
public "getGc"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
public "getGcOrThrow"(arg0: string): $SparkProtos$SystemStatistics$Gc
public "containsGc"(arg0: string): boolean
public "hasJava"(): boolean
/**
 * 
 * @deprecated
 */
public "getNet"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
public "containsNet"(arg0: string): boolean
public "getNetMap"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
public "getCpu"(): $SparkProtos$SystemStatistics$Cpu
public "clearCpu"(): $SparkProtos$SystemStatistics$Builder
public "hasDisk"(): boolean
public "getJava"(): $SparkProtos$SystemStatistics$Java
public "hasCpu"(): boolean
public "clearJava"(): $SparkProtos$SystemStatistics$Builder
public "hasOs"(): boolean
public "clearDisk"(): $SparkProtos$SystemStatistics$Builder
public "clearOs"(): $SparkProtos$SystemStatistics$Builder
public "getNetCount"(): integer
public "mergeJava"(arg0: $SparkProtos$SystemStatistics$Java$Type): $SparkProtos$SystemStatistics$Builder
public "getDisk"(): $SparkProtos$SystemStatistics$Disk
public "mergeCpu"(arg0: $SparkProtos$SystemStatistics$Cpu$Type): $SparkProtos$SystemStatistics$Builder
public "mergeDisk"(arg0: $SparkProtos$SystemStatistics$Disk$Type): $SparkProtos$SystemStatistics$Builder
public "mergeOs"(arg0: $SparkProtos$SystemStatistics$Os$Type): $SparkProtos$SystemStatistics$Builder
public "getNetOrDefault"(arg0: string, arg1: $SparkProtos$SystemStatistics$NetInterface$Type): $SparkProtos$SystemStatistics$NetInterface
public "getNetOrThrow"(arg0: string): $SparkProtos$SystemStatistics$NetInterface
public "putAllNet"(arg0: $Map$Type<(string), ($SparkProtos$SystemStatistics$NetInterface$Type)>): $SparkProtos$SystemStatistics$Builder
public "clearNet"(): $SparkProtos$SystemStatistics$Builder
public "clearGc"(): $SparkProtos$SystemStatistics$Builder
public "removeGc"(arg0: string): $SparkProtos$SystemStatistics$Builder
public "removeNet"(arg0: string): $SparkProtos$SystemStatistics$Builder
public "putAllGc"(arg0: $Map$Type<(string), ($SparkProtos$SystemStatistics$Gc$Type)>): $SparkProtos$SystemStatistics$Builder
get "os"(): $SparkProtos$SystemStatistics$Os
set "memory"(value: $SparkProtos$SystemStatistics$Memory$Builder$Type)
set "memory"(value: $SparkProtos$SystemStatistics$Memory$Type)
get "uptime"(): long
get "memory"(): $SparkProtos$SystemStatistics$Memory
set "disk"(value: $SparkProtos$SystemStatistics$Disk$Builder$Type)
set "disk"(value: $SparkProtos$SystemStatistics$Disk$Type)
set "java"(value: $SparkProtos$SystemStatistics$Java$Builder$Type)
set "java"(value: $SparkProtos$SystemStatistics$Java$Type)
set "cpu"(value: $SparkProtos$SystemStatistics$Cpu$Builder$Type)
set "cpu"(value: $SparkProtos$SystemStatistics$Cpu$Type)
set "os"(value: $SparkProtos$SystemStatistics$Os$Type)
set "os"(value: $SparkProtos$SystemStatistics$Os$Builder$Type)
set "uptime"(value: long)
get "gcCount"(): integer
get "gcMap"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
get "gc"(): $Map<(string), ($SparkProtos$SystemStatistics$Gc)>
get "net"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
get "netMap"(): $Map<(string), ($SparkProtos$SystemStatistics$NetInterface)>
get "cpu"(): $SparkProtos$SystemStatistics$Cpu
get "java"(): $SparkProtos$SystemStatistics$Java
get "netCount"(): integer
get "disk"(): $SparkProtos$SystemStatistics$Disk
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Builder$Type = ($SparkProtos$SystemStatistics$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Builder_ = $SparkProtos$SystemStatistics$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder" {
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder, $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder"

export class $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Memory$MemoryPool), ($SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder)> implements $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder {


public "getTotal"(): long
public "clearTotal"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
public "clearUsed"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
public "getUsed"(): long
public "setUsed"(arg0: long): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
public "setTotal"(arg0: long): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
get "total"(): long
get "used"(): long
set "used"(value: long)
set "total"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type = ($SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder_ = $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectionMonitor$Listener" {
import {$GarbageCollectionNotificationInfo, $GarbageCollectionNotificationInfo$Type} from "packages/com/sun/management/$GarbageCollectionNotificationInfo"

export interface $GarbageCollectionMonitor$Listener {

 "onGc"(arg0: $GarbageCollectionNotificationInfo$Type): void

(arg0: $GarbageCollectionNotificationInfo$Type): void
}

export namespace $GarbageCollectionMonitor$Listener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GarbageCollectionMonitor$Listener$Type = ($GarbageCollectionMonitor$Listener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GarbageCollectionMonitor$Listener_ = $GarbageCollectionMonitor$Listener$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnknownFieldSchema" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $UnknownFieldSchema<T, B> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnknownFieldSchema$Type<T, B> = ($UnknownFieldSchema<(T), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnknownFieldSchema_<T, B> = $UnknownFieldSchema$Type<(T), (B)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper, $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type"

export interface $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder extends $MessageLiteOrBuilder {

 "getType"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
 "getTypeValue"(): integer
 "getThreadGrouperValue"(): integer
 "getTickLengthThreshold"(): long
 "getNumberOfIncludedTicks"(): integer
 "getThreadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder$Type = ($SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder_ = $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DoubleValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $DoubleValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $DoubleValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleValueOrBuilder$Type = ($DoubleValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleValueOrBuilder_ = $DoubleValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$Pointers$Builder" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"

export interface $Pointers$Builder extends $AbstractBuilder<($Pointers)>, $Buildable$Builder<($Pointers)> {

 "withStatic"<T>(pointer: $Pointer$Type<(T)>, value: T): $Pointers$Builder
 "withDynamic"<T>(pointer: $Pointer$Type<(T)>, value: $Supplier$Type<(T)>): $Pointers$Builder
 "build"(): $Pointers
}

export namespace $Pointers$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $Pointers
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Pointers$Builder$Type = ($Pointers$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Pointers$Builder_ = $Pointers$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/flattener/$FlattenerListener" {
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"

export interface $FlattenerListener {

 "pushStyle"(style: $Style$Type): void
 "popStyle"(style: $Style$Type): void
 "component"(text: string): void

(style: $Style$Type): void
}

export namespace $FlattenerListener {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FlattenerListener$Type = ($FlattenerListener);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FlattenerListener_ = $FlattenerListener$Type;
}}
declare module "packages/me/lucko/spark/common/heapdump/$HeapDumpSummary" {
import {$SparkHeapProtos$HeapData, $SparkHeapProtos$HeapData$Type} from "packages/me/lucko/spark/proto/$SparkHeapProtos$HeapData"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"

export class $HeapDumpSummary {


public static "createNew"(): $HeapDumpSummary
public "toProto"(arg0: $SparkPlatform$Type, arg1: $CommandSender$Type): $SparkHeapProtos$HeapData
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $HeapDumpSummary$Type = ($HeapDumpSummary);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $HeapDumpSummary_ = $HeapDumpSummary$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$SSLSocketChannel" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SSLEngine, $SSLEngine$Type} from "packages/javax/net/ssl/$SSLEngine"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$WrappedByteChannel, $WrappedByteChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WrappedByteChannel"
import {$SocketChannel, $SocketChannel$Type} from "packages/java/nio/channels/$SocketChannel"
import {$ISSLChannel, $ISSLChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/interfaces/$ISSLChannel"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SSLSocketChannel implements $WrappedByteChannel, $ByteChannel, $ISSLChannel {

constructor(arg0: $SocketChannel$Type, arg1: $SSLEngine$Type, arg2: $ExecutorService$Type, arg3: $SelectionKey$Type)

public "isOpen"(): boolean
public "write"(arg0: $ByteBuffer$Type): integer
public "read"(arg0: $ByteBuffer$Type): integer
public "close"(): void
public "isBlocking"(): boolean
public "getSSLEngine"(): $SSLEngine
public "isNeedWrite"(): boolean
public "writeMore"(): void
public "isNeedRead"(): boolean
public "readMore"(arg0: $ByteBuffer$Type): integer
get "open"(): boolean
get "blocking"(): boolean
get "sSLEngine"(): $SSLEngine
get "needWrite"(): boolean
get "needRead"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SSLSocketChannel$Type = ($SSLSocketChannel);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SSLSocketChannel_ = $SSLSocketChannel$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$TextFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$DataFrame"

export class $TextFrame extends $DataFrame {

constructor()

public "isValid"(): void
get "valid"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextFrame$Type = ($TextFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextFrame_ = $TextFrame$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $SparkWebSocketProtos {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$Type = ($SparkWebSocketProtos);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos_ = $SparkWebSocketProtos$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$BooleanArrayList" {
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Internal$BooleanList, $Internal$BooleanList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$BooleanList"
import {$PrimitiveNonBoxingCollection, $PrimitiveNonBoxingCollection$Type} from "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"

export class $BooleanArrayList extends $AbstractProtobufList<(boolean)> implements $Internal$BooleanList, $RandomAccess, $PrimitiveNonBoxingCollection {


public "add"(arg0: boolean): boolean
public "add"(arg0: integer, arg1: boolean): void
public "remove"(arg0: integer): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "getBoolean"(arg0: integer): boolean
public "size"(): integer
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: boolean): boolean
public static "emptyList"(): $BooleanArrayList
public "setBoolean"(arg0: integer, arg1: boolean): boolean
public "addBoolean"(arg0: boolean): void
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(boolean)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean): $List<(boolean)>
public static "of"<E>(): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean): $List<(boolean)>
public static "of"<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean): $List<(boolean)>
public static "of"<E>(...arg0: (boolean)[]): $List<(boolean)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BooleanArrayList$Type = ($BooleanArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BooleanArrayList_ = $BooleanArrayList$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/$Statistic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export interface $Statistic<W extends ($Enum<(W)>) & ($StatisticWindow)> {

 "name"(): string
 "getWindows"(): (W)[]
}

export namespace $Statistic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Statistic$Type<W> = ($Statistic<(W)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Statistic_<W> = $Statistic$Type<(W)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$NBTComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $NBTComponent<C extends $NBTComponent<(C), (B)>, B extends $NBTComponentBuilder<(C), (B)>> extends $BuildableComponent<(C), (B)> {

 "separator"(): $Component
 "separator"(separator: $ComponentLike$Type): C
 "nbtPath"(nbtPath: string): C
 "nbtPath"(): string
 "examinableProperties"(): $Stream<(any)>
 "interpret"(): boolean
 "interpret"(interpret: boolean): C
 "toBuilder"(): B
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $Component
 "append"(like: $ComponentLike$Type): $Component
 "append"(component: $Component$Type): $Component
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(color: $TextColor$Type): $Component
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(style: $Style$Type): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "style"(style: $Style$Builder$Type): $Component
 "children"(): $List<($Component)>
 "children"(children: $List$Type<(any)>): $Component
 "appendNewline"(): $Component
 "mergeStyle"(that: $Component$Type): $Component
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $Component
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "colorIfAbsent"(color: $TextColor$Type): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "decorate"(decoration: $TextDecoration$Type): $Component
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(event: $ClickEvent$Type): $Component
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Component
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $NBTComponent {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): C
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTComponent$Type<C, B> = ($NBTComponent<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTComponent_<C, B> = $NBTComponent$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/$BytesocksClientImpl" {
import {$BytesocksClient$Socket, $BytesocksClient$Socket$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Socket"
import {$BytesocksClient, $BytesocksClient$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient"
import {$BytesocksClient$Listener, $BytesocksClient$Listener$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient$Listener"

export class $BytesocksClientImpl implements $BytesocksClient {


public "connect"(arg0: string, arg1: $BytesocksClient$Listener$Type): $BytesocksClient$Socket
public "createAndConnect"(arg0: $BytesocksClient$Listener$Type): $BytesocksClient$Socket
public static "create"(arg0: string, arg1: string): $BytesocksClient
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytesocksClientImpl$Type = ($BytesocksClientImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytesocksClientImpl_ = $BytesocksClientImpl$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Command$TabCompleter" {
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"

export interface $Command$TabCompleter {

 "completions"(arg0: $SparkPlatform$Type, arg1: $CommandSender$Type, arg2: $List$Type<(string)>): $List<(string)>

(): $Command$TabCompleter
}

export namespace $Command$TabCompleter {
function empty<S>(): $Command$TabCompleter
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Command$TabCompleter$Type = ($Command$TabCompleter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Command$TabCompleter_ = $Command$TabCompleter$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData" {
import {$SparkWebSocketProtos$ServerUpdateSamplerData$Builder, $SparkWebSocketProtos$ServerUpdateSamplerData$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData$Builder"
import {$SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder, $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkWebSocketProtos$ServerUpdateSamplerData extends $GeneratedMessageLite<($SparkWebSocketProtos$ServerUpdateSamplerData), ($SparkWebSocketProtos$ServerUpdateSamplerData$Builder)> implements $SparkWebSocketProtos$ServerUpdateSamplerDataOrBuilder {
static readonly "PAYLOAD_ID_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ServerUpdateSamplerData)>
public static "newBuilder"(arg0: $SparkWebSocketProtos$ServerUpdateSamplerData$Type): $SparkWebSocketProtos$ServerUpdateSamplerData$Builder
public static "newBuilder"(): $SparkWebSocketProtos$ServerUpdateSamplerData$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "getDefaultInstance"(): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerUpdateSamplerData
public "getPayloadId"(): string
public "getPayloadIdBytes"(): $ByteString
get "defaultInstance"(): $SparkWebSocketProtos$ServerUpdateSamplerData
get "payloadId"(): string
get "payloadIdBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateSamplerData$Type = ($SparkWebSocketProtos$ServerUpdateSamplerData);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateSamplerData_ = $SparkWebSocketProtos$ServerUpdateSamplerData$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectionMonitor" {
import {$GarbageCollectionMonitor$Listener, $GarbageCollectionMonitor$Listener$Type} from "packages/me/lucko/spark/common/monitor/memory/$GarbageCollectionMonitor$Listener"
import {$Notification, $Notification$Type} from "packages/javax/management/$Notification"
import {$NotificationListener, $NotificationListener$Type} from "packages/javax/management/$NotificationListener"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$GarbageCollectionNotificationInfo, $GarbageCollectionNotificationInfo$Type} from "packages/com/sun/management/$GarbageCollectionNotificationInfo"

export class $GarbageCollectionMonitor implements $NotificationListener, $AutoCloseable {

constructor()

public "close"(): void
public static "getGcType"(arg0: $GarbageCollectionNotificationInfo$Type): string
public "removeListener"(arg0: $GarbageCollectionMonitor$Listener$Type): void
public "handleNotification"(arg0: $Notification$Type, arg1: any): void
public "addListener"(arg0: $GarbageCollectionMonitor$Listener$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GarbageCollectionMonitor$Type = ($GarbageCollectionMonitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GarbageCollectionMonitor_ = $GarbageCollectionMonitor$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$FloatList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$FloatList extends $Internal$ProtobufList<(float)> {

 "getFloat"(arg0: integer): float
 "setFloat"(arg0: integer, arg1: float): float
 "addFloat"(arg0: float): void
 "mutableCopyWithCapacity"(arg0: integer): $Internal$FloatList
 "makeImmutable"(): void
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: float): void
 "add"(arg0: float): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): float
 "get"(arg0: integer): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(float)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(float)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(float)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(float)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: float): float
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(float)>
 "listIterator"(): $ListIterator<(float)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(float)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(float)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$FloatList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float): $List<(float)>
function of<E>(arg0: float, arg1: float): $List<(float)>
function of<E>(arg0: float): $List<(float)>
function of<E>(): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): $List<(float)>
function of<E>(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): $List<(float)>
function of<E>(...arg0: (float)[]): $List<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$FloatList$Type = ($Internal$FloatList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$FloatList_ = $Internal$FloatList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$Style" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$StyleGetter, $StyleGetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleGetter"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$StyleSetter, $StyleSetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleSetter"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Style extends $Buildable<($Style), ($Style$Builder)>, $Examinable, $StyleGetter, $StyleSetter<($Style)> {

 "isEmpty"(): boolean
 "merge"(that: $Style$Type, merge: $Style$Merge$Type): $Style
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, merge: $Style$Merge$Type): $Style
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type): $Style
 "merge"(that: $Style$Type): $Style
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style
 "merge"(that: $Style$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style
 "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, ...merges: ($Style$Merge$Type)[]): $Style
 "merge"(that: $Style$Type, ...merges: ($Style$Merge$Type)[]): $Style
 "color"(color: $TextColor$Type): $Style
 "color"(): $TextColor
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Style
 "unmerge"(that: $Style$Type): $Style
 "edit"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Style
 "edit"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Style
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Style
 "decorate"(decoration: $TextDecoration$Type): $Style
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "toBuilder"(): $Style$Builder
 "insertion"(insertion: string): $Style
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "clickEvent"(event: $ClickEvent$Type): $Style
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Style
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Style
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Style
}

export namespace $Style {
const DEFAULT_FONT: $Key
function empty(): $Style
function style(color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $Style
function style(...applicables: ($StyleBuilderApplicable$Type)[]): $Style
function style(applicables: $Iterable$Type<(any)>): $Style
function style(color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $Style
function style(): $Style$Builder
function style(consumer: $Consumer$Type<($Style$Builder$Type)>): $Style
function style(color: $TextColor$Type): $Style
function style(decoration: $TextDecoration$Type): $Style
function configureAndBuild<R, B>(builder: $Style$Builder$Type, consumer: $Consumer$Type<(any)>): $Style
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Style$Type = ($Style);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Style_ = $Style$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$GcOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$GcOrBuilder extends $MessageLiteOrBuilder {

 "getTotal"(): long
 "getAvgFrequency"(): double
 "getAvgTime"(): double
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$GcOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$GcOrBuilder$Type = ($SparkProtos$PlatformStatistics$GcOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$GcOrBuilder_ = $SparkProtos$PlatformStatistics$GcOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/permission/$PermissionCheckers" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PermissionCheckers {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PermissionCheckers$Type = ($PermissionCheckers);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PermissionCheckers_ = $PermissionCheckers$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$PaginationImpl" {
import {$Pagination, $Pagination$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Pagination$Builder, $Pagination$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/feature/pagination/$Pagination$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $PaginationImpl<T> implements $Examinable, $Pagination<(T)> {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "examinableProperties"(): $Stream<(any)>
public "render"(content: $Collection$Type<(any)>, page: integer): $List<($Component)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public static "builder"(): $Pagination$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PaginationImpl$Type<T> = ($PaginationImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PaginationImpl_<T> = $PaginationImpl$Type<(T)>;
}}
declare module "packages/me/lucko/spark/common/command/modules/$TickMonitoringModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"

export class $TickMonitoringModule implements $CommandModule {

constructor()

public "close"(): void
public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickMonitoringModule$Type = ($TickMonitoringModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickMonitoringModule_ = $TickMonitoringModule$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/net/$NetworkInterfaceInfo" {
import {$Direction, $Direction$Type} from "packages/me/lucko/spark/common/monitor/net/$Direction"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $NetworkInterfaceInfo {
static readonly "ZERO": $NetworkInterfaceInfo

constructor(arg0: string, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long)

public "getName"(): string
public "getBytes"(arg0: $Direction$Type): long
public "subtract"(arg0: $NetworkInterfaceInfo$Type): $NetworkInterfaceInfo
public "isZero"(): boolean
public static "difference"(arg0: $Map$Type<(string), ($NetworkInterfaceInfo$Type)>, arg1: $Map$Type<(string), ($NetworkInterfaceInfo$Type)>): $Map<(string), ($NetworkInterfaceInfo)>
public "getReceiveErrors"(): long
public "getTransmitErrors"(): long
public "getReceivedPackets"(): long
public "getPackets"(arg0: $Direction$Type): long
public "getReceivedBytes"(): long
public "getTransmittedBytes"(): long
public "getTransmittedPackets"(): long
public static "pollSystem"(): $Map<(string), ($NetworkInterfaceInfo)>
get "name"(): string
get "zero"(): boolean
get "receiveErrors"(): long
get "transmitErrors"(): long
get "receivedPackets"(): long
get "receivedBytes"(): long
get "transmittedBytes"(): long
get "transmittedPackets"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkInterfaceInfo$Type = ($NetworkInterfaceInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkInterfaceInfo_ = $NetworkInterfaceInfo$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/net/$Direction" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Direction extends $Enum<($Direction)> {
static readonly "RECEIVE": $Direction
static readonly "TRANSMIT": $Direction


public static "values"(): ($Direction)[]
public static "valueOf"(arg0: string): $Direction
public "abbrev"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Direction$Type = (("receive") | ("transmit")) | ($Direction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Direction_ = $Direction$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CanIgnoreReturnValue" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $CanIgnoreReturnValue extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $CanIgnoreReturnValue {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CanIgnoreReturnValue$Type = ($CanIgnoreReturnValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CanIgnoreReturnValue_ = $CanIgnoreReturnValue$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer$Builder" {
import {$GsonComponentSerializer, $GsonComponentSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$GsonComponentSerializer"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$LegacyHoverEventSerializer, $LegacyHoverEventSerializer$Type} from "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$LegacyHoverEventSerializer"

export interface $GsonComponentSerializer$Builder extends $AbstractBuilder<($GsonComponentSerializer)>, $Buildable$Builder<($GsonComponentSerializer)> {

 "downsampleColors"(): $GsonComponentSerializer$Builder
 "build"(): $GsonComponentSerializer
 "emitLegacyHoverEvent"(): $GsonComponentSerializer$Builder
 "legacyHoverEventSerializer"(serializer: $LegacyHoverEventSerializer$Type): $GsonComponentSerializer$Builder
}

export namespace $GsonComponentSerializer$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $GsonComponentSerializer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GsonComponentSerializer$Builder$Type = ($GsonComponentSerializer$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GsonComponentSerializer$Builder_ = $GsonComponentSerializer$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Method" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$MethodOrBuilder, $MethodOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MethodOrBuilder"
import {$Method$Builder, $Method$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Method$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $Method extends $GeneratedMessageLite<($Method), ($Method$Builder)> implements $MethodOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "REQUEST_TYPE_URL_FIELD_NUMBER": integer
static readonly "REQUEST_STREAMING_FIELD_NUMBER": integer
static readonly "RESPONSE_TYPE_URL_FIELD_NUMBER": integer
static readonly "RESPONSE_STREAMING_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer
static readonly "SYNTAX_FIELD_NUMBER": integer


public "getName"(): string
public static "parser"(): $Parser<($Method)>
public static "newBuilder"(arg0: $Method$Type): $Method$Builder
public static "newBuilder"(): $Method$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Method
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Method
public "getSyntax"(): $Syntax
public static "getDefaultInstance"(): $Method
public "getOptions"(arg0: integer): $Option
public "getResponseTypeUrl"(): string
public "getRequestTypeUrl"(): string
public "getNameBytes"(): $ByteString
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getSyntaxValue"(): integer
public "getResponseStreaming"(): boolean
public "getRequestTypeUrlBytes"(): $ByteString
public "getResponseTypeUrlBytes"(): $ByteString
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public "getRequestStreaming"(): boolean
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Method
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Method
public static "parseFrom"(arg0: (byte)[]): $Method
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Method
public static "parseFrom"(arg0: $ByteString$Type): $Method
public static "parseFrom"(arg0: $ByteBuffer$Type): $Method
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Method
public static "parseFrom"(arg0: $CodedInputStream$Type): $Method
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Method
public static "parseFrom"(arg0: $InputStream$Type): $Method
get "name"(): string
get "syntax"(): $Syntax
get "defaultInstance"(): $Method
get "responseTypeUrl"(): string
get "requestTypeUrl"(): string
get "nameBytes"(): $ByteString
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "syntaxValue"(): integer
get "responseStreaming"(): boolean
get "requestTypeUrlBytes"(): $ByteString
get "responseTypeUrlBytes"(): $ByteString
get "optionsOrBuilderList"(): $List<(any)>
get "requestStreaming"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Method$Type = ($Method);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Method_ = $Method$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageInfo" {
import {$ProtoSyntax, $ProtoSyntax$Type} from "packages/me/lucko/spark/lib/protobuf/$ProtoSyntax"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $MessageInfo {

 "isMessageSetWireFormat"(): boolean
 "getSyntax"(): $ProtoSyntax
 "getDefaultInstance"(): $MessageLite
}

export namespace $MessageInfo {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageInfo$Type = ($MessageInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageInfo_ = $MessageInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Book, $Book$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $Book$Builder extends $AbstractBuilder<($Book)>, $Buildable$Builder<($Book)> {

 "title"(title: $Component$Type): $Book$Builder
 "pages"(...pages: ($Component$Type)[]): $Book$Builder
 "pages"(pages: $Collection$Type<($Component$Type)>): $Book$Builder
 "addPage"(page: $Component$Type): $Book$Builder
 "author"(author: $Component$Type): $Book$Builder
}

export namespace $Book$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $Book
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Book$Builder$Type = ($Book$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Book$Builder_ = $Book$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl" {
import {$Opcode, $Opcode$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$Opcode"
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$SSLSession, $SSLSession$Type} from "packages/javax/net/ssl/$SSLSession"
import {$WebSocketServer$WebSocketWorker, $WebSocketServer$WebSocketWorker$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/server/$WebSocketServer$WebSocketWorker"
import {$InvalidDataException, $InvalidDataException$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidDataException"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$WebSocketListener, $WebSocketListener$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketListener"
import {$SelectionKey, $SelectionKey$Type} from "packages/java/nio/channels/$SelectionKey"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ReadyState, $ReadyState$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/enums/$ReadyState"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$ClientHandshakeBuilder, $ClientHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshakeBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$BlockingQueue, $BlockingQueue$Type} from "packages/java/util/concurrent/$BlockingQueue"
import {$IProtocol, $IProtocol$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/protocols/$IProtocol"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketImpl implements $WebSocket {
static readonly "DEFAULT_PORT": integer
static readonly "DEFAULT_WSS_PORT": integer
static readonly "RCVBUF": integer
readonly "outQueue": $BlockingQueue<($ByteBuffer)>
readonly "inQueue": $BlockingQueue<($ByteBuffer)>

constructor(arg0: $WebSocketListener$Type, arg1: $List$Type<($Draft$Type)>)
constructor(arg0: $WebSocketListener$Type, arg1: $Draft$Type)

public "getWebSocketListener"(): $WebSocketListener
public "toString"(): string
public "decode"(arg0: $ByteBuffer$Type): void
public "isOpen"(): boolean
public "close"(arg0: $InvalidDataException$Type): void
public "close"(arg0: integer): void
public "close"(): void
public "close"(arg0: integer, arg1: string): void
public "close"(arg0: integer, arg1: string, arg2: boolean): void
public "getProtocol"(): $IProtocol
public "getChannel"(): $ByteChannel
public "isClosed"(): boolean
public "getSSLSession"(): $SSLSession
public "getRemoteSocketAddress"(): $InetSocketAddress
public "getLocalSocketAddress"(): $InetSocketAddress
public "startHandshake"(arg0: $ClientHandshakeBuilder$Type): void
public "isClosing"(): boolean
public "flushAndClose"(arg0: integer, arg1: string, arg2: boolean): void
public "setChannel"(arg0: $ByteChannel$Type): void
public "send"(arg0: $ByteBuffer$Type): void
public "send"(arg0: string): void
public "send"(arg0: (byte)[]): void
public "setAttachment"<T>(arg0: T): void
public "closeConnection"(arg0: integer, arg1: string, arg2: boolean): void
public "closeConnection"(arg0: integer, arg1: string): void
public "closeConnection"(): void
public "sendFrame"(arg0: $Collection$Type<($Framedata$Type)>): void
public "sendFrame"(arg0: $Framedata$Type): void
public "sendFragmentedFrame"(arg0: $Opcode$Type, arg1: $ByteBuffer$Type, arg2: boolean): void
public "getResourceDescriptor"(): string
public "getAttachment"<T>(): T
public "sendPing"(): void
public "updateLastPong"(): void
public "getDraft"(): $Draft
public "eot"(): void
public "getReadyState"(): $ReadyState
public "hasSSLSupport"(): boolean
public "hasBufferedData"(): boolean
public "isFlushAndClose"(): boolean
public "setWorkerThread"(arg0: $WebSocketServer$WebSocketWorker$Type): void
public "setSelectionKey"(arg0: $SelectionKey$Type): void
public "getWorkerThread"(): $WebSocketServer$WebSocketWorker
public "getSelectionKey"(): $SelectionKey
get "webSocketListener"(): $WebSocketListener
get "open"(): boolean
get "protocol"(): $IProtocol
get "channel"(): $ByteChannel
get "closed"(): boolean
get "sSLSession"(): $SSLSession
get "remoteSocketAddress"(): $InetSocketAddress
get "localSocketAddress"(): $InetSocketAddress
get "closing"(): boolean
set "channel"(value: $ByteChannel$Type)
set "attachment"(value: T)
get "resourceDescriptor"(): string
get "attachment"(): T
get "draft"(): $Draft
get "readyState"(): $ReadyState
set "workerThread"(value: $WebSocketServer$WebSocketWorker$Type)
set "selectionKey"(value: $SelectionKey$Type)
get "workerThread"(): $WebSocketServer$WebSocketWorker
get "selectionKey"(): $SelectionKey
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketImpl$Type = ($WebSocketImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketImpl_ = $WebSocketImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment" {
import {$File, $File$Type} from "packages/java/io/$File"
import {$List, $List$Type} from "packages/java/util/$List"

export class $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment {

constructor(arg0: string, arg1: $List$Type<($File$Type)>)

public "getClassPath"(): $List<($File)>
public "getVirtualMachineType"(): string
get "classPath"(): $List<($File)>
get "virtualMachineType"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment$Type = ($ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment_ = $ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CodedInputStream" {
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"

export class $CodedInputStream {


public "readStringRequireUtf8"(): string
public "checkRecursionLimit"(): void
public "readRawLittleEndian32"(): integer
public "readRawLittleEndian64"(): long
public static "newInstance"(arg0: $InputStream$Type): $CodedInputStream
public static "newInstance"(arg0: (byte)[], arg1: integer, arg2: integer): $CodedInputStream
public static "newInstance"(arg0: $Iterable$Type<($ByteBuffer$Type)>): $CodedInputStream
public static "newInstance"(arg0: (byte)[]): $CodedInputStream
public static "newInstance"(arg0: $InputStream$Type, arg1: integer): $CodedInputStream
public static "newInstance"(arg0: $ByteBuffer$Type): $CodedInputStream
public "readBytes"(): $ByteString
public "readFloat"(): float
public "readDouble"(): double
public "readString"(): string
public "readRawVarint32"(): integer
public static "readRawVarint32"(arg0: integer, arg1: $InputStream$Type): integer
public "checkLastTagWas"(arg0: integer): void
/**
 * 
 * @deprecated
 */
public "skipField"(arg0: integer, arg1: $CodedOutputStream$Type): boolean
public "skipField"(arg0: integer): boolean
public "readUInt64"(): long
public "readInt64"(): long
public "readGroup"(arg0: integer, arg1: $MessageLite$Builder$Type, arg2: $ExtensionRegistryLite$Type): void
public "readGroup"<T extends $MessageLite>(arg0: integer, arg1: $Parser$Type<(T)>, arg2: $ExtensionRegistryLite$Type): T
public "readSFixed64"(): long
public "readMessage"<T extends $MessageLite>(arg0: $Parser$Type<(T)>, arg1: $ExtensionRegistryLite$Type): T
public "readMessage"(arg0: $MessageLite$Builder$Type, arg1: $ExtensionRegistryLite$Type): void
public "readBool"(): boolean
public "readFixed32"(): integer
public "readUInt32"(): integer
public "readSInt64"(): long
public "readFixed64"(): long
public "readSFixed32"(): integer
public "readSInt32"(): integer
public "readInt32"(): integer
public "getBytesUntilLimit"(): integer
/**
 * 
 * @deprecated
 */
public "readUnknownGroup"(arg0: integer, arg1: $MessageLite$Builder$Type): void
public "resetSizeCounter"(): void
public "getTotalBytesRead"(): integer
public "readRawBytes"(arg0: integer): (byte)[]
public "popLimit"(arg0: integer): void
public "isAtEnd"(): boolean
public "skipMessage"(): void
public "skipMessage"(arg0: $CodedOutputStream$Type): void
public "setRecursionLimit"(arg0: integer): integer
public "skipRawBytes"(arg0: integer): void
public static "decodeZigZag32"(arg0: integer): integer
public "readRawByte"(): byte
public "getLastTag"(): integer
public "enableAliasing"(arg0: boolean): void
public "setSizeLimit"(arg0: integer): integer
public "readByteArray"(): (byte)[]
public "readByteBuffer"(): $ByteBuffer
public "readRawVarint64"(): long
public static "decodeZigZag64"(arg0: long): long
public "readTag"(): integer
public "readEnum"(): integer
public "pushLimit"(arg0: integer): integer
get "bytesUntilLimit"(): integer
get "totalBytesRead"(): integer
get "atEnd"(): boolean
set "recursionLimit"(value: integer)
get "lastTag"(): integer
set "sizeLimit"(value: integer)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CodedInputStream$Type = ($CodedInputStream);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CodedInputStream_ = $CodedInputStream$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/nbt/api/$BinaryTagHolder" {
import {$Codec, $Codec$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export interface $BinaryTagHolder {

 "get"<T, DX extends $Exception>(codec: $Codec$Type<(T), (string), (DX), (any)>): T
 "string"(): string
}

export namespace $BinaryTagHolder {
function encode<T, EX>(nbt: T, codec: $Codec$Type<(any), (string), (any), (EX)>): $BinaryTagHolder
function of(string: string): $BinaryTagHolder
function binaryTagHolder(string: string): $BinaryTagHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryTagHolder$Type = ($BinaryTagHolder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryTagHolder_ = $BinaryTagHolder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType" {
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$Deque, $Deque$Type} from "packages/java/util/$Deque"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentIteratorType {

 "populate"(component: $Component$Type, deque: $Deque$Type<($Component$Type)>, flags: $Set$Type<($ComponentIteratorFlag$Type)>): void

(component: $Component$Type, deque: $Deque$Type<($Component$Type)>, flags: $Set$Type<($ComponentIteratorFlag$Type)>): void
}

export namespace $ComponentIteratorType {
const DEPTH_FIRST: $ComponentIteratorType
const BREADTH_FIRST: $ComponentIteratorType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentIteratorType$Type = ($ComponentIteratorType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentIteratorType_ = $ComponentIteratorType$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Memory$Builder, $SparkProtos$SystemStatistics$Memory$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$Builder"
import {$SparkProtos$SystemStatistics$MemoryOrBuilder, $SparkProtos$SystemStatistics$MemoryOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$MemoryOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$SystemStatistics$Memory$MemoryPool, $SparkProtos$SystemStatistics$Memory$MemoryPool$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Memory$MemoryPool"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Memory extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Memory), ($SparkProtos$SystemStatistics$Memory$Builder)> implements $SparkProtos$SystemStatistics$MemoryOrBuilder {
static readonly "PHYSICAL_FIELD_NUMBER": integer
static readonly "SWAP_FIELD_NUMBER": integer


public "getSwap"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
public "hasPhysical"(): boolean
public "getPhysical"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
public "hasSwap"(): boolean
public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Memory)>
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Memory$Type): $SparkProtos$SystemStatistics$Memory$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$Memory$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Memory
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Memory
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Memory
get "swap"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
get "physical"(): $SparkProtos$SystemStatistics$Memory$MemoryPool
get "defaultInstance"(): $SparkProtos$SystemStatistics$Memory
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Memory$Type = ($SparkProtos$SystemStatistics$Memory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Memory_ = $SparkProtos$SystemStatistics$Memory$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$WrappersProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $WrappersProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappersProto$Type = ($WrappersProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappersProto_ = $WrappersProto$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$KeyedValue" {
import {$Keyed, $Keyed$Type} from "packages/me/lucko/spark/lib/adventure/key/$Keyed"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"

export interface $KeyedValue<T> extends $Keyed {

 "value"(): T
 "key"(): $Key
}

export namespace $KeyedValue {
function of<T>(key: $Key$Type, value: T): $KeyedValue<(T)>
function keyedValue<T>(key: $Key$Type, value: T): $KeyedValue<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyedValue$Type<T> = ($KeyedValue<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyedValue_<T> = $KeyedValue$Type<(T)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo" {
import {$SparkSamplerProtos$SocketChannelInfoOrBuilder, $SparkSamplerProtos$SocketChannelInfoOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfoOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$SocketChannelInfo$Builder, $SparkSamplerProtos$SocketChannelInfo$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo$Builder"

export class $SparkSamplerProtos$SocketChannelInfo extends $GeneratedMessageLite<($SparkSamplerProtos$SocketChannelInfo), ($SparkSamplerProtos$SocketChannelInfo$Builder)> implements $SparkSamplerProtos$SocketChannelInfoOrBuilder {
static readonly "CHANNEL_ID_FIELD_NUMBER": integer
static readonly "PUBLIC_KEY_FIELD_NUMBER": integer


public "getPublicKey"(): $ByteString
public static "parser"(): $Parser<($SparkSamplerProtos$SocketChannelInfo)>
public static "newBuilder"(): $SparkSamplerProtos$SocketChannelInfo$Builder
public static "newBuilder"(arg0: $SparkSamplerProtos$SocketChannelInfo$Type): $SparkSamplerProtos$SocketChannelInfo$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SocketChannelInfo
public static "getDefaultInstance"(): $SparkSamplerProtos$SocketChannelInfo
public "getChannelId"(): string
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SocketChannelInfo
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SocketChannelInfo
public "getChannelIdBytes"(): $ByteString
get "publicKey"(): $ByteString
get "defaultInstance"(): $SparkSamplerProtos$SocketChannelInfo
get "channelId"(): string
get "channelIdBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SocketChannelInfo$Type = ($SparkSamplerProtos$SocketChannelInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SocketChannelInfo_ = $SparkSamplerProtos$SocketChannelInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$JoinConfiguration$Builder, $JoinConfiguration$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $JoinConfiguration extends $Buildable<($JoinConfiguration), ($JoinConfiguration$Builder)>, $Examinable {

 "prefix"(): $Component
 "suffix"(): $Component
 "separator"(): $Component
 "predicate"(): $Predicate<($ComponentLike)>
 "lastSeparatorIfSerial"(): $Component
 "lastSeparator"(): $Component
 "parentStyle"(): $Style
 "convertor"(): $Function<($ComponentLike), ($Component)>
 "toBuilder"(): $JoinConfiguration$Builder
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "examinableProperties"(): $Stream<(any)>
}

export namespace $JoinConfiguration {
function builder(): $JoinConfiguration$Builder
function separator(separator: $ComponentLike$Type): $JoinConfiguration
function newlines(): $JoinConfiguration
function separators(separator: $ComponentLike$Type, lastSeparator: $ComponentLike$Type): $JoinConfiguration
function arrayLike(): $JoinConfiguration
function commas(spaces: boolean): $JoinConfiguration
function noSeparators(): $JoinConfiguration
function configureAndBuild<R, B>(builder: $JoinConfiguration$Builder$Type, consumer: $Consumer$Type<(any)>): $JoinConfiguration
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JoinConfiguration$Type = ($JoinConfiguration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JoinConfiguration_ = $JoinConfiguration$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldMaskProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $FieldMaskProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldMaskProto$Type = ($FieldMaskProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldMaskProto_ = $FieldMaskProto$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder, $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper, $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Type"

export class $SparkSamplerProtos$SamplerMetadata$DataAggregator extends $GeneratedMessageLite<($SparkSamplerProtos$SamplerMetadata$DataAggregator), ($SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder)> implements $SparkSamplerProtos$SamplerMetadata$DataAggregatorOrBuilder {
static readonly "TYPE_FIELD_NUMBER": integer
static readonly "THREAD_GROUPER_FIELD_NUMBER": integer
static readonly "TICK_LENGTH_THRESHOLD_FIELD_NUMBER": integer
static readonly "NUMBER_OF_INCLUDED_TICKS_FIELD_NUMBER": integer


public "getType"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
public static "parser"(): $Parser<($SparkSamplerProtos$SamplerMetadata$DataAggregator)>
public static "newBuilder"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public static "newBuilder"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "getDefaultInstance"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public "getTypeValue"(): integer
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $InputStream$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: (byte)[]): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public "getThreadGrouperValue"(): integer
public "getTickLengthThreshold"(): long
public "getNumberOfIncludedTicks"(): integer
public "getThreadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
get "type"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type
get "defaultInstance"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "typeValue"(): integer
get "threadGrouperValue"(): integer
get "tickLengthThreshold"(): long
get "numberOfIncludedTicks"(): integer
get "threadGrouper"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator$ThreadGrouper
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type = ($SparkSamplerProtos$SamplerMetadata$DataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$DataAggregator_ = $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldSet" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$FieldSet$FieldDescriptorLite, $FieldSet$FieldDescriptorLite$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet$FieldDescriptorLite"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$FieldSet$Builder, $FieldSet$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $FieldSet<T extends $FieldSet$FieldDescriptorLite<(T)>> {


public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "clone"(): $FieldSet<(T)>
public "clear"(): void
public "iterator"(): $Iterator<($Map$Entry<(T), (any)>)>
public "getField"(arg0: T): any
public static "emptySet"<T extends $FieldSet$FieldDescriptorLite<(T)>>(): $FieldSet<(T)>
public "writeTo"(arg0: $CodedOutputStream$Type): void
public "makeImmutable"(): void
public static "newBuilder"<T extends $FieldSet$FieldDescriptorLite<(T)>>(): $FieldSet$Builder<(T)>
public "getSerializedSize"(): integer
public "isImmutable"(): boolean
public "hasField"(arg0: T): boolean
public "setField"(arg0: T, arg1: any): void
public "getAllFields"(): $Map<(T), (any)>
public "isInitialized"(): boolean
public "mergeFrom"(arg0: $FieldSet$Type<(T)>): void
public static "readPrimitiveField"(arg0: $CodedInputStream$Type, arg1: $WireFormat$FieldType$Type, arg2: boolean): any
public static "writeField"(arg0: $FieldSet$FieldDescriptorLite$Type<(any)>, arg1: any, arg2: $CodedOutputStream$Type): void
public static "newFieldSet"<T extends $FieldSet$FieldDescriptorLite<(T)>>(): $FieldSet<(T)>
public "getRepeatedField"(arg0: T, arg1: integer): any
public "setRepeatedField"(arg0: T, arg1: integer, arg2: any): void
public "clearField"(arg0: T): void
public "addRepeatedField"(arg0: T, arg1: any): void
public static "computeFieldSize"(arg0: $FieldSet$FieldDescriptorLite$Type<(any)>, arg1: any): integer
public "writeMessageSetTo"(arg0: $CodedOutputStream$Type): void
public "getRepeatedFieldCount"(arg0: T): integer
public "getMessageSetSerializedSize"(): integer
get "serializedSize"(): integer
get "immutable"(): boolean
get "allFields"(): $Map<(T), (any)>
get "initialized"(): boolean
get "messageSetSerializedSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldSet$Type<T> = ($FieldSet<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldSet_<T> = $FieldSet$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidFrameException" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$InvalidDataException, $InvalidDataException$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$InvalidDataException"

export class $InvalidFrameException extends $InvalidDataException {

constructor(arg0: string, arg1: $Throwable$Type)
constructor(arg0: $Throwable$Type)
constructor(arg0: string)
constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $InvalidFrameException$Type = ($InvalidFrameException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $InvalidFrameException_ = $InvalidFrameException$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$JfrReader$Element" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $JfrReader$Element {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $JfrReader$Element$Type = ($JfrReader$Element);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $JfrReader$Element_ = $JfrReader$Element$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ApiProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $ApiProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ApiProto$Type = ($ApiProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ApiProto_ = $ApiProto$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/memory/$MemoryInfo" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $MemoryInfo extends $Enum<($MemoryInfo)> {


public static "getAvailablePhysicalMemory"(): long
public static "getTotalVirtualMemory"(): long
public static "values"(): ($MemoryInfo)[]
public static "valueOf"(arg0: string): $MemoryInfo
public static "getUsedPhysicalMemory"(): long
public static "getTotalPhysicalMemory"(): long
public static "getTotalSwap"(): long
public static "getUsedSwap"(): long
get "availablePhysicalMemory"(): long
get "totalVirtualMemory"(): long
get "usedPhysicalMemory"(): long
get "totalPhysicalMemory"(): long
get "totalSwap"(): long
get "usedSwap"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MemoryInfo$Type = (never) | ($MemoryInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MemoryInfo_ = $MemoryInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Value$Builder" {
import {$Struct, $Struct$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct"
import {$Struct$Builder, $Struct$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ListValue$Builder, $ListValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue$Builder"
import {$ListValue, $ListValue$Type} from "packages/me/lucko/spark/lib/protobuf/$ListValue"
import {$ValueOrBuilder, $ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$ValueOrBuilder"
import {$NullValue, $NullValue$Type} from "packages/me/lucko/spark/lib/protobuf/$NullValue"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$Value$KindCase, $Value$KindCase$Type} from "packages/me/lucko/spark/lib/protobuf/$Value$KindCase"

export class $Value$Builder extends $GeneratedMessageLite$Builder<($Value), ($Value$Builder)> implements $ValueOrBuilder {


public "clearListValue"(): $Value$Builder
public "setNullValueValue"(arg0: integer): $Value$Builder
public "clearStringValue"(): $Value$Builder
public "setBoolValue"(arg0: boolean): $Value$Builder
public "setNumberValue"(arg0: double): $Value$Builder
public "clearStructValue"(): $Value$Builder
public "clearNumberValue"(): $Value$Builder
public "setNullValue"(arg0: $NullValue$Type): $Value$Builder
public "clearKind"(): $Value$Builder
public "clearBoolValue"(): $Value$Builder
public "setStructValue"(arg0: $Struct$Builder$Type): $Value$Builder
public "setStructValue"(arg0: $Struct$Type): $Value$Builder
public "mergeListValue"(arg0: $ListValue$Type): $Value$Builder
public "setListValue"(arg0: $ListValue$Type): $Value$Builder
public "setListValue"(arg0: $ListValue$Builder$Type): $Value$Builder
public "clearNullValue"(): $Value$Builder
public "mergeStructValue"(arg0: $Struct$Type): $Value$Builder
public "getStringValueBytes"(): $ByteString
public "hasStringValue"(): boolean
public "getStringValue"(): string
public "setStringValue"(arg0: string): $Value$Builder
public "getNumberValue"(): double
public "hasStructValue"(): boolean
public "getNullValueValue"(): integer
public "hasNumberValue"(): boolean
public "getKindCase"(): $Value$KindCase
public "getStructValue"(): $Struct
public "hasBoolValue"(): boolean
public "hasListValue"(): boolean
public "getBoolValue"(): boolean
public "getNullValue"(): $NullValue
public "getListValue"(): $ListValue
public "hasNullValue"(): boolean
public "setStringValueBytes"(arg0: $ByteString$Type): $Value$Builder
set "nullValueValue"(value: integer)
set "boolValue"(value: boolean)
set "numberValue"(value: double)
set "nullValue"(value: $NullValue$Type)
set "structValue"(value: $Struct$Builder$Type)
set "structValue"(value: $Struct$Type)
set "listValue"(value: $ListValue$Type)
set "listValue"(value: $ListValue$Builder$Type)
get "stringValueBytes"(): $ByteString
get "stringValue"(): string
set "stringValue"(value: string)
get "numberValue"(): double
get "nullValueValue"(): integer
get "kindCase"(): $Value$KindCase
get "structValue"(): $Struct
get "boolValue"(): boolean
get "nullValue"(): $NullValue
get "listValue"(): $ListValue
set "stringValueBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Value$Builder$Type = ($Value$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Value$Builder_ = $Value$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$KeyImpl" {
import {$Namespaced, $Namespaced$Type} from "packages/me/lucko/spark/lib/adventure/key/$Namespaced"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export class $KeyImpl implements $Key {


public "value"(): string
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(that: $Key$Type): integer
public "examinableProperties"(): $Stream<(any)>
public "namespace"(): string
public "asString"(): string
public "key"(): $Key
public static "key"(string: string): $Key
public static "key"(namespaced: $Namespaced$Type, value: string): $Key
public static "key"(string: string, character: character): $Key
public static "key"(namespace: string, value: string): $Key
public static "comparator"(): $Comparator<(any)>
public static "parseableValue"(value: string): boolean
public static "parseable"(string: string): boolean
public static "allowedInNamespace"(character: character): boolean
public static "allowedInValue"(character: character): boolean
public static "parseableNamespace"(namespace: string): boolean
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyImpl$Type = ($KeyImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyImpl_ = $KeyImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/signature/$SignatureVisitor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $SignatureVisitor {
static readonly "EXTENDS": character
static readonly "SUPER": character
static readonly "INSTANCEOF": character

constructor(arg0: integer)

public "visitEnd"(): void
public "visitInterface"(): $SignatureVisitor
public "visitParameterType"(): $SignatureVisitor
public "visitExceptionType"(): $SignatureVisitor
public "visitClassBound"(): $SignatureVisitor
public "visitBaseType"(arg0: character): void
public "visitSuperclass"(): $SignatureVisitor
public "visitTypeVariable"(arg0: string): void
public "visitArrayType"(): $SignatureVisitor
public "visitTypeArgument"(arg0: character): $SignatureVisitor
public "visitTypeArgument"(): void
public "visitReturnType"(): $SignatureVisitor
public "visitClassType"(arg0: string): void
public "visitInnerClassType"(arg0: string): void
public "visitInterfaceBound"(): $SignatureVisitor
public "visitFormalTypeParameter"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignatureVisitor$Type = ($SignatureVisitor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignatureVisitor_ = $SignatureVisitor$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export interface $KeybindComponent$Builder extends $ComponentBuilder<($KeybindComponent), ($KeybindComponent$Builder)> {

 "keybind"(keybind: string): $KeybindComponent$Builder
 "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $KeybindComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $KeybindComponent$Builder
 "append"(...components: ($Component$Type)[]): $KeybindComponent$Builder
 "append"(component: $Component$Type): $KeybindComponent$Builder
 "append"(component: $ComponentLike$Type): $KeybindComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $KeybindComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $KeybindComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $KeybindComponent$Builder
 "style"(style: $Style$Type): $KeybindComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $KeybindComponent$Builder
 "mergeStyle"(that: $Component$Type): $KeybindComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $KeybindComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $KeybindComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $KeybindComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $KeybindComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $KeybindComponent$Builder
 "resetStyle"(): $KeybindComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $KeybindComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $KeybindComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $KeybindComponent$Builder
 "font"(font: $Key$Type): $KeybindComponent$Builder
 "appendSpace"(): $KeybindComponent$Builder
 "insertion"(insertion: string): $KeybindComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $KeybindComponent$Builder
}

export namespace $KeybindComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $KeybindComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeybindComponent$Builder$Type = ($KeybindComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeybindComponent$Builder_ = $KeybindComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$Dictionary$Visitor" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Dictionary$Visitor<T> {

 "visit"(arg0: long, arg1: T): void

(arg0: long, arg1: T): void
}

export namespace $Dictionary$Visitor {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Dictionary$Visitor$Type<T> = ($Dictionary$Visitor<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Dictionary$Visitor_<T> = $Dictionary$Visitor$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Buildable" {
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"

export interface $Buildable<R, B extends $Buildable$Builder<(R)>> {

 "toBuilder"(): B

(builder: B, consumer: $Consumer$Type<(any)>): R
}

export namespace $Buildable {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Buildable$Type<R, B> = ($Buildable<(R), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Buildable_<R, B> = $Buildable$Type<(R), (B)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$Handle" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Handle {

/**
 * 
 * @deprecated
 */
constructor(arg0: integer, arg1: string, arg2: string, arg3: string)
constructor(arg0: integer, arg1: string, arg2: string, arg3: string, arg4: boolean)

public "getName"(): string
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isInterface"(): boolean
public "getOwner"(): string
public "getTag"(): integer
public "getDesc"(): string
get "name"(): string
get "interface"(): boolean
get "owner"(): string
get "tag"(): integer
get "desc"(): string
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Handle$Type = ($Handle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Handle_ = $Handle$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$Builder" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$SparkSamplerProtos$SamplerMetadataOrBuilder, $SparkSamplerProtos$SamplerMetadataOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadataOrBuilder"
import {$SparkProtos$CommandSenderMetadata, $SparkProtos$CommandSenderMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics$Builder, $SparkProtos$SystemStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Builder"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkProtos$CommandSenderMetadata$Builder, $SparkProtos$CommandSenderMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$CommandSenderMetadata$Builder"
import {$SparkSamplerProtos$SamplerMetadata$SamplerMode, $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SamplerMode"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkProtos$PlatformMetadata$Builder, $SparkProtos$PlatformMetadata$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata$Builder"
import {$SparkSamplerProtos$SamplerMetadata$ThreadDumper, $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$ThreadDumper"
import {$SparkSamplerProtos$SamplerMetadata, $SparkSamplerProtos$SamplerMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$PlatformMetadata, $SparkProtos$PlatformMetadata$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformMetadata"
import {$SparkProtos$PlatformStatistics$Builder, $SparkProtos$PlatformStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Builder"
import {$SparkSamplerProtos$SamplerMetadata$SourceMetadata, $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$SourceMetadata"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $SparkSamplerProtos$SamplerMetadata$Builder extends $GeneratedMessageLite$Builder<($SparkSamplerProtos$SamplerMetadata), ($SparkSamplerProtos$SamplerMetadata$Builder)> implements $SparkSamplerProtos$SamplerMetadataOrBuilder {


public "setPlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setPlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setPlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setPlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "putAllServerConfigurations"(arg0: $Map$Type<(string), (string)>): $SparkSamplerProtos$SamplerMetadata$Builder
public "putAllExtraPlatformMetadata"(arg0: $Map$Type<(string), (string)>): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearSamplerMode"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "getSourcesOrThrow"(arg0: string): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public "containsSources"(arg0: string): boolean
public "getSourcesCount"(): integer
public "getSamplerMode"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
public "getSourcesMap"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
public "setComment"(arg0: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "getComment"(): string
public "clearNumberOfTicks"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "setCreator"(arg0: $SparkProtos$CommandSenderMetadata$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setCreator"(arg0: $SparkProtos$CommandSenderMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setDataAggregator"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setDataAggregator"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setSamplerMode"(arg0: $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setThreadDumper"(arg0: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setThreadDumper"(arg0: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "setNumberOfTicks"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$Builder
public "putSources"(arg0: string, arg1: $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearEndTime"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearStartTime"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "setEndTime"(arg0: long): $SparkSamplerProtos$SamplerMetadata$Builder
public "getStartTime"(): long
public "getInterval"(): integer
public "getCreator"(): $SparkProtos$CommandSenderMetadata
public "getEndTime"(): long
public "clearComment"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "setInterval"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearInterval"(): $SparkSamplerProtos$SamplerMetadata$Builder
/**
 * 
 * @deprecated
 */
public "getSources"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
public "getPlatformStatistics"(): $SparkProtos$PlatformStatistics
public "getSystemStatistics"(): $SparkProtos$SystemStatistics
public "getNumberOfTicks"(): integer
public "clearExtraPlatformMetadata"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "removeExtraPlatformMetadata"(arg0: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "putExtraPlatformMetadata"(arg0: string, arg1: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "removeServerConfigurations"(arg0: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearServerConfigurations"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "putServerConfigurations"(arg0: string, arg1: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "setStartTime"(arg0: long): $SparkSamplerProtos$SamplerMetadata$Builder
public "getServerConfigurationsOrDefault"(arg0: string, arg1: string): string
public "hasPlatformMetadata"(): boolean
/**
 * 
 * @deprecated
 */
public "getServerConfigurations"(): $Map<(string), (string)>
public "clearPlatformMetadata"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "mergePlatformMetadata"(arg0: $SparkProtos$PlatformMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "getServerConfigurationsOrThrow"(arg0: string): string
public "getServerConfigurationsMap"(): $Map<(string), (string)>
public "containsServerConfigurations"(arg0: string): boolean
public "hasSystemStatistics"(): boolean
public "getExtraPlatformMetadataOrDefault"(arg0: string, arg1: string): string
public "clearPlatformStatistics"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "setSamplerModeValue"(arg0: integer): $SparkSamplerProtos$SamplerMetadata$Builder
public "mergeSystemStatistics"(arg0: $SparkProtos$SystemStatistics$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "hasPlatformStatistics"(): boolean
public "getExtraPlatformMetadataCount"(): integer
/**
 * 
 * @deprecated
 */
public "getExtraPlatformMetadata"(): $Map<(string), (string)>
public "getExtraPlatformMetadataOrThrow"(arg0: string): string
public "getSourcesOrDefault"(arg0: string, arg1: $SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type): $SparkSamplerProtos$SamplerMetadata$SourceMetadata
public "clearDataAggregator"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearSystemStatistics"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "getServerConfigurationsCount"(): integer
public "containsExtraPlatformMetadata"(arg0: string): boolean
public "getPlatformMetadata"(): $SparkProtos$PlatformMetadata
public "mergeDataAggregator"(arg0: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "mergePlatformStatistics"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "getExtraPlatformMetadataMap"(): $Map<(string), (string)>
public "getSamplerModeValue"(): integer
public "removeSources"(arg0: string): $SparkSamplerProtos$SamplerMetadata$Builder
public "putAllSources"(arg0: $Map$Type<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata$Type)>): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearSources"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "hasThreadDumper"(): boolean
public "hasCreator"(): boolean
public "getThreadDumper"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
public "clearCreator"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "mergeThreadDumper"(arg0: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "clearThreadDumper"(): $SparkSamplerProtos$SamplerMetadata$Builder
public "mergeCreator"(arg0: $SparkProtos$CommandSenderMetadata$Type): $SparkSamplerProtos$SamplerMetadata$Builder
public "hasDataAggregator"(): boolean
public "getDataAggregator"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
public "getCommentBytes"(): $ByteString
public "setCommentBytes"(arg0: $ByteString$Type): $SparkSamplerProtos$SamplerMetadata$Builder
set "platformMetadata"(value: $SparkProtos$PlatformMetadata$Type)
set "platformMetadata"(value: $SparkProtos$PlatformMetadata$Builder$Type)
set "platformStatistics"(value: $SparkProtos$PlatformStatistics$Builder$Type)
set "platformStatistics"(value: $SparkProtos$PlatformStatistics$Type)
set "systemStatistics"(value: $SparkProtos$SystemStatistics$Type)
set "systemStatistics"(value: $SparkProtos$SystemStatistics$Builder$Type)
get "sourcesCount"(): integer
get "samplerMode"(): $SparkSamplerProtos$SamplerMetadata$SamplerMode
get "sourcesMap"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
set "comment"(value: string)
get "comment"(): string
set "creator"(value: $SparkProtos$CommandSenderMetadata$Builder$Type)
set "creator"(value: $SparkProtos$CommandSenderMetadata$Type)
set "dataAggregator"(value: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Builder$Type)
set "dataAggregator"(value: $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type)
set "samplerMode"(value: $SparkSamplerProtos$SamplerMetadata$SamplerMode$Type)
set "threadDumper"(value: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Type)
set "threadDumper"(value: $SparkSamplerProtos$SamplerMetadata$ThreadDumper$Builder$Type)
set "numberOfTicks"(value: integer)
set "endTime"(value: long)
get "startTime"(): long
get "interval"(): integer
get "creator"(): $SparkProtos$CommandSenderMetadata
get "endTime"(): long
set "interval"(value: integer)
get "sources"(): $Map<(string), ($SparkSamplerProtos$SamplerMetadata$SourceMetadata)>
get "platformStatistics"(): $SparkProtos$PlatformStatistics
get "systemStatistics"(): $SparkProtos$SystemStatistics
get "numberOfTicks"(): integer
set "startTime"(value: long)
get "serverConfigurations"(): $Map<(string), (string)>
get "serverConfigurationsMap"(): $Map<(string), (string)>
set "samplerModeValue"(value: integer)
get "extraPlatformMetadataCount"(): integer
get "extraPlatformMetadata"(): $Map<(string), (string)>
get "serverConfigurationsCount"(): integer
get "platformMetadata"(): $SparkProtos$PlatformMetadata
get "extraPlatformMetadataMap"(): $Map<(string), (string)>
get "samplerModeValue"(): integer
get "threadDumper"(): $SparkSamplerProtos$SamplerMetadata$ThreadDumper
get "dataAggregator"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "commentBytes"(): $ByteString
set "commentBytes"(value: $ByteString$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkSamplerProtos$SamplerMetadata$Builder$Type = ($SparkSamplerProtos$SamplerMetadata$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkSamplerProtos$SamplerMetadata$Builder_ = $SparkSamplerProtos$SamplerMetadata$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$KeyedValueImpl" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$KeyedValue, $KeyedValue$Type} from "packages/me/lucko/spark/lib/adventure/key/$KeyedValue"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export class $KeyedValueImpl<T> implements $Examinable, $KeyedValue<(T)> {


public "value"(): T
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): $Key
public "examinableProperties"(): $Stream<(any)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
/**
 * 
 * @deprecated
 */
public static "of"<T>(key: $Key$Type, value: T): $KeyedValue<(T)>
public static "keyedValue"<T>(key: $Key$Type, value: T): $KeyedValue<(T)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $KeyedValueImpl$Type<T> = ($KeyedValueImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $KeyedValueImpl_<T> = $KeyedValueImpl$Type<(T)>;
}}
declare module "packages/me/lucko/spark/common/api/$SparkApi" {
import {$GenericStatistic, $GenericStatistic$Type} from "packages/me/lucko/spark/api/statistic/types/$GenericStatistic"
import {$StatisticWindow$CpuUsage, $StatisticWindow$CpuUsage$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$CpuUsage"
import {$GarbageCollector, $GarbageCollector$Type} from "packages/me/lucko/spark/api/gc/$GarbageCollector"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$DoubleStatistic, $DoubleStatistic$Type} from "packages/me/lucko/spark/api/statistic/types/$DoubleStatistic"
import {$StatisticWindow$TicksPerSecond, $StatisticWindow$TicksPerSecond$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$TicksPerSecond"
import {$Spark, $Spark$Type} from "packages/me/lucko/spark/api/$Spark"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$StatisticWindow$MillisPerTick, $StatisticWindow$MillisPerTick$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow$MillisPerTick"

export class $SparkApi implements $Spark {

constructor(arg0: $SparkPlatform$Type)

public static "register"(arg0: $Spark$Type): void
public "gc"(): $Map<(string), ($GarbageCollector)>
public static "unregister"(): void
public "cpuSystem"(): $DoubleStatistic<($StatisticWindow$CpuUsage)>
public "cpuProcess"(): $DoubleStatistic<($StatisticWindow$CpuUsage)>
public "tps"(): $DoubleStatistic<($StatisticWindow$TicksPerSecond)>
public "mspt"(): $GenericStatistic<($DoubleAverageInfo), ($StatisticWindow$MillisPerTick)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkApi$Type = ($SparkApi);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkApi_ = $SparkApi$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Index" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Index<K, V> {


public "value"(key: K): V
public "values"(): $Set<(V)>
public "key"(value: V): K
public "keys"(): $Set<(K)>
public static "create"<K, V extends $Enum<(V)>>(type: $Class$Type<(V)>, keyFunction: $Function$Type<(any), (any)>, ...values: (V)[]): $Index<(K), (V)>
public static "create"<K, V>(keyFunction: $Function$Type<(any), (any)>, constants: $List$Type<(V)>): $Index<(K), (V)>
public static "create"<K, V>(keyFunction: $Function$Type<(any), (any)>, ...values: (V)[]): $Index<(K), (V)>
public static "create"<K, V extends $Enum<(V)>>(type: $Class$Type<(V)>, keyFunction: $Function$Type<(any), (any)>): $Index<(K), (V)>
public "valueToKey"(): $Map<(V), (K)>
public "keyToValue"(): $Map<(K), (V)>
public "keyOrThrow"(value: V): K
public "valueOr"(key: K, defaultValue: V): V
public "valueOrThrow"(key: K): V
public "keyOr"(value: V, defaultKey: K): K
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Index$Type<K, V> = ($Index<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Index_<K, V> = $Index$Type<(K), (V)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java" {
import {$SparkProtos$SystemStatistics$JavaOrBuilder, $SparkProtos$SystemStatistics$JavaOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$JavaOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$SystemStatistics$Java$Builder, $SparkProtos$SystemStatistics$Java$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Java$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$SystemStatistics$Java extends $GeneratedMessageLite<($SparkProtos$SystemStatistics$Java), ($SparkProtos$SystemStatistics$Java$Builder)> implements $SparkProtos$SystemStatistics$JavaOrBuilder {
static readonly "VENDOR_FIELD_NUMBER": integer
static readonly "VERSION_FIELD_NUMBER": integer
static readonly "VENDOR_VERSION_FIELD_NUMBER": integer
static readonly "VM_ARGS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$SystemStatistics$Java)>
public "getVersion"(): string
public static "newBuilder"(arg0: $SparkProtos$SystemStatistics$Java$Type): $SparkProtos$SystemStatistics$Java$Builder
public static "newBuilder"(): $SparkProtos$SystemStatistics$Java$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Java
public static "getDefaultInstance"(): $SparkProtos$SystemStatistics$Java
public "getVendor"(): string
public "getVersionBytes"(): $ByteString
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$SystemStatistics$Java
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$SystemStatistics$Java
public "getVendorVersion"(): string
public "getVmArgs"(): string
public "getVmArgsBytes"(): $ByteString
public "getVendorBytes"(): $ByteString
public "getVendorVersionBytes"(): $ByteString
get "version"(): string
get "defaultInstance"(): $SparkProtos$SystemStatistics$Java
get "vendor"(): string
get "versionBytes"(): $ByteString
get "vendorVersion"(): string
get "vmArgs"(): string
get "vmArgsBytes"(): $ByteString
get "vendorBytes"(): $ByteString
get "vendorVersionBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$SystemStatistics$Java$Type = ($SparkProtos$SystemStatistics$Java);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$SystemStatistics$Java_ = $SparkProtos$SystemStatistics$Java$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/tick/$TickStatistics" {
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"

export interface $TickStatistics {

 "duration1Min"(): $DoubleAverageInfo
 "tps15Min"(): double
 "duration10Sec"(): $DoubleAverageInfo
 "duration5Min"(): $DoubleAverageInfo
 "tps5Sec"(): double
 "tps10Sec"(): double
 "tps1Min"(): double
 "tps5Min"(): double
 "isDurationSupported"(): boolean
}

export namespace $TickStatistics {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickStatistics$Type = ($TickStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickStatistics_ = $TickStatistics$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$PingOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $SparkProtos$PlatformStatistics$PingOrBuilder extends $MessageLiteOrBuilder {

 "getLast15M"(): $SparkProtos$RollingAverageValues
 "hasLast15M"(): boolean
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$PlatformStatistics$PingOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$PingOrBuilder$Type = ($SparkProtos$PlatformStatistics$PingOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$PingOrBuilder_ = $SparkProtos$PlatformStatistics$PingOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentLike" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentLike {

 "asComponent"(): $Component

(like: $ComponentLike$Type): $Component
}

export namespace $ComponentLike {
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentLike$Type = ($ComponentLike);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentLike_ = $ComponentLike$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageLiteToString" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $MessageLiteToString {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageLiteToString$Type = ($MessageLiteToString);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageLiteToString_ = $MessageLiteToString$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/nbt/api/$BinaryTagHolderImpl" {
import {$BinaryTagHolder, $BinaryTagHolder$Type} from "packages/me/lucko/spark/lib/adventure/nbt/api/$BinaryTagHolder"
import {$Codec, $Codec$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"

export class $BinaryTagHolderImpl implements $BinaryTagHolder {


public "get"<T, DX extends $Exception>(codec: $Codec$Type<(T), (string), (DX), (any)>): T
public "equals"(that: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "string"(): string
public static "encode"<T, EX extends $Exception>(nbt: T, codec: $Codec$Type<(any), (string), (any), (EX)>): $BinaryTagHolder
/**
 * 
 * @deprecated
 */
public static "of"(string: string): $BinaryTagHolder
public static "binaryTagHolder"(string: string): $BinaryTagHolder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BinaryTagHolderImpl$Type = ($BinaryTagHolderImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BinaryTagHolderImpl_ = $BinaryTagHolderImpl$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/ping/$PingStatistics$PlayerPing" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $PingStatistics$PlayerPing {


public "name"(): string
public "ping"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PingStatistics$PlayerPing$Type = ($PingStatistics$PlayerPing);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PingStatistics$PlayerPing_ = $PingStatistics$PlayerPing$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldInfo$Builder" {
import {$FieldInfo, $FieldInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldInfo"
import {$FieldType, $FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldType"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"
import {$Internal$EnumVerifier, $Internal$EnumVerifier$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumVerifier"
import {$OneofInfo, $OneofInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$OneofInfo"

export class $FieldInfo$Builder {


public "build"(): $FieldInfo
public "withField"(arg0: $Field$Type): $FieldInfo$Builder
public "withMapDefaultEntry"(arg0: any): $FieldInfo$Builder
public "withCachedSizeField"(arg0: $Field$Type): $FieldInfo$Builder
public "withType"(arg0: $FieldType$Type): $FieldInfo$Builder
public "withRequired"(arg0: boolean): $FieldInfo$Builder
public "withEnumVerifier"(arg0: $Internal$EnumVerifier$Type): $FieldInfo$Builder
public "withFieldNumber"(arg0: integer): $FieldInfo$Builder
public "withEnforceUtf8"(arg0: boolean): $FieldInfo$Builder
public "withPresence"(arg0: $Field$Type, arg1: integer): $FieldInfo$Builder
public "withOneof"(arg0: $OneofInfo$Type, arg1: $Class$Type<(any)>): $FieldInfo$Builder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldInfo$Builder$Type = ($FieldInfo$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldInfo$Builder_ = $FieldInfo$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/bossbar/$BossBarImplementation" {
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $BossBarImplementation {

}

export namespace $BossBarImplementation {
function get<I>(bar: $BossBar$Type, type: $Class$Type<(I)>): I
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BossBarImplementation$Type = ($BossBarImplementation);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BossBarImplementation_ = $BossBarImplementation$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener$Builder" {
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$ComponentFlattener, $ComponentFlattener$Type} from "packages/me/lucko/spark/lib/adventure/text/flattener/$ComponentFlattener"

export interface $ComponentFlattener$Builder extends $AbstractBuilder<($ComponentFlattener)>, $Buildable$Builder<($ComponentFlattener)> {

 "complexMapper"<T extends $Component>(type: $Class$Type<(T)>, converter: $BiConsumer$Type<(T), ($Consumer$Type<($Component$Type)>)>): $ComponentFlattener$Builder
 "unknownMapper"(converter: $Function$Type<($Component$Type), (string)>): $ComponentFlattener$Builder
 "mapper"<T extends $Component>(type: $Class$Type<(T)>, converter: $Function$Type<(T), (string)>): $ComponentFlattener$Builder
 "build"(): $ComponentFlattener
}

export namespace $ComponentFlattener$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $ComponentFlattener
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentFlattener$Builder$Type = ($ComponentFlattener$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentFlattener$Builder_ = $ComponentFlattener$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$ExtensionDescriptor" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$WireFormat$JavaType, $WireFormat$JavaType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$JavaType"
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$FieldSet$FieldDescriptorLite, $FieldSet$FieldDescriptorLite$Type} from "packages/me/lucko/spark/lib/protobuf/$FieldSet$FieldDescriptorLite"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"

export class $GeneratedMessageLite$ExtensionDescriptor implements $FieldSet$FieldDescriptorLite<($GeneratedMessageLite$ExtensionDescriptor)> {


public "compareTo"(arg0: $GeneratedMessageLite$ExtensionDescriptor$Type): integer
public "getNumber"(): integer
public "internalMergeFrom"(arg0: $MessageLite$Builder$Type, arg1: $MessageLite$Type): $MessageLite$Builder
public "isPacked"(): boolean
public "isRepeated"(): boolean
public "getEnumType"(): $Internal$EnumLiteMap<(any)>
public "getLiteType"(): $WireFormat$FieldType
public "getLiteJavaType"(): $WireFormat$JavaType
get "number"(): integer
get "packed"(): boolean
get "repeated"(): boolean
get "enumType"(): $Internal$EnumLiteMap<(any)>
get "liteType"(): $WireFormat$FieldType
get "liteJavaType"(): $WireFormat$JavaType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedMessageLite$ExtensionDescriptor$Type = ($GeneratedMessageLite$ExtensionDescriptor);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedMessageLite$ExtensionDescriptor_ = $GeneratedMessageLite$ExtensionDescriptor$Type;
}}
declare module "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider" {
import {$WorldInfoProvider$ChunksResult, $WorldInfoProvider$ChunksResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$ChunksResult"
import {$WorldInfoProvider$CountsResult, $WorldInfoProvider$CountsResult$Type} from "packages/me/lucko/spark/common/platform/world/$WorldInfoProvider$CountsResult"

export interface $WorldInfoProvider {

 "mustCallSync"(): boolean
 "pollCounts"(): $WorldInfoProvider$CountsResult
 "pollChunks"(): $WorldInfoProvider$ChunksResult<(any)>
}

export namespace $WorldInfoProvider {
const NO_OP: $WorldInfoProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WorldInfoProvider$Type = ($WorldInfoProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WorldInfoProvider_ = $WorldInfoProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$LinearComponents" {
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $LinearComponents {


public static "linear"(...applicables: ($ComponentBuilderApplicable$Type)[]): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LinearComponents$Type = ($LinearComponents);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LinearComponents_ = $LinearComponents$Type;
}}
declare module "packages/me/lucko/spark/common/util/$RollingAverage" {
import {$BigDecimal, $BigDecimal$Type} from "packages/java/math/$BigDecimal"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"

export class $RollingAverage implements $DoubleAverageInfo {

constructor(arg0: integer)

public "add"(arg0: $BigDecimal$Type): void
public "min"(): double
public "max"(): double
public "mean"(): double
public "getSamples"(): integer
public "percentile"(arg0: double): double
public "percentile95th"(): double
public "median"(): double
get "samples"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $RollingAverage$Type = ($RollingAverage);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $RollingAverage_ = $RollingAverage$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MapFieldSchemaLite" {
import {$MapEntryLite$Metadata, $MapEntryLite$Metadata$Type} from "packages/me/lucko/spark/lib/protobuf/$MapEntryLite$Metadata"
import {$MapFieldSchema, $MapFieldSchema$Type} from "packages/me/lucko/spark/lib/protobuf/$MapFieldSchema"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $MapFieldSchemaLite implements $MapFieldSchema {


public "getSerializedSize"(arg0: integer, arg1: any, arg2: any): integer
public "isImmutable"(arg0: any): boolean
public "toImmutable"(arg0: any): any
public "mergeFrom"(arg0: any, arg1: any): any
public "forMutableMapData"(arg0: any): $Map<(any), (any)>
public "newMapField"(arg0: any): any
public "forMapMetadata"(arg0: any): $MapEntryLite$Metadata<(any), (any)>
public "forMapData"(arg0: any): $Map<(any), (any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MapFieldSchemaLite$Type = ($MapFieldSchemaLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MapFieldSchemaLite_ = $MapFieldSchemaLite$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$FieldType" {
import {$JavaType, $JavaType$Type} from "packages/me/lucko/spark/lib/protobuf/$JavaType"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Field, $Field$Type} from "packages/java/lang/reflect/$Field"

export class $FieldType extends $Enum<($FieldType)> {
static readonly "DOUBLE": $FieldType
static readonly "FLOAT": $FieldType
static readonly "INT64": $FieldType
static readonly "UINT64": $FieldType
static readonly "INT32": $FieldType
static readonly "FIXED64": $FieldType
static readonly "FIXED32": $FieldType
static readonly "BOOL": $FieldType
static readonly "STRING": $FieldType
static readonly "MESSAGE": $FieldType
static readonly "BYTES": $FieldType
static readonly "UINT32": $FieldType
static readonly "ENUM": $FieldType
static readonly "SFIXED32": $FieldType
static readonly "SFIXED64": $FieldType
static readonly "SINT32": $FieldType
static readonly "SINT64": $FieldType
static readonly "GROUP": $FieldType
static readonly "DOUBLE_LIST": $FieldType
static readonly "FLOAT_LIST": $FieldType
static readonly "INT64_LIST": $FieldType
static readonly "UINT64_LIST": $FieldType
static readonly "INT32_LIST": $FieldType
static readonly "FIXED64_LIST": $FieldType
static readonly "FIXED32_LIST": $FieldType
static readonly "BOOL_LIST": $FieldType
static readonly "STRING_LIST": $FieldType
static readonly "MESSAGE_LIST": $FieldType
static readonly "BYTES_LIST": $FieldType
static readonly "UINT32_LIST": $FieldType
static readonly "ENUM_LIST": $FieldType
static readonly "SFIXED32_LIST": $FieldType
static readonly "SFIXED64_LIST": $FieldType
static readonly "SINT32_LIST": $FieldType
static readonly "SINT64_LIST": $FieldType
static readonly "DOUBLE_LIST_PACKED": $FieldType
static readonly "FLOAT_LIST_PACKED": $FieldType
static readonly "INT64_LIST_PACKED": $FieldType
static readonly "UINT64_LIST_PACKED": $FieldType
static readonly "INT32_LIST_PACKED": $FieldType
static readonly "FIXED64_LIST_PACKED": $FieldType
static readonly "FIXED32_LIST_PACKED": $FieldType
static readonly "BOOL_LIST_PACKED": $FieldType
static readonly "UINT32_LIST_PACKED": $FieldType
static readonly "ENUM_LIST_PACKED": $FieldType
static readonly "SFIXED32_LIST_PACKED": $FieldType
static readonly "SFIXED64_LIST_PACKED": $FieldType
static readonly "SINT32_LIST_PACKED": $FieldType
static readonly "SINT64_LIST_PACKED": $FieldType
static readonly "GROUP_LIST": $FieldType
static readonly "MAP": $FieldType


public static "values"(): ($FieldType)[]
public static "valueOf"(arg0: string): $FieldType
public "id"(): integer
public "getJavaType"(): $JavaType
public "isPrimitiveScalar"(): boolean
public "isValidForField"(arg0: $Field$Type): boolean
public static "forId"(arg0: integer): $FieldType
public "isScalar"(): boolean
public "isPacked"(): boolean
public "isList"(): boolean
public "isMap"(): boolean
get "javaType"(): $JavaType
get "primitiveScalar"(): boolean
get "scalar"(): boolean
get "packed"(): boolean
get "list"(): boolean
get "map"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FieldType$Type = (("fixed64") | ("message_list") | ("int32_list") | ("sint32_list_packed") | ("sfixed64") | ("sint32_list") | ("float") | ("bytes_list") | ("sfixed32_list") | ("sfixed32_list_packed") | ("fixed32_list_packed") | ("int64") | ("uint32") | ("group") | ("fixed32_list") | ("double") | ("enum_list_packed") | ("bool_list_packed") | ("uint64_list") | ("uint32_list_packed") | ("uint64_list_packed") | ("enum") | ("bool_list") | ("group_list") | ("uint64") | ("fixed64_list") | ("double_list_packed") | ("float_list") | ("sint64_list_packed") | ("sint32") | ("double_list") | ("bool") | ("string") | ("sfixed64_list_packed") | ("fixed64_list_packed") | ("uint32_list") | ("sfixed32") | ("map") | ("fixed32") | ("sint64") | ("int32_list_packed") | ("sint64_list") | ("int64_list_packed") | ("message") | ("sfixed64_list") | ("float_list_packed") | ("int32") | ("bytes") | ("int64_list") | ("string_list") | ("enum_list")) | ($FieldType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FieldType_ = $FieldType$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteOutput" {
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $ByteOutput {

constructor()

public "write"(arg0: $ByteBuffer$Type): void
public "write"(arg0: (byte)[], arg1: integer, arg2: integer): void
public "write"(arg0: byte): void
public "writeLazy"(arg0: $ByteBuffer$Type): void
public "writeLazy"(arg0: (byte)[], arg1: integer, arg2: integer): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteOutput$Type = ($ByteOutput);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteOutput_ = $ByteOutput$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$IExtension" {
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"

export interface $IExtension {

 "acceptProvidedExtensionAsServer"(arg0: string): boolean
 "getProvidedExtensionAsServer"(): string
 "acceptProvidedExtensionAsClient"(arg0: string): boolean
 "getProvidedExtensionAsClient"(): string
 "toString"(): string
 "reset"(): void
 "encodeFrame"(arg0: $Framedata$Type): void
 "decodeFrame"(arg0: $Framedata$Type): void
 "copyInstance"(): $IExtension
 "isFrameValid"(arg0: $Framedata$Type): void
}

export namespace $IExtension {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IExtension$Type = ($IExtension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IExtension_ = $IExtension$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$ProtobufList<E> extends $List<(E)>, $RandomAccess {

 "makeImmutable"(): void
 "mutableCopyWithCapacity"(arg0: integer): $Internal$ProtobufList<(E)>
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: E): void
 "add"(arg0: E): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): E
 "get"(arg0: integer): E
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(E)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(E)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(E)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(E)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: E): E
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(E)>
 "listIterator"(): $ListIterator<(E)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(E)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(E)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$ProtobufList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E): $List<(E)>
function of<E>(arg0: E, arg1: E): $List<(E)>
function of<E>(arg0: E): $List<(E)>
function of<E>(): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
function of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
function of<E>(...arg0: (E)[]): $List<(E)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$ProtobufList$Type<E> = ($Internal$ProtobufList<(E)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$ProtobufList_<E> = $Internal$ProtobufList$Type<(E)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$ChunkOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $SparkProtos$WorldStatistics$ChunkOrBuilder extends $MessageLiteOrBuilder {

 "getZ"(): integer
 "getX"(): integer
 "containsEntityCounts"(arg0: string): boolean
 "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
 "getEntityCountsCount"(): integer
 "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
 "getEntityCounts"(): $Map<(string), (integer)>
 "getEntityCountsMap"(): $Map<(string), (integer)>
 "getTotalEntities"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkProtos$WorldStatistics$ChunkOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$ChunkOrBuilder$Type = ($SparkProtos$WorldStatistics$ChunkOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$ChunkOrBuilder_ = $SparkProtos$WorldStatistics$ChunkOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/command/$Command$ArgumentInfo" {
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $Command$ArgumentInfo {

constructor(arg0: string, arg1: string, arg2: string)

public "subCommandName"(): string
public "argumentName"(): string
public "requiresParameter"(): boolean
public "parameterDescription"(): string
public "toComponent"(arg0: string): $Component
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Command$ArgumentInfo$Type = ($Command$ArgumentInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Command$ArgumentInfo_ = $Command$ArgumentInfo$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$AbstractNode" {
import {$StackTraceNode, $StackTraceNode$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"

export class $AbstractNode {

constructor()

public "getChildren"(): $Collection<($StackTraceNode)>
public "getTimeWindows"(): $Set<(integer)>
public "removeTimeWindows"(arg0: $IntPredicate$Type): boolean
get "children"(): $Collection<($StackTraceNode)>
get "timeWindows"(): $Set<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractNode$Type = ($AbstractNode);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractNode_ = $AbstractNode$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$Component" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$StyleGetter, $StyleGetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleGetter"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$StyleSetter, $StyleSetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleSetter"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Component extends $ComponentBuilderApplicable, $ComponentLike, $Examinable, $HoverEventSource<($Component)>, $StyleGetter, $StyleSetter<($Component)> {

 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $Component
 "append"(like: $ComponentLike$Type): $Component
 "append"(component: $Component$Type): $Component
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(color: $TextColor$Type): $Component
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(style: $Style$Type): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Component
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "style"(style: $Style$Builder$Type): $Component
 "children"(): $List<($Component)>
 "children"(children: $List$Type<(any)>): $Component
 "appendNewline"(): $Component
 "mergeStyle"(that: $Component$Type): $Component
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $Component
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "colorIfAbsent"(color: $TextColor$Type): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "examinableProperties"(): $Stream<(any)>
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "decorate"(decoration: $TextDecoration$Type): $Component
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(event: $ClickEvent$Type): $Component
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "hoverEvent"(source: $HoverEventSource$Type<(any)>): $Component
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $Component {
const EQUALS: $BiPredicate<(any), (any)>
const EQUALS_IDENTITY: $BiPredicate<(any), (any)>
const IS_NOT_EMPTY: $Predicate<(any)>
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Component$Type = ($Component);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Component_ = $Component$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/$CurrentFrame" {
import {$Frame, $Frame$Type} from "packages/me/lucko/spark/lib/asm/$Frame"

export class $CurrentFrame extends $Frame {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CurrentFrame$Type = ($CurrentFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CurrentFrame_ = $CurrentFrame$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$IntList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$IntList extends $Internal$ProtobufList<(integer)> {

 "getInt"(arg0: integer): integer
 "setInt"(arg0: integer, arg1: integer): integer
 "mutableCopyWithCapacity"(arg0: integer): $Internal$IntList
 "addInt"(arg0: integer): void
 "makeImmutable"(): void
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: integer): void
 "add"(arg0: integer): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): integer
 "get"(arg0: integer): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(integer)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(integer)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(integer)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: integer): integer
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(integer)>
 "listIterator"(): $ListIterator<(integer)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(integer)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(integer)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$IntList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer): $List<(integer)>
function of<E>(arg0: integer): $List<(integer)>
function of<E>(): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
function of<E>(...arg0: (integer)[]): $List<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$IntList$Type = ($Internal$IntList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$IntList_ = $Internal$IntList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/audience/$ForwardingAudience" {
import {$SignedMessage, $SignedMessage$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage"
import {$BossBar, $BossBar$Type} from "packages/me/lucko/spark/lib/adventure/bossbar/$BossBar"
import {$SignedMessage$Signature, $SignedMessage$Signature$Type} from "packages/me/lucko/spark/lib/adventure/chat/$SignedMessage$Signature"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$TitlePart, $TitlePart$Type} from "packages/me/lucko/spark/lib/adventure/title/$TitlePart"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SoundStop, $SoundStop$Type} from "packages/me/lucko/spark/lib/adventure/sound/$SoundStop"
import {$Pointers, $Pointers$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointers"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$Sound$Emitter, $Sound$Emitter$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound$Emitter"
import {$Book$Builder, $Book$Builder$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book$Builder"
import {$Identified, $Identified$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identified"
import {$Identity, $Identity$Type} from "packages/me/lucko/spark/lib/adventure/identity/$Identity"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$MessageType, $MessageType$Type} from "packages/me/lucko/spark/lib/adventure/audience/$MessageType"
import {$Title, $Title$Type} from "packages/me/lucko/spark/lib/adventure/title/$Title"
import {$Audience, $Audience$Type} from "packages/me/lucko/spark/lib/adventure/audience/$Audience"
import {$Optional, $Optional$Type} from "packages/java/util/$Optional"
import {$ChatType$Bound, $ChatType$Bound$Type} from "packages/me/lucko/spark/lib/adventure/chat/$ChatType$Bound"
import {$Book, $Book$Type} from "packages/me/lucko/spark/lib/adventure/inventory/$Book"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"
import {$Sound, $Sound$Type} from "packages/me/lucko/spark/lib/adventure/sound/$Sound"

export interface $ForwardingAudience extends $Audience {

 "sendMessage"(signedMessage: $SignedMessage$Type, boundChatType: $ChatType$Bound$Type): void
 "sendMessage"(message: $Component$Type, boundChatType: $ChatType$Bound$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $Component$Type, type: $MessageType$Type): void
 "sendMessage"(message: $Component$Type): void
 "forEachAudience"(action: $Consumer$Type<(any)>): void
 "audiences"(): $Iterable<(any)>
 "filterAudience"(filter: $Predicate$Type<(any)>): $Audience
 "deleteMessage"(signature: $SignedMessage$Signature$Type): void
 "clearTitle"(): void
 "sendActionBar"(message: $Component$Type): void
 "showBossBar"(bar: $BossBar$Type): void
 "hideBossBar"(bar: $BossBar$Type): void
 "resetTitle"(): void
 "openBook"(book: $Book$Type): void
 "sendTitlePart"<T>(part: $TitlePart$Type<(T)>, value: T): void
 "stopSound"(stop: $SoundStop$Type): void
 "pointers"(): $Pointers
 "playSound"(sound: $Sound$Type, x: double, y: double, z: double): void
 "playSound"(sound: $Sound$Type, emitter: $Sound$Emitter$Type): void
 "playSound"(sound: $Sound$Type): void
 "sendPlayerListHeaderAndFooter"(header: $Component$Type, footer: $Component$Type): void
 "sendPlayerListHeader"(header: $Component$Type): void
 "sendPlayerListFooter"(footer: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $Component$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identity$Type, message: $ComponentLike$Type): void
 "sendMessage"(message: $ComponentLike$Type, boundChatType: $ChatType$Bound$Type): void
 "sendMessage"(message: $ComponentLike$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(message: $ComponentLike$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(message: $Component$Type, type: $MessageType$Type): void
/**
 * 
 * @deprecated
 */
 "sendMessage"(source: $Identified$Type, message: $ComponentLike$Type): void
 "deleteMessage"(signedMessage: $SignedMessage$Type): void
 "sendActionBar"(message: $ComponentLike$Type): void
 "openBook"(book: $Book$Builder$Type): void
 "stopSound"(sound: $Sound$Type): void
 "showTitle"(title: $Title$Type): void
 "sendPlayerListHeaderAndFooter"(header: $ComponentLike$Type, footer: $ComponentLike$Type): void
 "sendPlayerListHeader"(header: $ComponentLike$Type): void
 "sendPlayerListFooter"(footer: $ComponentLike$Type): void
 "getOrDefaultFrom"<T>(pointer: $Pointer$Type<(T)>, defaultValue: $Supplier$Type<(any)>): T
 "get"<T>(pointer: $Pointer$Type<(T)>): $Optional<(T)>
 "getOrDefault"<T>(pointer: $Pointer$Type<(T)>, defaultValue: T): T

(signedMessage: $SignedMessage$Type, boundChatType: $ChatType$Bound$Type): void
}

export namespace $ForwardingAudience {
function empty(): $Audience
function audience(audiences: $Iterable$Type<(any)>): $ForwardingAudience
function audience(...audiences: ($Audience$Type)[]): $Audience
function toAudience(): $Collector<(any), (any), ($ForwardingAudience)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForwardingAudience$Type = ($ForwardingAudience);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForwardingAudience_ = $ForwardingAudience$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageSchema" {
import {$ArrayDecoders$Registers, $ArrayDecoders$Registers$Type} from "packages/me/lucko/spark/lib/protobuf/$ArrayDecoders$Registers"
import {$Schema, $Schema$Type} from "packages/me/lucko/spark/lib/protobuf/$Schema"
import {$Reader, $Reader$Type} from "packages/me/lucko/spark/lib/protobuf/$Reader"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$Writer, $Writer$Type} from "packages/me/lucko/spark/lib/protobuf/$Writer"

export class $MessageSchema<T> implements $Schema<(T)> {


public "equals"(arg0: T, arg1: T): boolean
public "hashCode"(arg0: T): integer
public "newInstance"(): T
public "writeTo"(arg0: T, arg1: $Writer$Type): void
public "makeImmutable"(arg0: T): void
public "getSerializedSize"(arg0: T): integer
public "isInitialized"(arg0: T): boolean
public "mergeFrom"(arg0: T, arg1: $Reader$Type, arg2: $ExtensionRegistryLite$Type): void
public "mergeFrom"(arg0: T, arg1: (byte)[], arg2: integer, arg3: integer, arg4: $ArrayDecoders$Registers$Type): void
public "mergeFrom"(arg0: T, arg1: T): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageSchema$Type<T> = ($MessageSchema<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageSchema_<T> = $MessageSchema$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextColorImpl" {
import {$HSVLike, $HSVLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$HSVLike"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$RGBLike, $RGBLike$Type} from "packages/me/lucko/spark/lib/adventure/util/$RGBLike"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"

export class $TextColorImpl implements $TextColor {


public "value"(): integer
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(that: $TextColor$Type): integer
public static "color"(r: float, g: float, b: float): $TextColor
public static "color"(value: integer): $TextColor
public static "color"(rgb: $RGBLike$Type): $TextColor
public static "color"(r: integer, g: integer, b: integer): $TextColor
public static "color"(hsv: $HSVLike$Type): $TextColor
public "red"(): integer
public static "fromCSSHexString"(string: string): $TextColor
public "asHexString"(): string
public static "fromHexString"(string: string): $TextColor
public "styleApply"(style: $Style$Builder$Type): void
public "examinableProperties"(): $Stream<(any)>
public "blue"(): integer
public "green"(): integer
public static "lerp"(t: float, a: $RGBLike$Type, b: $RGBLike$Type): $TextColor
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "asHSV"(): $HSVLike
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextColorImpl$Type = ($TextColorImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextColorImpl_ = $TextColorImpl$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$SamplerBuilder" {
import {$Sampler, $Sampler$Type} from "packages/me/lucko/spark/common/sampler/$Sampler"
import {$ThreadGrouper, $ThreadGrouper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadGrouper"
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"
import {$TimeUnit, $TimeUnit$Type} from "packages/java/util/concurrent/$TimeUnit"

export class $SamplerBuilder {

constructor()

public "start"(arg0: $SparkPlatform$Type): $Sampler
public "mode"(arg0: $SamplerMode$Type): $SamplerBuilder
public "ticksOver"(arg0: integer, arg1: $TickHook$Type): $SamplerBuilder
public "completeAfter"(arg0: long, arg1: $TimeUnit$Type): $SamplerBuilder
public "forceJavaSampler"(arg0: boolean): $SamplerBuilder
public "ignoreNative"(arg0: boolean): $SamplerBuilder
public "allocLiveOnly"(arg0: boolean): $SamplerBuilder
public "threadDumper"(arg0: $ThreadDumper$Type): $SamplerBuilder
public "threadGrouper"(arg0: $ThreadGrouper$Type): $SamplerBuilder
public "ignoreSleeping"(arg0: boolean): $SamplerBuilder
public "background"(arg0: boolean): $SamplerBuilder
public "samplingInterval"(arg0: double): $SamplerBuilder
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SamplerBuilder$Type = ($SamplerBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SamplerBuilder_ = $SamplerBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MixinOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $MixinOrBuilder extends $MessageLiteOrBuilder {

 "getName"(): string
 "getRoot"(): string
 "getNameBytes"(): $ByteString
 "getRootBytes"(): $ByteString
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $MixinOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MixinOrBuilder$Type = ($MixinOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MixinOrBuilder_ = $MixinOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/tick/$ReportPredicate" {
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ReportPredicate {

 "shouldReport"(arg0: double, arg1: double, arg2: double): boolean
 "monitoringStartMessage"(): $Component
}

export namespace $ReportPredicate {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReportPredicate$Type = ($ReportPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReportPredicate_ = $ReportPredicate$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$WireFormat" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $WireFormat {
static readonly "WIRETYPE_VARINT": integer
static readonly "WIRETYPE_FIXED64": integer
static readonly "WIRETYPE_LENGTH_DELIMITED": integer
static readonly "WIRETYPE_START_GROUP": integer
static readonly "WIRETYPE_END_GROUP": integer
static readonly "WIRETYPE_FIXED32": integer


public static "getTagFieldNumber"(arg0: integer): integer
public static "getTagWireType"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WireFormat$Type = ($WireFormat);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WireFormat_ = $WireFormat$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/util/$Codec" {
import {$Throwable, $Throwable$Type} from "packages/java/lang/$Throwable"
import {$Codec$Encoder, $Codec$Encoder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec$Encoder"
import {$Codec$Decoder, $Codec$Decoder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Codec$Decoder"

export interface $Codec<D, E, DX extends $Throwable, EX extends $Throwable> {

 "decode"(encoded: E): D
 "encode"(decoded: D): E
}

export namespace $Codec {
function of<D, E, DX, EX>(decoder: $Codec$Decoder$Type<(D), (E), (DX)>, encoder: $Codec$Encoder$Type<(D), (E), (EX)>): $Codec<(D), (E), (DX), (EX)>
function codec<D, E, DX, EX>(decoder: $Codec$Decoder$Type<(D), (E), (DX)>, encoder: $Codec$Encoder$Type<(D), (E), (EX)>): $Codec<(D), (E), (DX), (EX)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Codec$Type<D, E, DX, EX> = ($Codec<(D), (E), (DX), (EX)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Codec_<D, E, DX, EX> = $Codec$Type<(D), (E), (DX), (EX)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings" {
import {$SparkWebSocketProtos$ServerConnectResponse$Settings$Builder, $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$Settings$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder, $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkWebSocketProtos$ServerConnectResponse$Settings extends $GeneratedMessageLite<($SparkWebSocketProtos$ServerConnectResponse$Settings), ($SparkWebSocketProtos$ServerConnectResponse$Settings$Builder)> implements $SparkWebSocketProtos$ServerConnectResponse$SettingsOrBuilder {
static readonly "STATISTICS_INTERVAL_FIELD_NUMBER": integer
static readonly "SAMPLER_INTERVAL_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkWebSocketProtos$ServerConnectResponse$Settings)>
public static "newBuilder"(): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
public static "newBuilder"(arg0: $SparkWebSocketProtos$ServerConnectResponse$Settings$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "getDefaultInstance"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $InputStream$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $ByteString$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: (byte)[]): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkWebSocketProtos$ServerConnectResponse$Settings
public "getSamplerInterval"(): integer
public "getStatisticsInterval"(): integer
get "defaultInstance"(): $SparkWebSocketProtos$ServerConnectResponse$Settings
get "samplerInterval"(): integer
get "statisticsInterval"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerConnectResponse$Settings$Type = ($SparkWebSocketProtos$ServerConnectResponse$Settings);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerConnectResponse$Settings_ = $SparkWebSocketProtos$ServerConnectResponse$Settings$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps$Builder" {
import {$SparkProtos$PlatformStatistics$Tps, $SparkProtos$PlatformStatistics$Tps$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Tps"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$PlatformStatistics$TpsOrBuilder, $SparkProtos$PlatformStatistics$TpsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$TpsOrBuilder"

export class $SparkProtos$PlatformStatistics$Tps$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$PlatformStatistics$Tps), ($SparkProtos$PlatformStatistics$Tps$Builder)> implements $SparkProtos$PlatformStatistics$TpsOrBuilder {


public "setLast1M"(arg0: double): $SparkProtos$PlatformStatistics$Tps$Builder
public "setLast15M"(arg0: double): $SparkProtos$PlatformStatistics$Tps$Builder
public "setLast5M"(arg0: double): $SparkProtos$PlatformStatistics$Tps$Builder
public "clearLast1M"(): $SparkProtos$PlatformStatistics$Tps$Builder
public "clearLast5M"(): $SparkProtos$PlatformStatistics$Tps$Builder
public "getLast5M"(): double
public "getLast1M"(): double
public "getLast15M"(): double
public "clearLast15M"(): $SparkProtos$PlatformStatistics$Tps$Builder
set "last1M"(value: double)
set "last15M"(value: double)
set "last5M"(value: double)
get "last5M"(): double
get "last1M"(): double
get "last15M"(): double
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Tps$Builder$Type = ($SparkProtos$PlatformStatistics$Tps$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Tps$Builder_ = $SparkProtos$PlatformStatistics$Tps$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MutabilityOracle" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $MutabilityOracle {

 "ensureMutable"(): void

(): void
}

export namespace $MutabilityOracle {
const IMMUTABLE: $MutabilityOracle
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MutabilityOracle$Type = ($MutabilityOracle);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MutabilityOracle_ = $MutabilityOracle$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$BlockNBTComponent$WorldPos$Coordinate, $BlockNBTComponent$WorldPos$Coordinate$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $BlockNBTComponent$Builder extends $NBTComponentBuilder<($BlockNBTComponent), ($BlockNBTComponent$Builder)> {

 "pos"(pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent$Builder
 "absoluteWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent$Builder
 "relativeWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent$Builder
 "localPos"(left: double, up: double, forwards: double): $BlockNBTComponent$Builder
 "worldPos"(x: $BlockNBTComponent$WorldPos$Coordinate$Type, y: $BlockNBTComponent$WorldPos$Coordinate$Type, z: $BlockNBTComponent$WorldPos$Coordinate$Type): $BlockNBTComponent$Builder
 "separator"(separator: $ComponentLike$Type): $BlockNBTComponent$Builder
 "nbtPath"(nbtPath: string): $BlockNBTComponent$Builder
 "interpret"(interpret: boolean): $BlockNBTComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $BlockNBTComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $BlockNBTComponent$Builder
 "append"(...components: ($Component$Type)[]): $BlockNBTComponent$Builder
 "append"(component: $Component$Type): $BlockNBTComponent$Builder
 "append"(component: $ComponentLike$Type): $BlockNBTComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $BlockNBTComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $BlockNBTComponent$Builder
 "style"(style: $Style$Type): $BlockNBTComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $BlockNBTComponent$Builder
 "mergeStyle"(that: $Component$Type): $BlockNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $BlockNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $BlockNBTComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $BlockNBTComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $BlockNBTComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $BlockNBTComponent$Builder
 "resetStyle"(): $BlockNBTComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $BlockNBTComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $BlockNBTComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $BlockNBTComponent$Builder
 "font"(font: $Key$Type): $BlockNBTComponent$Builder
 "appendSpace"(): $BlockNBTComponent$Builder
 "insertion"(insertion: string): $BlockNBTComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $BlockNBTComponent$Builder
}

export namespace $BlockNBTComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponent$Builder$Type = ($BlockNBTComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponent$Builder_ = $BlockNBTComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DoubleValue" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$DoubleValueOrBuilder, $DoubleValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$DoubleValueOrBuilder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$DoubleValue$Builder, $DoubleValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$DoubleValue$Builder"

export class $DoubleValue extends $GeneratedMessageLite<($DoubleValue), ($DoubleValue$Builder)> implements $DoubleValueOrBuilder {
static readonly "VALUE_FIELD_NUMBER": integer


public "getValue"(): double
public static "of"(arg0: double): $DoubleValue
public static "parser"(): $Parser<($DoubleValue)>
public static "newBuilder"(arg0: $DoubleValue$Type): $DoubleValue$Builder
public static "newBuilder"(): $DoubleValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $DoubleValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $DoubleValue
public static "getDefaultInstance"(): $DoubleValue
public static "parseFrom"(arg0: $ByteString$Type): $DoubleValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $DoubleValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $DoubleValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $DoubleValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $DoubleValue
public static "parseFrom"(arg0: $InputStream$Type): $DoubleValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $DoubleValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $DoubleValue
public static "parseFrom"(arg0: (byte)[]): $DoubleValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $DoubleValue
get "value"(): double
get "defaultInstance"(): $DoubleValue
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleValue$Type = ($DoubleValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleValue_ = $DoubleValue$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int32ValueOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export interface $Int32ValueOrBuilder extends $MessageLiteOrBuilder {

 "getValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $Int32ValueOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int32ValueOrBuilder$Type = ($Int32ValueOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int32ValueOrBuilder_ = $Int32ValueOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$SamplerContainer" {
import {$Sampler, $Sampler$Type} from "packages/me/lucko/spark/common/sampler/$Sampler"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"

export class $SamplerContainer implements $AutoCloseable {

constructor()

public "close"(): void
public "getActiveSampler"(): $Sampler
public "unsetActiveSampler"(arg0: $Sampler$Type): void
public "setActiveSampler"(arg0: $Sampler$Type): void
public "stopActiveSampler"(arg0: boolean): void
get "activeSampler"(): $Sampler
set "activeSampler"(value: $Sampler$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SamplerContainer$Type = ($SamplerContainer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SamplerContainer_ = $SamplerContainer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$StringValue$Builder" {
import {$StringValueOrBuilder, $StringValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$StringValueOrBuilder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$StringValue, $StringValue$Type} from "packages/me/lucko/spark/lib/protobuf/$StringValue"

export class $StringValue$Builder extends $GeneratedMessageLite$Builder<($StringValue), ($StringValue$Builder)> implements $StringValueOrBuilder {


public "getValue"(): string
public "setValue"(arg0: string): $StringValue$Builder
public "clearValue"(): $StringValue$Builder
public "setValueBytes"(arg0: $ByteString$Type): $StringValue$Builder
public "getValueBytes"(): $ByteString
get "value"(): string
set "value"(value: string)
set "valueBytes"(value: $ByteString$Type)
get "valueBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StringValue$Builder$Type = ($StringValue$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StringValue$Builder_ = $StringValue$Builder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region$Builder" {
import {$SparkProtos$WorldStatistics$Chunk$Builder, $SparkProtos$WorldStatistics$Chunk$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk$Builder"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$SparkProtos$WorldStatistics$Chunk, $SparkProtos$WorldStatistics$Chunk$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Chunk"
import {$SparkProtos$WorldStatistics$RegionOrBuilder, $SparkProtos$WorldStatistics$RegionOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$RegionOrBuilder"
import {$SparkProtos$WorldStatistics$Region, $SparkProtos$WorldStatistics$Region$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Region"

export class $SparkProtos$WorldStatistics$Region$Builder extends $GeneratedMessageLite$Builder<($SparkProtos$WorldStatistics$Region), ($SparkProtos$WorldStatistics$Region$Builder)> implements $SparkProtos$WorldStatistics$RegionOrBuilder {


public "setChunks"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Chunk$Type): $SparkProtos$WorldStatistics$Region$Builder
public "setChunks"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Chunk$Builder$Type): $SparkProtos$WorldStatistics$Region$Builder
public "clearChunks"(): $SparkProtos$WorldStatistics$Region$Builder
public "getChunks"(arg0: integer): $SparkProtos$WorldStatistics$Chunk
public "getChunksList"(): $List<($SparkProtos$WorldStatistics$Chunk)>
public "addAllChunks"(arg0: $Iterable$Type<(any)>): $SparkProtos$WorldStatistics$Region$Builder
public "removeChunks"(arg0: integer): $SparkProtos$WorldStatistics$Region$Builder
public "getChunksCount"(): integer
public "clearTotalEntities"(): $SparkProtos$WorldStatistics$Region$Builder
public "setTotalEntities"(arg0: integer): $SparkProtos$WorldStatistics$Region$Builder
public "addChunks"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Chunk$Builder$Type): $SparkProtos$WorldStatistics$Region$Builder
public "addChunks"(arg0: $SparkProtos$WorldStatistics$Chunk$Type): $SparkProtos$WorldStatistics$Region$Builder
public "addChunks"(arg0: integer, arg1: $SparkProtos$WorldStatistics$Chunk$Type): $SparkProtos$WorldStatistics$Region$Builder
public "addChunks"(arg0: $SparkProtos$WorldStatistics$Chunk$Builder$Type): $SparkProtos$WorldStatistics$Region$Builder
public "getTotalEntities"(): integer
get "chunksList"(): $List<($SparkProtos$WorldStatistics$Chunk)>
get "chunksCount"(): integer
set "totalEntities"(value: integer)
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Region$Builder$Type = ($SparkProtos$WorldStatistics$Region$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics$Region$Builder_ = $SparkProtos$WorldStatistics$Region$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/pointer/$PointerImpl" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Pointer, $Pointer$Type} from "packages/me/lucko/spark/lib/adventure/pointer/$Pointer"

export class $PointerImpl<T> implements $Pointer<(T)> {


public "type"(): $Class<(T)>
public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "key"(): $Key
public "examinableProperties"(): $Stream<(any)>
public static "pointer"<V>(type: $Class$Type<(T)>, key: $Key$Type): $Pointer<(T)>
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PointerImpl$Type<T> = ($PointerImpl<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PointerImpl_<T> = $PointerImpl$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$NBTComponent, $NBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponent"

export interface $NBTComponentBuilder<C extends $NBTComponent<(C), (B)>, B extends $NBTComponentBuilder<(C), (B)>> extends $ComponentBuilder<(C), (B)> {

 "separator"(separator: $ComponentLike$Type): B
 "nbtPath"(nbtPath: string): B
 "interpret"(interpret: boolean): B
 "append"(components: $Iterable$Type<(any)>): B
 "append"(...components: ($ComponentLike$Type)[]): B
 "append"(...components: ($Component$Type)[]): B
 "append"(component: $Component$Type): B
 "append"(component: $ComponentLike$Type): B
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): B
 "apply"(consumer: $Consumer$Type<(any)>): B
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): B
 "style"(style: $Style$Type): B
 "children"(): $List<($Component)>
 "appendNewline"(): B
 "mergeStyle"(that: $Component$Type): B
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): B
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): B
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
 "applyDeep"(action: $Consumer$Type<(any)>): B
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
 "resetStyle"(): B
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): B
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): B
 "decorate"(decoration: $TextDecoration$Type): B
 "font"(font: $Key$Type): B
 "appendSpace"(): B
 "insertion"(insertion: string): B
 "clickEvent"(event: $ClickEvent$Type): B
}

export namespace $NBTComponentBuilder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): C
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NBTComponentBuilder$Type<C, B> = ($NBTComponentBuilder<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NBTComponentBuilder_<C, B> = $NBTComponentBuilder$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EmptyProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $EmptyProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EmptyProto$Type = ($EmptyProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EmptyProto_ = $EmptyProto$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder" {
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $SelectorComponent$Builder extends $ComponentBuilder<($SelectorComponent), ($SelectorComponent$Builder)> {

 "separator"(separator: $ComponentLike$Type): $SelectorComponent$Builder
 "pattern"(pattern: string): $SelectorComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $SelectorComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $SelectorComponent$Builder
 "append"(...components: ($Component$Type)[]): $SelectorComponent$Builder
 "append"(component: $Component$Type): $SelectorComponent$Builder
 "append"(component: $ComponentLike$Type): $SelectorComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $SelectorComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $SelectorComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $SelectorComponent$Builder
 "style"(style: $Style$Type): $SelectorComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $SelectorComponent$Builder
 "mergeStyle"(that: $Component$Type): $SelectorComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $SelectorComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $SelectorComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $SelectorComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $SelectorComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $SelectorComponent$Builder
 "resetStyle"(): $SelectorComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $SelectorComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $SelectorComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $SelectorComponent$Builder
 "font"(font: $Key$Type): $SelectorComponent$Builder
 "appendSpace"(): $SelectorComponent$Builder
 "insertion"(insertion: string): $SelectorComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $SelectorComponent$Builder
}

export namespace $SelectorComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $SelectorComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SelectorComponent$Builder$Type = ($SelectorComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SelectorComponent$Builder_ = $SelectorComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/$ComponentSerializer" {
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentSerializer<I extends $Component, O extends $Component, R> {

 "deserialize"(input: R): O
 "serialize"(component: I): R
 "deserializeOrNull"(input: R): O
 "serializeOr"(component: I, fallback: R): R
 "serializeOrNull"(component: I): R
/**
 * 
 * @deprecated
 */
 "deseializeOrNull"(input: R): O
 "deserializeOr"(input: R, fallback: O): O
}

export namespace $ComponentSerializer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentSerializer$Type<I, O, R> = ($ComponentSerializer<(I), (O), (R)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentSerializer_<I, O, R> = $ComponentSerializer$Type<(I), (O), (R)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$Symbol" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Symbol {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Symbol$Type = ($Symbol);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Symbol_ = $Symbol$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionLite" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"

export class $ExtensionLite<ContainingType extends $MessageLite, Type> {

constructor()

public "getDefaultValue"(): Type
public "getNumber"(): integer
public "getMessageDefaultInstance"(): $MessageLite
public "isRepeated"(): boolean
public "getLiteType"(): $WireFormat$FieldType
get "defaultValue"(): Type
get "number"(): integer
get "messageDefaultInstance"(): $MessageLite
get "repeated"(): boolean
get "liteType"(): $WireFormat$FieldType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionLite$Type<ContainingType, Type> = ($ExtensionLite<(ContainingType), (Type)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionLite_<ContainingType, Type> = $ExtensionLite$Type<(ContainingType), (Type)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$EnumValue" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$OptionOrBuilder, $OptionOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$OptionOrBuilder"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$EnumValue$Builder, $EnumValue$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValue$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$EnumValueOrBuilder, $EnumValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$EnumValueOrBuilder"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export class $EnumValue extends $GeneratedMessageLite<($EnumValue), ($EnumValue$Builder)> implements $EnumValueOrBuilder {
static readonly "NAME_FIELD_NUMBER": integer
static readonly "NUMBER_FIELD_NUMBER": integer
static readonly "OPTIONS_FIELD_NUMBER": integer


public "getName"(): string
public "getNumber"(): integer
public static "parser"(): $Parser<($EnumValue)>
public static "newBuilder"(): $EnumValue$Builder
public static "newBuilder"(arg0: $EnumValue$Type): $EnumValue$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $EnumValue
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "getDefaultInstance"(): $EnumValue
public "getOptions"(arg0: integer): $Option
public "getNameBytes"(): $ByteString
public "getOptionsList"(): $List<($Option)>
public "getOptionsCount"(): integer
public "getOptionsOrBuilderList"(): $List<(any)>
public "getOptionsOrBuilder"(arg0: integer): $OptionOrBuilder
public static "parseFrom"(arg0: (byte)[]): $EnumValue
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "parseFrom"(arg0: $ByteString$Type): $EnumValue
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "parseFrom"(arg0: $ByteBuffer$Type): $EnumValue
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "parseFrom"(arg0: $CodedInputStream$Type): $EnumValue
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $EnumValue
public static "parseFrom"(arg0: $InputStream$Type): $EnumValue
get "name"(): string
get "number"(): integer
get "defaultInstance"(): $EnumValue
get "nameBytes"(): $ByteString
get "optionsList"(): $List<($Option)>
get "optionsCount"(): integer
get "optionsOrBuilderList"(): $List<(any)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $EnumValue$Type = ($EnumValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $EnumValue_ = $EnumValue$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncProfilerJob" {
import {$ThreadDumper, $ThreadDumper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadDumper"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$SampleCollector, $SampleCollector$Type} from "packages/me/lucko/spark/common/sampler/async/$SampleCollector"
import {$AsyncDataAggregator, $AsyncDataAggregator$Type} from "packages/me/lucko/spark/common/sampler/async/$AsyncDataAggregator"

export class $AsyncProfilerJob {


public "start"(): void
public "init"(arg0: $SparkPlatform$Type, arg1: $SampleCollector$Type<(any)>, arg2: $ThreadDumper$Type, arg3: integer, arg4: boolean): void
public "stop"(): void
public "getWindow"(): integer
public "deleteOutputFile"(): void
public "aggregate"(arg0: $AsyncDataAggregator$Type): void
get "window"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncProfilerJob$Type = ($AsyncProfilerJob);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncProfilerJob_ = $AsyncProfilerJob$Type;
}}
declare module "packages/me/lucko/spark/common/ws/$ViewerSocket" {
import {$AbstractSampler, $AbstractSampler$Type} from "packages/me/lucko/spark/common/sampler/$AbstractSampler"
import {$PublicKey, $PublicKey$Type} from "packages/java/security/$PublicKey"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$BytesocksClient, $BytesocksClient$Type} from "packages/me/lucko/spark/lib/bytesocks/$BytesocksClient"
import {$SparkWebSocketProtos$PacketWrapper, $SparkWebSocketProtos$PacketWrapper$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper"
import {$AutoCloseable, $AutoCloseable$Type} from "packages/java/lang/$AutoCloseable"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$Sampler$ExportProps, $Sampler$ExportProps$Type} from "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps"
import {$ViewerSocketConnection$Listener, $ViewerSocketConnection$Listener$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocketConnection$Listener"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"

export class $ViewerSocket implements $ViewerSocketConnection$Listener, $AutoCloseable {

constructor(arg0: $SparkPlatform$Type, arg1: $BytesocksClient$Type, arg2: $Sampler$ExportProps$Type)

public "processSamplerStopped"(arg0: $AbstractSampler$Type): void
public "processWindowRotate"(arg0: $AbstractSampler$Type): void
public "sendUpdatedStatistics"(arg0: $SparkProtos$PlatformStatistics$Type, arg1: $SparkProtos$SystemStatistics$Type): void
public "isOpen"(): boolean
public "close"(): void
public "getPayload"(): $SparkSamplerProtos$SocketChannelInfo
public "sendClientTrustedMessage"(arg0: string): void
public "sendUpdatedSamplerData"(arg0: string): void
public "onPacket"(arg0: $SparkWebSocketProtos$PacketWrapper$Type, arg1: boolean, arg2: $PublicKey$Type): void
public "isKeyTrusted"(arg0: $PublicKey$Type): boolean
get "open"(): boolean
get "payload"(): $SparkSamplerProtos$SocketChannelInfo
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ViewerSocket$Type = ($ViewerSocket);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ViewerSocket_ = $ViewerSocket$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$CheckReturnValue" {
import {$Annotation, $Annotation$Type} from "packages/java/lang/annotation/$Annotation"
import {$Class, $Class$Type} from "packages/java/lang/$Class"

export interface $CheckReturnValue extends $Annotation {

 "equals"(arg0: any): boolean
 "toString"(): string
 "hashCode"(): integer
 "annotationType"(): $Class<(any)>
}

export namespace $CheckReturnValue {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CheckReturnValue$Type = ($CheckReturnValue);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CheckReturnValue_ = $CheckReturnValue$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite" {
import {$WireFormat$FieldType, $WireFormat$FieldType$Type} from "packages/me/lucko/spark/lib/protobuf/$WireFormat$FieldType"
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$Internal$EnumLiteMap, $Internal$EnumLiteMap$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$EnumLiteMap"
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$CodedOutputStream, $CodedOutputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedOutputStream"
import {$GeneratedMessageLite$GeneratedExtension, $GeneratedMessageLite$GeneratedExtension$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$GeneratedExtension"
import {$AbstractMessageLite, $AbstractMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite"

export class $GeneratedMessageLite<MessageType extends $GeneratedMessageLite<(MessageType), (BuilderType)>, BuilderType extends $GeneratedMessageLite$Builder<(MessageType), (BuilderType)>> extends $AbstractMessageLite<(MessageType), (BuilderType)> {

constructor()

public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "writeTo"(arg0: $CodedOutputStream$Type): void
public "getSerializedSize"(): integer
public "newBuilderForType"(): BuilderType
public "getParserForType"(): $Parser<(MessageType)>
public static "newSingularGeneratedExtension"<ContainingType extends $MessageLite, Type>(arg0: ContainingType, arg1: Type, arg2: $MessageLite$Type, arg3: $Internal$EnumLiteMap$Type<(any)>, arg4: integer, arg5: $WireFormat$FieldType$Type, arg6: $Class$Type<(any)>): $GeneratedMessageLite$GeneratedExtension<(ContainingType), (Type)>
public static "newRepeatedGeneratedExtension"<ContainingType extends $MessageLite, Type>(arg0: ContainingType, arg1: $MessageLite$Type, arg2: $Internal$EnumLiteMap$Type<(any)>, arg3: integer, arg4: $WireFormat$FieldType$Type, arg5: boolean, arg6: $Class$Type<(any)>): $GeneratedMessageLite$GeneratedExtension<(ContainingType), (Type)>
public "toBuilder"(): BuilderType
public "isInitialized"(): boolean
get "serializedSize"(): integer
get "parserForType"(): $Parser<(MessageType)>
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $GeneratedMessageLite$Type<MessageType, BuilderType> = ($GeneratedMessageLite<(MessageType), (BuilderType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $GeneratedMessageLite_<MessageType, BuilderType> = $GeneratedMessageLite$Type<(MessageType), (BuilderType)>;
}}
declare module "packages/me/lucko/spark/forge/$ForgePlatformInfo" {
import {$PlatformInfo$Data, $PlatformInfo$Data$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo$Data"
import {$PlatformInfo, $PlatformInfo$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo"
import {$PlatformInfo$Type, $PlatformInfo$Type$Type} from "packages/me/lucko/spark/common/platform/$PlatformInfo$Type"

export class $ForgePlatformInfo implements $PlatformInfo {

constructor(arg0: $PlatformInfo$Type$Type)

public "getName"(): string
public "getType"(): $PlatformInfo$Type
public "getVersion"(): string
public "getMinecraftVersion"(): string
public "toData"(): $PlatformInfo$Data
public "getSparkVersion"(): integer
get "name"(): string
get "type"(): $PlatformInfo$Type
get "version"(): string
get "minecraftVersion"(): string
get "sparkVersion"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ForgePlatformInfo$Type = ($ForgePlatformInfo);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ForgePlatformInfo_ = $ForgePlatformInfo$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$NBTComponentBuilder, $NBTComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentBuilder"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $StorageNBTComponent$Builder extends $NBTComponentBuilder<($StorageNBTComponent), ($StorageNBTComponent$Builder)> {

 "storage"(storage: $Key$Type): $StorageNBTComponent$Builder
 "separator"(separator: $ComponentLike$Type): $StorageNBTComponent$Builder
 "nbtPath"(nbtPath: string): $StorageNBTComponent$Builder
 "interpret"(interpret: boolean): $StorageNBTComponent$Builder
 "append"(components: $Iterable$Type<(any)>): $StorageNBTComponent$Builder
 "append"(...components: ($ComponentLike$Type)[]): $StorageNBTComponent$Builder
 "append"(...components: ($Component$Type)[]): $StorageNBTComponent$Builder
 "append"(component: $Component$Type): $StorageNBTComponent$Builder
 "append"(component: $ComponentLike$Type): $StorageNBTComponent$Builder
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $StorageNBTComponent$Builder
 "apply"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent$Builder
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $StorageNBTComponent$Builder
 "style"(style: $Style$Type): $StorageNBTComponent$Builder
 "children"(): $List<($Component)>
 "appendNewline"(): $StorageNBTComponent$Builder
 "mergeStyle"(that: $Component$Type): $StorageNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $StorageNBTComponent$Builder
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $StorageNBTComponent$Builder
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $StorageNBTComponent$Builder
 "applyDeep"(action: $Consumer$Type<(any)>): $StorageNBTComponent$Builder
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): $StorageNBTComponent$Builder
 "resetStyle"(): $StorageNBTComponent$Builder
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): $StorageNBTComponent$Builder
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $StorageNBTComponent$Builder
 "decorate"(decoration: $TextDecoration$Type): $StorageNBTComponent$Builder
 "font"(font: $Key$Type): $StorageNBTComponent$Builder
 "appendSpace"(): $StorageNBTComponent$Builder
 "insertion"(insertion: string): $StorageNBTComponent$Builder
 "clickEvent"(event: $ClickEvent$Type): $StorageNBTComponent$Builder
}

export namespace $StorageNBTComponent$Builder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StorageNBTComponent$Builder$Type = ($StorageNBTComponent$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StorageNBTComponent$Builder_ = $StorageNBTComponent$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/$Adventure" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $Adventure {
static readonly "NAMESPACE": string


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Adventure$Type = ($Adventure);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Adventure_ = $Adventure$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Value$KindCase" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $Value$KindCase extends $Enum<($Value$KindCase)> {
static readonly "NULL_VALUE": $Value$KindCase
static readonly "NUMBER_VALUE": $Value$KindCase
static readonly "STRING_VALUE": $Value$KindCase
static readonly "BOOL_VALUE": $Value$KindCase
static readonly "STRUCT_VALUE": $Value$KindCase
static readonly "LIST_VALUE": $Value$KindCase
static readonly "KIND_NOT_SET": $Value$KindCase


public static "values"(): ($Value$KindCase)[]
/**
 * 
 * @deprecated
 */
public static "valueOf"(arg0: integer): $Value$KindCase
public static "valueOf"(arg0: string): $Value$KindCase
public "getNumber"(): integer
public static "forNumber"(arg0: integer): $Value$KindCase
get "number"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Value$KindCase$Type = (("list_value") | ("number_value") | ("string_value") | ("kind_not_set") | ("null_value") | ("bool_value") | ("struct_value")) | ($Value$KindCase);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Value$KindCase_ = $Value$KindCase$Type;
}}
declare module "packages/me/lucko/spark/common/command/modules/$SamplerModule" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Command, $Command$Type} from "packages/me/lucko/spark/common/command/$Command"
import {$CommandModule, $CommandModule$Type} from "packages/me/lucko/spark/common/command/$CommandModule"

export class $SamplerModule implements $CommandModule {

constructor()

public "registerCommands"(arg0: $Consumer$Type<($Command$Type)>): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SamplerModule$Type = ($SamplerModule);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SamplerModule_ = $SamplerModule$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/renderer/$ComponentRenderer" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export interface $ComponentRenderer<C> {

 "render"(component: $Component$Type, context: C): $Component
 "mapContext"<T>(transformer: $Function$Type<(T), (C)>): $ComponentRenderer<(T)>

(component: $Component$Type, context: C): $Component
}

export namespace $ComponentRenderer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentRenderer$Type<C> = ($ComponentRenderer<(C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentRenderer_<C> = $ComponentRenderer$Type<(C)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder" {
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"

export interface $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder extends $MessageLiteOrBuilder {

 "getPlatform"(): $SparkProtos$PlatformStatistics
 "hasPlatform"(): boolean
 "hasSystem"(): boolean
 "getSystem"(): $SparkProtos$SystemStatistics
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder$Type = ($SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder_ = $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/jfr/$Dictionary" {
import {$Dictionary$Visitor, $Dictionary$Visitor$Type} from "packages/me/lucko/spark/common/sampler/async/jfr/$Dictionary$Visitor"

export class $Dictionary<T> {

constructor()

public "get"(arg0: long): T
public "put"(arg0: long, arg1: T): void
public "clear"(): void
public "size"(): integer
public "forEach"(arg0: $Dictionary$Visitor$Type<(T)>): void
public "preallocate"(arg0: integer): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Dictionary$Type<T> = ($Dictionary<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Dictionary_<T> = $Dictionary$Type<(T)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$ClassTooLargeException" {
import {$IndexOutOfBoundsException, $IndexOutOfBoundsException$Type} from "packages/java/lang/$IndexOutOfBoundsException"

export class $ClassTooLargeException extends $IndexOutOfBoundsException {

constructor(arg0: string, arg1: integer)

public "getClassName"(): string
public "getConstantPoolCount"(): integer
get "className"(): string
get "constantPoolCount"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClassTooLargeException$Type = ($ClassTooLargeException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClassTooLargeException_ = $ClassTooLargeException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionSchemaLite" {
import {$GeneratedMessageLite$ExtensionDescriptor, $GeneratedMessageLite$ExtensionDescriptor$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$ExtensionDescriptor"
import {$ExtensionSchema, $ExtensionSchema$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionSchema"

export class $ExtensionSchemaLite extends $ExtensionSchema<($GeneratedMessageLite$ExtensionDescriptor)> {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionSchemaLite$Type = ($ExtensionSchemaLite);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionSchemaLite_ = $ExtensionSchemaLite$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $PrimitiveNonBoxingCollection {

}

export namespace $PrimitiveNonBoxingCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PrimitiveNonBoxingCollection$Type = ($PrimitiveNonBoxingCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PrimitiveNonBoxingCollection_ = $PrimitiveNonBoxingCollection$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps" {
import {$ClassSourceLookup, $ClassSourceLookup$Type} from "packages/me/lucko/spark/common/sampler/source/$ClassSourceLookup"
import {$SparkSamplerProtos$SocketChannelInfo, $SparkSamplerProtos$SocketChannelInfo$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SocketChannelInfo"
import {$Supplier, $Supplier$Type} from "packages/java/util/function/$Supplier"
import {$MergeMode, $MergeMode$Type} from "packages/me/lucko/spark/common/sampler/node/$MergeMode"
import {$CommandSender$Data, $CommandSender$Data$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender$Data"

export class $Sampler$ExportProps {

constructor()

public "comment"(arg0: string): $Sampler$ExportProps
public "comment"(): string
public "mergeMode"(): $Supplier<($MergeMode)>
public "mergeMode"(arg0: $Supplier$Type<($MergeMode$Type)>): $Sampler$ExportProps
public "classSourceLookup"(): $Supplier<($ClassSourceLookup)>
public "classSourceLookup"(arg0: $Supplier$Type<($ClassSourceLookup$Type)>): $Sampler$ExportProps
public "channelInfo"(arg0: $SparkSamplerProtos$SocketChannelInfo$Type): $Sampler$ExportProps
public "channelInfo"(): $SparkSamplerProtos$SocketChannelInfo
public "creator"(arg0: $CommandSender$Data$Type): $Sampler$ExportProps
public "creator"(): $CommandSender$Data
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Sampler$ExportProps$Type = ($Sampler$ExportProps);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Sampler$ExportProps_ = $Sampler$ExportProps$Type;
}}
declare module "packages/me/lucko/spark/common/util/$BytebinClient" {
import {$BytebinClient$Content, $BytebinClient$Content$Type} from "packages/me/lucko/spark/common/util/$BytebinClient$Content"
import {$AbstractMessageLite, $AbstractMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite"

export class $BytebinClient {

constructor(arg0: string, arg1: string)

public "postContent"(arg0: $AbstractMessageLite$Type<(any), (any)>, arg1: string): $BytebinClient$Content
public "postContent"(arg0: $AbstractMessageLite$Type<(any), (any)>, arg1: string, arg2: string): $BytebinClient$Content
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BytebinClient$Type = ($BytebinClient);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BytebinClient_ = $BytebinClient$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/renderer/$TranslatableComponentRenderer" {
import {$AbstractComponentRenderer, $AbstractComponentRenderer$Type} from "packages/me/lucko/spark/lib/adventure/text/renderer/$AbstractComponentRenderer"
import {$Translator, $Translator$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translator"
import {$Locale, $Locale$Type} from "packages/java/util/$Locale"

export class $TranslatableComponentRenderer<C> extends $AbstractComponentRenderer<(C)> {

constructor()

public static "usingTranslationSource"(source: $Translator$Type): $TranslatableComponentRenderer<($Locale)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslatableComponentRenderer$Type<C> = ($TranslatableComponentRenderer<(C)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslatableComponentRenderer_<C> = $TranslatableComponentRenderer$Type<(C)>;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$WireFormat$JavaType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $WireFormat$JavaType extends $Enum<($WireFormat$JavaType)> {
static readonly "INT": $WireFormat$JavaType
static readonly "LONG": $WireFormat$JavaType
static readonly "FLOAT": $WireFormat$JavaType
static readonly "DOUBLE": $WireFormat$JavaType
static readonly "BOOLEAN": $WireFormat$JavaType
static readonly "STRING": $WireFormat$JavaType
static readonly "BYTE_STRING": $WireFormat$JavaType
static readonly "ENUM": $WireFormat$JavaType
static readonly "MESSAGE": $WireFormat$JavaType


public static "values"(): ($WireFormat$JavaType)[]
public static "valueOf"(arg0: string): $WireFormat$JavaType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WireFormat$JavaType$Type = (("boolean") | ("string") | ("double") | ("byte_string") | ("float") | ("message") | ("int") | ("long") | ("enum")) | ($WireFormat$JavaType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WireFormat$JavaType_ = $WireFormat$JavaType$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/serializer/gson/$TextColorSerializer" {
import {$JsonReader, $JsonReader$Type} from "packages/com/google/gson/stream/$JsonReader"
import {$TypeAdapter, $TypeAdapter$Type} from "packages/com/google/gson/$TypeAdapter"
import {$JsonWriter, $JsonWriter$Type} from "packages/com/google/gson/stream/$JsonWriter"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"

export class $TextColorSerializer extends $TypeAdapter<($TextColor)> {


public "write"(out: $JsonWriter$Type, value: $TextColor$Type): void
public "read"(arg0: $JsonReader$Type): $TextColor
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextColorSerializer$Type = ($TextColorSerializer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextColorSerializer_ = $TextColorSerializer$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ProtocolStringList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ProtocolStringList extends $List<(string)> {

 "asByteStringList"(): $List<($ByteString)>
 "add"(arg0: integer, arg1: string): void
 "add"(arg0: string): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): string
 "get"(arg0: integer): string
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(string)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(string)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(string)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(string)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: string): string
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(string)>
 "listIterator"(): $ListIterator<(string)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(string)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(string)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ProtocolStringList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string): $List<(string)>
function of<E>(arg0: string, arg1: string): $List<(string)>
function of<E>(arg0: string): $List<(string)>
function of<E>(): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string): $List<(string)>
function of<E>(arg0: string, arg1: string, arg2: string, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string): $List<(string)>
function of<E>(...arg0: (string)[]): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtocolStringList$Type = ($ProtocolStringList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtocolStringList_ = $ProtocolStringList$Type;
}}
declare module "packages/me/lucko/spark/common/util/$StatisticFormatter" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$MemoryUsage, $MemoryUsage$Type} from "packages/java/lang/management/$MemoryUsage"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$DoubleAverageInfo, $DoubleAverageInfo$Type} from "packages/me/lucko/spark/api/statistic/misc/$DoubleAverageInfo"

export class $StatisticFormatter extends $Enum<($StatisticFormatter)> {


public static "formatTickDuration"(arg0: double): $TextComponent
public static "values"(): ($StatisticFormatter)[]
public static "valueOf"(arg0: string): $StatisticFormatter
public static "formatPingRtt"(arg0: double): $TextComponent
public static "formatTps"(arg0: double): $TextComponent
public static "formatCpuUsage"(arg0: double): $TextComponent
public static "formatPingRtts"(arg0: double, arg1: double, arg2: double, arg3: double): $TextComponent
public static "generateMemoryUsageDiagram"(arg0: $MemoryUsage$Type, arg1: integer): $TextComponent
public static "generateMemoryPoolDiagram"(arg0: $MemoryUsage$Type, arg1: $MemoryUsage$Type, arg2: integer): $TextComponent
public static "generateDiskUsageDiagram"(arg0: double, arg1: double, arg2: integer): $TextComponent
public static "formatTickDurations"(arg0: $DoubleAverageInfo$Type): $TextComponent
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatisticFormatter$Type = (never) | ($StatisticFormatter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatisticFormatter_ = $StatisticFormatter$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/enums/$CloseHandshakeType" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"

export class $CloseHandshakeType extends $Enum<($CloseHandshakeType)> {
static readonly "NONE": $CloseHandshakeType
static readonly "ONEWAY": $CloseHandshakeType
static readonly "TWOWAY": $CloseHandshakeType


public static "values"(): ($CloseHandshakeType)[]
public static "valueOf"(arg0: string): $CloseHandshakeType
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CloseHandshakeType$Type = (("twoway") | ("none") | ("oneway")) | ($CloseHandshakeType);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CloseHandshakeType_ = $CloseHandshakeType$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$PlatformStatistics$MsptOrBuilder, $SparkProtos$PlatformStatistics$MsptOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$MsptOrBuilder"
import {$SparkProtos$PlatformStatistics$Mspt$Builder, $SparkProtos$PlatformStatistics$Mspt$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Mspt$Builder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$SparkProtos$RollingAverageValues, $SparkProtos$RollingAverageValues$Type} from "packages/me/lucko/spark/proto/$SparkProtos$RollingAverageValues"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$PlatformStatistics$Mspt extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Mspt), ($SparkProtos$PlatformStatistics$Mspt$Builder)> implements $SparkProtos$PlatformStatistics$MsptOrBuilder {
static readonly "LAST1M_FIELD_NUMBER": integer
static readonly "LAST5M_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Mspt)>
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Mspt$Type): $SparkProtos$PlatformStatistics$Mspt$Builder
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Mspt$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Mspt
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Mspt
public "getLast5M"(): $SparkProtos$RollingAverageValues
public "getLast1M"(): $SparkProtos$RollingAverageValues
public "hasLast1M"(): boolean
public "hasLast5M"(): boolean
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Mspt
get "last5M"(): $SparkProtos$RollingAverageValues
get "last1M"(): $SparkProtos$RollingAverageValues
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Mspt$Type = ($SparkProtos$PlatformStatistics$Mspt);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Mspt_ = $SparkProtos$PlatformStatistics$Mspt$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/net/$NetworkInterfaceAverages" {
import {$Direction, $Direction$Type} from "packages/me/lucko/spark/common/monitor/net/$Direction"
import {$RollingAverage, $RollingAverage$Type} from "packages/me/lucko/spark/common/util/$RollingAverage"

export class $NetworkInterfaceAverages {


public "bytesPerSecond"(arg0: $Direction$Type): $RollingAverage
public "packetsPerSecond"(arg0: $Direction$Type): $RollingAverage
public "txBytesPerSecond"(): $RollingAverage
public "rxBytesPerSecond"(): $RollingAverage
public "rxPacketsPerSecond"(): $RollingAverage
public "txPacketsPerSecond"(): $RollingAverage
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $NetworkInterfaceAverages$Type = ($NetworkInterfaceAverages);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $NetworkInterfaceAverages_ = $NetworkInterfaceAverages$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$TextFormatEscaper" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $TextFormatEscaper {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextFormatEscaper$Type = ($TextFormatEscaper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextFormatEscaper_ = $TextFormatEscaper$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncDataAggregator" {
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$ProfileSegment, $ProfileSegment$Type} from "packages/me/lucko/spark/common/sampler/async/$ProfileSegment"
import {$AbstractDataAggregator, $AbstractDataAggregator$Type} from "packages/me/lucko/spark/common/sampler/aggregator/$AbstractDataAggregator"

export class $AsyncDataAggregator extends $AbstractDataAggregator {


public "insertData"(arg0: $ProfileSegment$Type, arg1: integer): void
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
get "metadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncDataAggregator$Type = ($AsyncDataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncDataAggregator_ = $AsyncDataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$WrappedIOException" {
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$IOException, $IOException$Type} from "packages/java/io/$IOException"

export class $WrappedIOException extends $Exception {

constructor(arg0: $WebSocket$Type, arg1: $IOException$Type)

public "getConnection"(): $WebSocket
public "getIOException"(): $IOException
get "connection"(): $WebSocket
get "iOException"(): $IOException
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WrappedIOException$Type = ($WrappedIOException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WrappedIOException_ = $WrappedIOException$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Int64Value$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$Int64ValueOrBuilder, $Int64ValueOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$Int64ValueOrBuilder"
import {$Int64Value, $Int64Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Int64Value"

export class $Int64Value$Builder extends $GeneratedMessageLite$Builder<($Int64Value), ($Int64Value$Builder)> implements $Int64ValueOrBuilder {


public "getValue"(): long
public "setValue"(arg0: long): $Int64Value$Builder
public "clearValue"(): $Int64Value$Builder
get "value"(): long
set "value"(value: long)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int64Value$Builder$Type = ($Int64Value$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int64Value$Builder_ = $Int64Value$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$TimestampProto" {
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"

export class $TimestampProto {


public static "registerAllExtensions"(arg0: $ExtensionRegistryLite$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TimestampProto$Type = ($TimestampProto);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TimestampProto_ = $TimestampProto$Type;
}}
declare module "packages/me/lucko/spark/common/util/$Configuration" {
import {$Path, $Path$Type} from "packages/java/nio/file/$Path"
import {$List, $List$Type} from "packages/java/util/$List"

export class $Configuration {

constructor(arg0: $Path$Type)

public "remove"(arg0: string): void
public "getBoolean"(arg0: string, arg1: boolean): boolean
public "load"(): void
public "contains"(arg0: string): boolean
public "save"(): void
public "setBoolean"(arg0: string, arg1: boolean): void
public "getInteger"(arg0: string, arg1: integer): integer
public "getString"(arg0: string, arg1: string): string
public "setInteger"(arg0: string, arg1: integer): void
public "setStringList"(arg0: string, arg1: $List$Type<(string)>): void
public "setString"(arg0: string, arg1: string): void
public "getStringList"(arg0: string): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Configuration$Type = ($Configuration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Configuration_ = $Configuration$Type;
}}
declare module "packages/me/lucko/spark/lib/asm/signature/$SignatureWriter" {
import {$SignatureVisitor, $SignatureVisitor$Type} from "packages/me/lucko/spark/lib/asm/signature/$SignatureVisitor"

export class $SignatureWriter extends $SignatureVisitor {
static readonly "EXTENDS": character
static readonly "SUPER": character
static readonly "INSTANCEOF": character

constructor()

public "toString"(): string
public "visitEnd"(): void
public "visitInterface"(): $SignatureVisitor
public "visitParameterType"(): $SignatureVisitor
public "visitExceptionType"(): $SignatureVisitor
public "visitClassBound"(): $SignatureVisitor
public "visitBaseType"(arg0: character): void
public "visitSuperclass"(): $SignatureVisitor
public "visitTypeVariable"(arg0: string): void
public "visitArrayType"(): $SignatureVisitor
public "visitTypeArgument"(): void
public "visitTypeArgument"(arg0: character): $SignatureVisitor
public "visitReturnType"(): $SignatureVisitor
public "visitClassType"(arg0: string): void
public "visitInnerClassType"(arg0: string): void
public "visitInterfaceBound"(): $SignatureVisitor
public "visitFormalTypeParameter"(arg0: string): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SignatureWriter$Type = ($SignatureWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SignatureWriter_ = $SignatureWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$BlockNBTComponent$WorldPos$Coordinate, $BlockNBTComponent$WorldPos$Coordinate$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$WorldPos$Coordinate"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$NBTComponentImpl, $NBTComponentImpl$Type} from "packages/me/lucko/spark/lib/adventure/text/$NBTComponentImpl"

export class $BlockNBTComponentImpl extends $NBTComponentImpl<($BlockNBTComponent), ($BlockNBTComponent$Builder)> implements $BlockNBTComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "pos"(pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public "pos"(): $BlockNBTComponent$Pos
public "separator"(): $Component
public "style"(style: $Style$Type): $BlockNBTComponent
public "interpret"(interpret: boolean): $BlockNBTComponent
public "examinableProperties"(): $Stream<(any)>
public "absoluteWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent
public "relativeWorldPos"(x: integer, y: integer, z: integer): $BlockNBTComponent
public "localPos"(left: double, up: double, forwards: double): $BlockNBTComponent
public "worldPos"(x: $BlockNBTComponent$WorldPos$Coordinate$Type, y: $BlockNBTComponent$WorldPos$Coordinate$Type, z: $BlockNBTComponent$WorldPos$Coordinate$Type): $BlockNBTComponent
public "append"(component: $Component$Type): $BlockNBTComponent
public "append"(like: $ComponentLike$Type): $BlockNBTComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $BlockNBTComponent
public "color"(color: $TextColor$Type): $BlockNBTComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $BlockNBTComponent
public "style"(style: $Style$Builder$Type): $BlockNBTComponent
public "mergeStyle"(that: $Component$Type): $BlockNBTComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $BlockNBTComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $BlockNBTComponent
public "colorIfAbsent"(color: $TextColor$Type): $BlockNBTComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $BlockNBTComponent
public "clickEvent"(event: $ClickEvent$Type): $BlockNBTComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $BlockNBTComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $BlockNBTComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BlockNBTComponentImpl$Type = ($BlockNBTComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BlockNBTComponentImpl_ = $BlockNBTComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/common/monitor/$WindowsWmic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$List, $List$Type} from "packages/java/util/$List"

export class $WindowsWmic extends $Enum<($WindowsWmic)> {
static readonly "CPU_GET_NAME": $WindowsWmic
static readonly "OS_GET_CAPTION_AND_VERSION": $WindowsWmic


public static "values"(): ($WindowsWmic)[]
public static "valueOf"(arg0: string): $WindowsWmic
public "read"(): $List<(string)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WindowsWmic$Type = (("os_get_caption_and_version") | ("cpu_get_name")) | ($WindowsWmic);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WindowsWmic_ = $WindowsWmic$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/extensions/permessage_deflate/$PerMessageDeflateExtension" {
import {$Deflater, $Deflater$Type} from "packages/java/util/zip/$Deflater"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$CompressionExtension, $CompressionExtension$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$CompressionExtension"
import {$IExtension, $IExtension$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/extensions/$IExtension"
import {$Inflater, $Inflater$Type} from "packages/java/util/zip/$Inflater"

export class $PerMessageDeflateExtension extends $CompressionExtension {

constructor()

public "acceptProvidedExtensionAsServer"(arg0: string): boolean
public "getProvidedExtensionAsServer"(): string
public "acceptProvidedExtensionAsClient"(arg0: string): boolean
public "getProvidedExtensionAsClient"(): string
public "toString"(): string
public "setThreshold"(arg0: integer): void
public "getInflater"(): $Inflater
public "getDeflater"(): $Deflater
public "encodeFrame"(arg0: $Framedata$Type): void
public "decodeFrame"(arg0: $Framedata$Type): void
public "copyInstance"(): $IExtension
public "isFrameValid"(arg0: $Framedata$Type): void
public "getThreshold"(): integer
public "setClientNoContextTakeover"(arg0: boolean): void
public "isClientNoContextTakeover"(): boolean
public "isServerNoContextTakeover"(): boolean
public "setServerNoContextTakeover"(arg0: boolean): void
public "setInflater"(arg0: $Inflater$Type): void
public "setDeflater"(arg0: $Deflater$Type): void
get "providedExtensionAsServer"(): string
get "providedExtensionAsClient"(): string
set "threshold"(value: integer)
get "inflater"(): $Inflater
get "deflater"(): $Deflater
get "threshold"(): integer
set "clientNoContextTakeover"(value: boolean)
get "clientNoContextTakeover"(): boolean
get "serverNoContextTakeover"(): boolean
set "serverNoContextTakeover"(value: boolean)
set "inflater"(value: $Inflater$Type)
set "deflater"(value: $Deflater$Type)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $PerMessageDeflateExtension$Type = ($PerMessageDeflateExtension);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $PerMessageDeflateExtension_ = $PerMessageDeflateExtension$Type;
}}
declare module "packages/me/lucko/spark/common/command/$CommandResponseHandler" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$CommandSender, $CommandSender$Type} from "packages/me/lucko/spark/common/command/sender/$CommandSender"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"

export class $CommandResponseHandler {

constructor(arg0: $SparkPlatform$Type, arg1: $CommandSender$Type)

public "broadcast"(arg0: $Iterable$Type<($Component$Type)>): void
public "broadcast"(arg0: $Component$Type): void
public "replyPrefixed"(arg0: $Component$Type): void
public "broadcastPrefixed"(arg0: $Component$Type): void
public "setCommandPrimaryAlias"(arg0: string): void
public static "applyPrefix"(arg0: $Component$Type): $Component
public "allSenders"(arg0: $Consumer$Type<(any)>): void
public "reply"(arg0: $Iterable$Type<($Component$Type)>): void
public "reply"(arg0: $Component$Type): void
public "sender"(): $CommandSender
set "commandPrimaryAlias"(value: string)
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $CommandResponseHandler$Type = ($CommandResponseHandler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $CommandResponseHandler_ = $CommandResponseHandler$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Struct" {
import {$Struct$Builder, $Struct$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$Struct$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$StructOrBuilder, $StructOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$StructOrBuilder"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$Value, $Value$Type} from "packages/me/lucko/spark/lib/protobuf/$Value"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $Struct extends $GeneratedMessageLite<($Struct), ($Struct$Builder)> implements $StructOrBuilder {
static readonly "FIELDS_FIELD_NUMBER": integer


public "getFieldsOrDefault"(arg0: string, arg1: $Value$Type): $Value
public "containsFields"(arg0: string): boolean
public "getFieldsOrThrow"(arg0: string): $Value
public "getFieldsCount"(): integer
public "getFieldsMap"(): $Map<(string), ($Value)>
/**
 * 
 * @deprecated
 */
public "getFields"(): $Map<(string), ($Value)>
public static "parser"(): $Parser<($Struct)>
public static "newBuilder"(): $Struct$Builder
public static "newBuilder"(arg0: $Struct$Type): $Struct$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $Struct
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Struct
public static "getDefaultInstance"(): $Struct
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $Struct
public static "parseFrom"(arg0: $ByteString$Type): $Struct
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $Struct
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $Struct
public static "parseFrom"(arg0: $ByteBuffer$Type): $Struct
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $Struct
public static "parseFrom"(arg0: $InputStream$Type): $Struct
public static "parseFrom"(arg0: (byte)[]): $Struct
public static "parseFrom"(arg0: $CodedInputStream$Type): $Struct
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $Struct
get "fieldsCount"(): integer
get "fieldsMap"(): $Map<(string), ($Value)>
get "fields"(): $Map<(string), ($Value)>
get "defaultInstance"(): $Struct
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Struct$Type = ($Struct);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Struct_ = $Struct$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/java/$TickedDataAggregator" {
import {$ExecutorService, $ExecutorService$Type} from "packages/java/util/concurrent/$ExecutorService"
import {$ThreadInfo, $ThreadInfo$Type} from "packages/java/lang/management/$ThreadInfo"
import {$JavaDataAggregator, $JavaDataAggregator$Type} from "packages/me/lucko/spark/common/sampler/java/$JavaDataAggregator"
import {$ThreadGrouper, $ThreadGrouper$Type} from "packages/me/lucko/spark/common/sampler/$ThreadGrouper"
import {$SparkSamplerProtos$SamplerMetadata$DataAggregator, $SparkSamplerProtos$SamplerMetadata$DataAggregator$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerMetadata$DataAggregator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ThreadNode, $ThreadNode$Type} from "packages/me/lucko/spark/common/sampler/node/$ThreadNode"
import {$WindowStatisticsCollector$ExplicitTickCounter, $WindowStatisticsCollector$ExplicitTickCounter$Type} from "packages/me/lucko/spark/common/sampler/window/$WindowStatisticsCollector$ExplicitTickCounter"
import {$TickHook, $TickHook$Type} from "packages/me/lucko/spark/common/tick/$TickHook"

export class $TickedDataAggregator extends $JavaDataAggregator {

constructor(arg0: $ExecutorService$Type, arg1: $ThreadGrouper$Type, arg2: integer, arg3: boolean, arg4: boolean, arg5: $TickHook$Type, arg6: integer)

public "setTickCounter"(arg0: $WindowStatisticsCollector$ExplicitTickCounter$Type): void
public "exportData"(): $List<($ThreadNode)>
public "insertData"(arg0: $ThreadInfo$Type, arg1: integer): void
public "getMetadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
set "tickCounter"(value: $WindowStatisticsCollector$ExplicitTickCounter$Type)
get "metadata"(): $SparkSamplerProtos$SamplerMetadata$DataAggregator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TickedDataAggregator$Type = ($TickedDataAggregator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TickedDataAggregator_ = $TickedDataAggregator$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/key/$Namespaced" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Namespaced {

 "namespace"(): string

(): string
}

export namespace $Namespaced {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Namespaced$Type = ($Namespaced);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Namespaced_ = $Namespaced$Type;
}}
declare module "packages/me/lucko/spark/common/tick/$AbstractTickReporter" {
import {$TickReporter$Callback, $TickReporter$Callback$Type} from "packages/me/lucko/spark/common/tick/$TickReporter$Callback"
import {$TickReporter, $TickReporter$Type} from "packages/me/lucko/spark/common/tick/$TickReporter"

export class $AbstractTickReporter implements $TickReporter {

constructor()

public "removeCallback"(arg0: $TickReporter$Callback$Type): void
public "addCallback"(arg0: $TickReporter$Callback$Type): void
public "start"(): void
public "close"(): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractTickReporter$Type = ($AbstractTickReporter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractTickReporter_ = $AbstractTickReporter$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/async/$AsyncSampler" {
import {$SamplerSettings, $SamplerSettings$Type} from "packages/me/lucko/spark/common/sampler/$SamplerSettings"
import {$ViewerSocket, $ViewerSocket$Type} from "packages/me/lucko/spark/common/ws/$ViewerSocket"
import {$SamplerMode, $SamplerMode$Type} from "packages/me/lucko/spark/common/sampler/$SamplerMode"
import {$AbstractSampler, $AbstractSampler$Type} from "packages/me/lucko/spark/common/sampler/$AbstractSampler"
import {$SparkPlatform, $SparkPlatform$Type} from "packages/me/lucko/spark/common/$SparkPlatform"
import {$SampleCollector, $SampleCollector$Type} from "packages/me/lucko/spark/common/sampler/async/$SampleCollector"
import {$Sampler$ExportProps, $Sampler$ExportProps$Type} from "packages/me/lucko/spark/common/sampler/$Sampler$ExportProps"
import {$SparkSamplerProtos$SamplerData, $SparkSamplerProtos$SamplerData$Type} from "packages/me/lucko/spark/proto/$SparkSamplerProtos$SamplerData"

export class $AsyncSampler extends $AbstractSampler {

constructor(arg0: $SparkPlatform$Type, arg1: $SamplerSettings$Type, arg2: $SampleCollector$Type<(any)>)

public "start"(): void
public "stop"(arg0: boolean): void
public "toProto"(arg0: $SparkPlatform$Type, arg1: $Sampler$ExportProps$Type): $SparkSamplerProtos$SamplerData
public "attachSocket"(arg0: $ViewerSocket$Type): void
public "getMode"(): $SamplerMode
get "mode"(): $SamplerMode
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AsyncSampler$Type = ($AsyncSampler);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AsyncSampler_ = $AsyncSampler$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$SocketChannelIOHelper" {
import {$ByteChannel, $ByteChannel$Type} from "packages/java/nio/channels/$ByteChannel"
import {$WebSocketImpl, $WebSocketImpl$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketImpl"
import {$WrappedByteChannel, $WrappedByteChannel$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WrappedByteChannel"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SocketChannelIOHelper {


public static "read"(arg0: $ByteBuffer$Type, arg1: $WebSocketImpl$Type, arg2: $ByteChannel$Type): boolean
public static "batch"(arg0: $WebSocketImpl$Type, arg1: $ByteChannel$Type): boolean
public static "readMore"(arg0: $ByteBuffer$Type, arg1: $WebSocketImpl$Type, arg2: $WrappedByteChannel$Type): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SocketChannelIOHelper$Type = ($SocketChannelIOHelper);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SocketChannelIOHelper_ = $SocketChannelIOHelper$Type;
}}
declare module "packages/me/lucko/spark/common/sampler/node/$StackTraceNode$Describer" {
import {$StackTraceNode$Description, $StackTraceNode$Description$Type} from "packages/me/lucko/spark/common/sampler/node/$StackTraceNode$Description"

export interface $StackTraceNode$Describer<T> {

 "describe"(arg0: T, arg1: T): $StackTraceNode$Description

(arg0: T, arg1: T): $StackTraceNode$Description
}

export namespace $StackTraceNode$Describer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StackTraceNode$Describer$Type<T> = ($StackTraceNode$Describer<(T)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StackTraceNode$Describer_<T> = $StackTraceNode$Describer$Type<(T)>;
}}
declare module "packages/me/lucko/spark/api/statistic/types/$DoubleStatistic" {
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Statistic, $Statistic$Type} from "packages/me/lucko/spark/api/statistic/$Statistic"
import {$StatisticWindow, $StatisticWindow$Type} from "packages/me/lucko/spark/api/statistic/$StatisticWindow"

export interface $DoubleStatistic<W extends ($Enum<(W)>) & ($StatisticWindow)> extends $Statistic<(W)> {

 "poll"(arg0: W): double
 "poll"(): (double)[]
 "name"(): string
 "getWindows"(): (W)[]
}

export namespace $DoubleStatistic {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleStatistic$Type<W> = ($DoubleStatistic<(W)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleStatistic_<W> = $DoubleStatistic$Type<(W)>;
}}
declare module "packages/me/lucko/spark/lib/asm/$ByteVector" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ByteVector {

constructor(arg0: integer)
constructor()

public "putByte"(arg0: integer): $ByteVector
public "putShort"(arg0: integer): $ByteVector
public "putInt"(arg0: integer): $ByteVector
public "putLong"(arg0: long): $ByteVector
public "putByteArray"(arg0: (byte)[], arg1: integer, arg2: integer): $ByteVector
public "putUTF8"(arg0: string): $ByteVector
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteVector$Type = ($ByteVector);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteVector_ = $ByteVector$Type;
}}
declare module "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider" {
import {$ByteBuddyAgent$AttachmentProvider$Accessor, $ByteBuddyAgent$AttachmentProvider$Accessor$Type} from "packages/me/lucko/spark/lib/bytebuddy/agent/$ByteBuddyAgent$AttachmentProvider$Accessor"

export interface $ByteBuddyAgent$AttachmentProvider {

 "attempt"(): $ByteBuddyAgent$AttachmentProvider$Accessor

(): $ByteBuddyAgent$AttachmentProvider$Accessor
}

export namespace $ByteBuddyAgent$AttachmentProvider {
const DEFAULT: $ByteBuddyAgent$AttachmentProvider
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBuddyAgent$AttachmentProvider$Type = ($ByteBuddyAgent$AttachmentProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBuddyAgent$AttachmentProvider_ = $ByteBuddyAgent$AttachmentProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponentImpl" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$TranslatableComponent, $TranslatableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$AbstractComponent, $AbstractComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$AbstractComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"

export class $TranslatableComponentImpl extends $AbstractComponent implements $TranslatableComponent {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "args"(args: $List$Type<(any)>): $TranslatableComponent
public "args"(...args: ($ComponentLike$Type)[]): $TranslatableComponent
public "args"(): $List<($Component)>
public "key"(): string
public "key"(key: string): $TranslatableComponent
public "toBuilder"(): $TranslatableComponent$Builder
public "key"(translatable: $Translatable$Type): $TranslatableComponent
public "examinableProperties"(): $Stream<(any)>
public "append"(component: $Component$Type): $TranslatableComponent
public "append"(like: $ComponentLike$Type): $TranslatableComponent
public "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TranslatableComponent
public "color"(color: $TextColor$Type): $TranslatableComponent
public "style"(style: $Consumer$Type<($Style$Builder$Type)>): $TranslatableComponent
public "style"(style: $Style$Builder$Type): $TranslatableComponent
public "mergeStyle"(that: $Component$Type): $TranslatableComponent
public "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TranslatableComponent
public "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TranslatableComponent
public "colorIfAbsent"(color: $TextColor$Type): $TranslatableComponent
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TranslatableComponent
public "clickEvent"(event: $ClickEvent$Type): $TranslatableComponent
public "hoverEvent"(event: $HoverEventSource$Type<(any)>): $TranslatableComponent
public static "join"(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
public static "join"(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
/**
 * 
 * @deprecated
 */
public static "join"(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
public static "empty"(): $TextComponent
public static "text"(content: string, style: $Style$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type): $TextComponent
public static "text"(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: boolean): $TextComponent
public static "text"(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(): $TextComponent$Builder
public static "text"(value: double, color: $TextColor$Type): $TextComponent
public static "text"(consumer: $Consumer$Type<(any)>): $TextComponent
public static "text"(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(content: string): $TextComponent
public static "text"(value: character, style: $Style$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type): $TextComponent
public static "text"(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: double): $TextComponent
public static "text"(value: double, style: $Style$Type): $TextComponent
public static "text"(value: boolean, style: $Style$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: character): $TextComponent
public static "text"(value: long, style: $Style$Type): $TextComponent
public static "text"(value: long): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
public static "text"(value: long, color: $TextColor$Type): $TextComponent
public static "text"(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
public static "text"(value: float, color: $TextColor$Type): $TextComponent
public static "text"(value: float, style: $Style$Type): $TextComponent
public static "text"(value: float): $TextComponent
public static "text"(value: integer, style: $Style$Type): $TextComponent
public static "text"(value: integer): $TextComponent
public static "text"(value: integer, color: $TextColor$Type): $TextComponent
public static "space"(): $TextComponent
public static "selector"(pattern: string): $SelectorComponent
public static "selector"(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
public static "selector"(consumer: $Consumer$Type<(any)>): $SelectorComponent
public static "selector"(): $SelectorComponent$Builder
public static "blockNBT"(): $BlockNBTComponent$Builder
public static "blockNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
public static "blockNBT"(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
public static "textOfChildren"(...components: ($ComponentLike$Type)[]): $TextComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
public static "storageNBT"(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
public static "storageNBT"(): $StorageNBTComponent$Builder
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
public static "keybind"(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
public static "keybind"(keybind: string): $KeybindComponent
public static "keybind"(): $KeybindComponent$Builder
public static "keybind"(consumer: $Consumer$Type<(any)>): $KeybindComponent
public static "keybind"(keybind: string, style: $Style$Type): $KeybindComponent
public static "keybind"(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
public static "newline"(): $TextComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(): $TranslatableComponent$Builder
public static "translatable"(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
public static "translatable"(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
public static "translatable"(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
/**
 * 
 * @deprecated
 */
public static "score"(name: string, objective: string, value: string): $ScoreComponent
public static "score"(consumer: $Consumer$Type<(any)>): $ScoreComponent
public static "score"(name: string, objective: string): $ScoreComponent
public static "score"(): $ScoreComponent$Builder
public static "entityNBT"(nbtPath: string, selector: string): $EntityNBTComponent
public static "entityNBT"(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
public static "entityNBT"(): $EntityNBTComponent$Builder
public static "toComponent"(): $Collector<($Component), (any), ($Component)>
public static "toComponent"(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $TranslatableComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $TranslatableComponent
public static "unbox"(like: $ComponentLike$Type): $Component
public static "asComponents"(likes: $List$Type<(any)>): $List<($Component)>
public static "asComponents"(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
public static "unbox"<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslatableComponentImpl$Type = ($TranslatableComponentImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslatableComponentImpl_ = $TranslatableComponentImpl$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$TypeOrBuilder" {
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Field, $Field$Type} from "packages/me/lucko/spark/lib/protobuf/$Field"
import {$SourceContext, $SourceContext$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext"
import {$Syntax, $Syntax$Type} from "packages/me/lucko/spark/lib/protobuf/$Syntax"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$Option, $Option$Type} from "packages/me/lucko/spark/lib/protobuf/$Option"

export interface $TypeOrBuilder extends $MessageLiteOrBuilder {

 "getFieldsCount"(): integer
 "getOneofsList"(): $List<(string)>
 "getOneofsBytes"(arg0: integer): $ByteString
 "getOneofs"(arg0: integer): string
 "getFieldsList"(): $List<($Field)>
 "getOneofsCount"(): integer
 "getName"(): string
 "getFields"(arg0: integer): $Field
 "getSyntax"(): $Syntax
 "getOptions"(arg0: integer): $Option
 "getNameBytes"(): $ByteString
 "getSourceContext"(): $SourceContext
 "getOptionsList"(): $List<($Option)>
 "getOptionsCount"(): integer
 "hasSourceContext"(): boolean
 "getSyntaxValue"(): integer
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $TypeOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TypeOrBuilder$Type = ($TypeOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TypeOrBuilder_ = $TypeOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapperOrBuilder" {
import {$SparkWebSocketProtos$ClientPing, $SparkWebSocketProtos$ClientPing$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientPing"
import {$SparkWebSocketProtos$ServerUpdateSamplerData, $SparkWebSocketProtos$ServerUpdateSamplerData$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateSamplerData"
import {$MessageLiteOrBuilder, $MessageLiteOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLiteOrBuilder"
import {$SparkWebSocketProtos$ServerConnectResponse, $SparkWebSocketProtos$ServerConnectResponse$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerConnectResponse"
import {$SparkWebSocketProtos$ServerUpdateStatistics, $SparkWebSocketProtos$ServerUpdateStatistics$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics"
import {$SparkWebSocketProtos$ServerPong, $SparkWebSocketProtos$ServerPong$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerPong"
import {$SparkWebSocketProtos$PacketWrapper$PacketCase, $SparkWebSocketProtos$PacketWrapper$PacketCase$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$PacketWrapper$PacketCase"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$SparkWebSocketProtos$ClientConnect, $SparkWebSocketProtos$ClientConnect$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ClientConnect"

export interface $SparkWebSocketProtos$PacketWrapperOrBuilder extends $MessageLiteOrBuilder {

 "getPacketCase"(): $SparkWebSocketProtos$PacketWrapper$PacketCase
 "getClientPing"(): $SparkWebSocketProtos$ClientPing
 "getClientConnect"(): $SparkWebSocketProtos$ClientConnect
 "hasServerPong"(): boolean
 "getServerPong"(): $SparkWebSocketProtos$ServerPong
 "hasClientPing"(): boolean
 "hasClientConnect"(): boolean
 "getServerConnectResponse"(): $SparkWebSocketProtos$ServerConnectResponse
 "getServerUpdateStatistics"(): $SparkWebSocketProtos$ServerUpdateStatistics
 "hasServerConnectResponse"(): boolean
 "hasServerUpdateStatistics"(): boolean
 "hasServerUpdateSampler"(): boolean
 "getServerUpdateSampler"(): $SparkWebSocketProtos$ServerUpdateSamplerData
 "getDefaultInstanceForType"(): $MessageLite
 "isInitialized"(): boolean
}

export namespace $SparkWebSocketProtos$PacketWrapperOrBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$PacketWrapperOrBuilder$Type = ($SparkWebSocketProtos$PacketWrapperOrBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$PacketWrapperOrBuilder_ = $SparkWebSocketProtos$PacketWrapperOrBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketAdapter" {
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$WebSocketListener, $WebSocketListener$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocketListener"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$ServerHandshake, $ServerHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshake"
import {$WebSocket, $WebSocket$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/$WebSocket"
import {$Draft, $Draft$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/drafts/$Draft"
import {$Framedata, $Framedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$Framedata"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$ServerHandshakeBuilder, $ServerHandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ServerHandshakeBuilder"
import {$PingFrame, $PingFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$PingFrame"
import {$Exception, $Exception$Type} from "packages/java/lang/$Exception"
import {$InetSocketAddress, $InetSocketAddress$Type} from "packages/java/net/$InetSocketAddress"

export class $WebSocketAdapter implements $WebSocketListener {

constructor()

public "onWebsocketHandshakeReceivedAsServer"(arg0: $WebSocket$Type, arg1: $Draft$Type, arg2: $ClientHandshake$Type): $ServerHandshakeBuilder
public "onWebsocketHandshakeReceivedAsClient"(arg0: $WebSocket$Type, arg1: $ClientHandshake$Type, arg2: $ServerHandshake$Type): void
public "onWebsocketHandshakeSentAsClient"(arg0: $WebSocket$Type, arg1: $ClientHandshake$Type): void
public "onWebsocketPing"(arg0: $WebSocket$Type, arg1: $Framedata$Type): void
public "onWebsocketPong"(arg0: $WebSocket$Type, arg1: $Framedata$Type): void
public "onPreparePing"(arg0: $WebSocket$Type): $PingFrame
public "getRemoteSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "getLocalSocketAddress"(arg0: $WebSocket$Type): $InetSocketAddress
public "onWebsocketCloseInitiated"(arg0: $WebSocket$Type, arg1: integer, arg2: string): void
public "onWebsocketClose"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
public "onWebsocketError"(arg0: $WebSocket$Type, arg1: $Exception$Type): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: $ByteBuffer$Type): void
public "onWebsocketMessage"(arg0: $WebSocket$Type, arg1: string): void
public "onWriteDemand"(arg0: $WebSocket$Type): void
public "onWebsocketOpen"(arg0: $WebSocket$Type, arg1: $Handshakedata$Type): void
public "onWebsocketClosing"(arg0: $WebSocket$Type, arg1: integer, arg2: string, arg3: boolean): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $WebSocketAdapter$Type = ($WebSocketAdapter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $WebSocketAdapter_ = $WebSocketAdapter$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$Internal$BooleanList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $Internal$BooleanList extends $Internal$ProtobufList<(boolean)> {

 "getBoolean"(arg0: integer): boolean
 "setBoolean"(arg0: integer, arg1: boolean): boolean
 "mutableCopyWithCapacity"(arg0: integer): $Internal$BooleanList
 "addBoolean"(arg0: boolean): void
 "makeImmutable"(): void
 "isModifiable"(): boolean
 "add"(arg0: integer, arg1: boolean): void
 "add"(arg0: boolean): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): boolean
 "get"(arg0: integer): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(boolean)>): void
 "size"(): integer
 "subList"(arg0: integer, arg1: integer): $List<(boolean)>
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "iterator"(): $Iterator<(boolean)>
 "contains"(arg0: any): boolean
 "spliterator"(): $Spliterator<(boolean)>
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: boolean): boolean
 "sort"(arg0: $Comparator$Type<(any)>): void
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "listIterator"(arg0: integer): $ListIterator<(boolean)>
 "listIterator"(): $ListIterator<(boolean)>
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(boolean)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(boolean)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Internal$BooleanList {
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean): $List<(boolean)>
function of<E>(arg0: boolean): $List<(boolean)>
function of<E>(): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean, arg9: boolean): $List<(boolean)>
function of<E>(arg0: boolean, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: boolean, arg7: boolean, arg8: boolean): $List<(boolean)>
function of<E>(...arg0: (boolean)[]): $List<(boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Internal$BooleanList$Type = ($Internal$BooleanList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Internal$BooleanList_ = $Internal$BooleanList$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration" {
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Index, $Index$Type} from "packages/me/lucko/spark/lib/adventure/util/$Index"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$Enum, $Enum$Type} from "packages/java/lang/$Enum"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$TriState, $TriState$Type} from "packages/me/lucko/spark/lib/adventure/util/$TriState"
import {$TextDecorationAndState, $TextDecorationAndState$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecorationAndState"
import {$TextFormat, $TextFormat$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextFormat"

export class $TextDecoration extends $Enum<($TextDecoration)> implements $StyleBuilderApplicable, $TextFormat {
static readonly "OBFUSCATED": $TextDecoration
static readonly "BOLD": $TextDecoration
static readonly "STRIKETHROUGH": $TextDecoration
static readonly "UNDERLINED": $TextDecoration
static readonly "ITALIC": $TextDecoration
static readonly "NAMES": $Index<(string), ($TextDecoration)>


public "toString"(): string
public static "values"(): ($TextDecoration)[]
public static "valueOf"(name: string): $TextDecoration
/**
 * 
 * @deprecated
 */
public "as"(state: boolean): $TextDecorationAndState
/**
 * 
 * @deprecated
 */
public "as"(state: $TextDecoration$State$Type): $TextDecorationAndState
public "styleApply"(style: $Style$Builder$Type): void
public "withState"(state: $TriState$Type): $TextDecorationAndState
public "withState"(state: boolean): $TextDecorationAndState
public "withState"(state: $TextDecoration$State$Type): $TextDecorationAndState
public "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextDecoration$Type = (("underlined") | ("bold") | ("strikethrough") | ("obfuscated") | ("italic")) | ($TextDecoration);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextDecoration_ = $TextDecoration$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake" {
import {$Handshakedata, $Handshakedata$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$Handshakedata"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ClientHandshake extends $Handshakedata {

 "getResourceDescriptor"(): string
 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $ClientHandshake {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientHandshake$Type = ($ClientHandshake);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientHandshake_ = $ClientHandshake$Type;
}}
declare module "packages/me/lucko/spark/api/statistic/$StatisticWindow" {
import {$Duration, $Duration$Type} from "packages/java/time/$Duration"

export interface $StatisticWindow {

 "length"(): $Duration

(): $Duration
}

export namespace $StatisticWindow {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StatisticWindow$Type = ($StatisticWindow);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StatisticWindow_ = $StatisticWindow$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$MessageInfoFactory" {
import {$Class, $Class$Type} from "packages/java/lang/$Class"
import {$MessageInfo, $MessageInfo$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageInfo"

export interface $MessageInfoFactory {

 "isSupported"(arg0: $Class$Type<(any)>): boolean
 "messageInfoFor"(arg0: $Class$Type<(any)>): $MessageInfo
}

export namespace $MessageInfoFactory {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $MessageInfoFactory$Type = ($MessageInfoFactory);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $MessageInfoFactory_ = $MessageInfoFactory$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent" {
import {$HoverEventSource, $HoverEventSource$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEventSource"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$KeybindComponent$Builder, $KeybindComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$Builder"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$ComponentIteratorType, $ComponentIteratorType$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorType"
import {$StorageNBTComponent, $StorageNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$KeybindComponent, $KeybindComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent"
import {$List, $List$Type} from "packages/java/util/$List"
import {$IntFunction2, $IntFunction2$Type} from "packages/me/lucko/spark/lib/adventure/util/$IntFunction2"
import {$TextReplacementConfig$Builder, $TextReplacementConfig$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig$Builder"
import {$BiPredicate, $BiPredicate$Type} from "packages/java/util/function/$BiPredicate"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$SelectorComponent$Builder, $SelectorComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent$Builder"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$JoinConfiguration, $JoinConfiguration$Type} from "packages/me/lucko/spark/lib/adventure/text/$JoinConfiguration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$ScoreComponent, $ScoreComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Translatable, $Translatable$Type} from "packages/me/lucko/spark/lib/adventure/translation/$Translatable"
import {$TranslatableComponent$Builder, $TranslatableComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TranslatableComponent$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$BlockNBTComponent$Builder, $BlockNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Builder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$BlockNBTComponent$Pos, $BlockNBTComponent$Pos$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent$Pos"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Pattern, $Pattern$Type} from "packages/java/util/regex/$Pattern"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$ComponentIteratorFlag, $ComponentIteratorFlag$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentIteratorFlag"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$BlockNBTComponent, $BlockNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BlockNBTComponent"
import {$ScoreComponent$Builder, $ScoreComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScoreComponent$Builder"
import {$EntityNBTComponent$Builder, $EntityNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent$Builder"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$SelectorComponent, $SelectorComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$SelectorComponent"
import {$PatternReplacementResult, $PatternReplacementResult$Type} from "packages/me/lucko/spark/lib/adventure/text/$PatternReplacementResult"
import {$TextReplacementConfig, $TextReplacementConfig$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextReplacementConfig"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$TextComponent$Builder, $TextComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent$Builder"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$TextComponent, $TextComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$TextComponent"
import {$EntityNBTComponent, $EntityNBTComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$EntityNBTComponent"
import {$ScopedComponent, $ScopedComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$ScopedComponent"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$StorageNBTComponent$Builder, $StorageNBTComponent$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/$StorageNBTComponent$Builder"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"
import {$KeybindComponent$KeybindLike, $KeybindComponent$KeybindLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$KeybindComponent$KeybindLike"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $TranslatableComponent extends $BuildableComponent<($TranslatableComponent), ($TranslatableComponent$Builder)>, $ScopedComponent<($TranslatableComponent)> {

 "args"(...args: ($ComponentLike$Type)[]): $TranslatableComponent
 "args"(args: $List$Type<(any)>): $TranslatableComponent
 "args"(): $List<($Component)>
 "key"(): string
 "key"(key: string): $TranslatableComponent
 "key"(translatable: $Translatable$Type): $TranslatableComponent
 "examinableProperties"(): $Stream<(any)>
 "toBuilder"(): $TranslatableComponent$Builder
 "append"(component: $Component$Type): $TranslatableComponent
 "append"(like: $ComponentLike$Type): $TranslatableComponent
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): $TranslatableComponent
 "color"(color: $TextColor$Type): $TranslatableComponent
 "style"(style: $Style$Type): $TranslatableComponent
 "style"(style: $Consumer$Type<($Style$Builder$Type)>): $TranslatableComponent
 "style"(style: $Style$Builder$Type): $TranslatableComponent
 "children"(children: $List$Type<(any)>): $TranslatableComponent
 "mergeStyle"(that: $Component$Type): $TranslatableComponent
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): $TranslatableComponent
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): $TranslatableComponent
 "colorIfAbsent"(color: $TextColor$Type): $TranslatableComponent
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): $TranslatableComponent
 "clickEvent"(event: $ClickEvent$Type): $TranslatableComponent
 "hoverEvent"(event: $HoverEventSource$Type<(any)>): $TranslatableComponent
 "iterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterator<($Component)>
 "iterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterator<($Component)>
 "contains"(that: $Component$Type): boolean
 "contains"(that: $Component$Type, equals: $BiPredicate$Type<(any), (any)>): boolean
 "spliterator"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Spliterator<($Component)>
 "spliterator"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Spliterator<($Component)>
 "color"(): $TextColor
 "compact"(): $Component
 "style"(): $Style
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Component
 "children"(): $List<($Component)>
 "appendNewline"(): $Component
/**
 * 
 * @deprecated
 */
 "detectCycle"(that: $Component$Type): void
 "applyFallbackStyle"(style: $Style$Type): $Component
 "applyFallbackStyle"(...style: ($StyleBuilderApplicable$Type)[]): $Component
 "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Component
 "hasStyling"(): boolean
 "replaceText"(configurer: $Consumer$Type<($TextReplacementConfig$Builder$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(search: string, replacement: $ComponentLike$Type, numberOfReplacements: integer): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "replaceText"(config: $TextReplacementConfig$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>, fn: $IntFunction2$Type<($PatternReplacementResult$Type)>): $Component
 "asHoverEvent"(op: $UnaryOperator$Type<($Component$Type)>): $HoverEvent<($Component)>
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(search: string, replacement: $ComponentLike$Type): $Component
/**
 * 
 * @deprecated
 */
 "replaceFirstText"(pattern: $Pattern$Type, replacement: $Function$Type<($TextComponent$Builder$Type), ($ComponentLike$Type)>): $Component
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
 "hasDecoration"(decoration: $TextDecoration$Type): boolean
 "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Component
 "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
 "font"(): $Key
 "appendSpace"(): $Component
 "iterable"(type: $ComponentIteratorType$Type, ...flags: ($ComponentIteratorFlag$Type)[]): $Iterable<($Component)>
 "iterable"(type: $ComponentIteratorType$Type, flags: $Set$Type<($ComponentIteratorFlag$Type)>): $Iterable<($Component)>
 "insertion"(): string
 "clickEvent"(): $ClickEvent
 "hoverEvent"(): $HoverEvent<(any)>
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "asHoverEvent"(): $HoverEvent<($Component)>
 "decorate"(...decorations: ($TextDecoration$Type)[]): $Component
 "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Component
}

export namespace $TranslatableComponent {
function configureAndBuild<R, B>(builder: $TranslatableComponent$Builder$Type, consumer: $Consumer$Type<(any)>): $TranslatableComponent
function join(config: $JoinConfiguration$Type, components: $Iterable$Type<(any)>): $Component
function join(config: $JoinConfiguration$Type, ...components: ($ComponentLike$Type)[]): $Component
function join(separator: $ComponentLike$Type, components: $Iterable$Type<(any)>): $TextComponent
function join(separator: $ComponentLike$Type, ...components: ($ComponentLike$Type)[]): $TextComponent
function empty(): $TextComponent
function text(content: string, style: $Style$Type): $TextComponent
function text(content: string, color: $TextColor$Type): $TextComponent
function text(content: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(content: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: boolean): $TextComponent
function text(value: double, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(): $TextComponent$Builder
function text(value: double, color: $TextColor$Type): $TextComponent
function text(consumer: $Consumer$Type<(any)>): $TextComponent
function text(value: double, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(content: string): $TextComponent
function text(value: character, style: $Style$Type): $TextComponent
function text(value: character, color: $TextColor$Type): $TextComponent
function text(value: character, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: character, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: double): $TextComponent
function text(value: double, style: $Style$Type): $TextComponent
function text(value: boolean, style: $Style$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type): $TextComponent
function text(value: boolean, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: boolean, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: character): $TextComponent
function text(value: long, style: $Style$Type): $TextComponent
function text(value: long): $TextComponent
function text(value: integer, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: integer, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: float, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: long, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TextComponent
function text(value: long, color: $TextColor$Type): $TextComponent
function text(value: float, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TextComponent
function text(value: float, color: $TextColor$Type): $TextComponent
function text(value: float, style: $Style$Type): $TextComponent
function text(value: float): $TextComponent
function text(value: integer, style: $Style$Type): $TextComponent
function text(value: integer): $TextComponent
function text(value: integer, color: $TextColor$Type): $TextComponent
function space(): $TextComponent
function selector(pattern: string): $SelectorComponent
function selector(pattern: string, separator: $ComponentLike$Type): $SelectorComponent
function selector(consumer: $Consumer$Type<(any)>): $SelectorComponent
function selector(): $SelectorComponent$Builder
function blockNBT(): $BlockNBTComponent$Builder
function blockNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, interpret: boolean, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(nbtPath: string, pos: $BlockNBTComponent$Pos$Type): $BlockNBTComponent
function blockNBT(consumer: $Consumer$Type<(any)>): $BlockNBTComponent
function textOfChildren(...components: ($ComponentLike$Type)[]): $TextComponent
function storageNBT(nbtPath: string, interpret: boolean, separator: $ComponentLike$Type, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, interpret: boolean, storage: $Key$Type): $StorageNBTComponent
function storageNBT(nbtPath: string, storage: $Key$Type): $StorageNBTComponent
function storageNBT(consumer: $Consumer$Type<(any)>): $StorageNBTComponent
function storageNBT(): $StorageNBTComponent$Builder
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, style: $Style$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $KeybindComponent
function keybind(keybind: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $KeybindComponent
function keybind(keybind: string): $KeybindComponent
function keybind(): $KeybindComponent$Builder
function keybind(consumer: $Consumer$Type<(any)>): $KeybindComponent
function keybind(keybind: string, style: $Style$Type): $KeybindComponent
function keybind(keybind: $KeybindComponent$KeybindLike$Type): $KeybindComponent
function newline(): $TextComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, style: $Style$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(): $TranslatableComponent$Builder
function translatable(translatable: $Translatable$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type): $TranslatableComponent
function translatable(key: string, style: $Style$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(consumer: $Consumer$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $TranslatableComponent
function translatable(translatable: $Translatable$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(key: string, style: $Style$Type, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function translatable(key: string, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, args: $List$Type<(any)>): $TranslatableComponent
function translatable(translatable: $Translatable$Type, color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>, ...args: ($ComponentLike$Type)[]): $TranslatableComponent
function score(name: string, objective: string, value: string): $ScoreComponent
function score(consumer: $Consumer$Type<(any)>): $ScoreComponent
function score(name: string, objective: string): $ScoreComponent
function score(): $ScoreComponent$Builder
function entityNBT(nbtPath: string, selector: string): $EntityNBTComponent
function entityNBT(consumer: $Consumer$Type<(any)>): $EntityNBTComponent
function entityNBT(): $EntityNBTComponent$Builder
function toComponent(): $Collector<($Component), (any), ($Component)>
function toComponent(separator: $Component$Type): $Collector<($Component), (any), ($Component)>
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
function unbox<V>(source: $HoverEventSource$Type<($Component$Type)>): $HoverEvent<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TranslatableComponent$Type = ($TranslatableComponent);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TranslatableComponent_ = $TranslatableComponent$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite$Builder" {
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$MessageLite, $MessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite"
import {$MessageLite$Builder, $MessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$MessageLite$Builder"
import {$AbstractMessageLite, $AbstractMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractMessageLite"

export class $AbstractMessageLite$Builder<MessageType extends $AbstractMessageLite<(MessageType), (BuilderType)>, BuilderType extends $AbstractMessageLite$Builder<(MessageType), (BuilderType)>> implements $MessageLite$Builder {

constructor()

public "clone"(): BuilderType
public "mergeDelimitedFrom"(arg0: $InputStream$Type): boolean
public "mergeDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): boolean
public "mergeFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): BuilderType
public "mergeFrom"(arg0: $MessageLite$Type): BuilderType
public "clear"(): $MessageLite$Builder
public "build"(): $MessageLite
public "buildPartial"(): $MessageLite
public "getDefaultInstanceForType"(): $MessageLite
public "isInitialized"(): boolean
get "defaultInstanceForType"(): $MessageLite
get "initialized"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractMessageLite$Builder$Type<MessageType, BuilderType> = ($AbstractMessageLite$Builder<(MessageType), (BuilderType)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractMessageLite$Builder_<MessageType, BuilderType> = $AbstractMessageLite$Builder$Type<(MessageType), (BuilderType)>;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics" {
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"
import {$SparkProtos$WorldStatistics$WorldOrBuilder, $SparkProtos$WorldStatistics$WorldOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$WorldOrBuilder"
import {$SparkProtos$WorldStatisticsOrBuilder, $SparkProtos$WorldStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatisticsOrBuilder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$SparkProtos$WorldStatistics$Builder, $SparkProtos$WorldStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$Builder"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$SparkProtos$WorldStatistics$World, $SparkProtos$WorldStatistics$World$Type} from "packages/me/lucko/spark/proto/$SparkProtos$WorldStatistics$World"

export class $SparkProtos$WorldStatistics extends $GeneratedMessageLite<($SparkProtos$WorldStatistics), ($SparkProtos$WorldStatistics$Builder)> implements $SparkProtos$WorldStatisticsOrBuilder {
static readonly "TOTAL_ENTITIES_FIELD_NUMBER": integer
static readonly "ENTITY_COUNTS_FIELD_NUMBER": integer
static readonly "WORLDS_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$WorldStatistics)>
public static "newBuilder"(arg0: $SparkProtos$WorldStatistics$Type): $SparkProtos$WorldStatistics$Builder
public static "newBuilder"(): $SparkProtos$WorldStatistics$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics
public static "getDefaultInstance"(): $SparkProtos$WorldStatistics
public "containsEntityCounts"(arg0: string): boolean
public "getEntityCountsOrDefault"(arg0: string, arg1: integer): integer
public "getWorldsOrBuilderList"(): $List<(any)>
public "getEntityCountsCount"(): integer
public "getEntityCountsOrThrow"(arg0: string): integer
/**
 * 
 * @deprecated
 */
public "getEntityCounts"(): $Map<(string), (integer)>
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$WorldStatistics
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$WorldStatistics
public "getWorldsCount"(): integer
public "getWorldsList"(): $List<($SparkProtos$WorldStatistics$World)>
public "getEntityCountsMap"(): $Map<(string), (integer)>
public "getWorldsOrBuilder"(arg0: integer): $SparkProtos$WorldStatistics$WorldOrBuilder
public "getWorlds"(arg0: integer): $SparkProtos$WorldStatistics$World
public "getTotalEntities"(): integer
get "defaultInstance"(): $SparkProtos$WorldStatistics
get "worldsOrBuilderList"(): $List<(any)>
get "entityCountsCount"(): integer
get "entityCounts"(): $Map<(string), (integer)>
get "worldsCount"(): integer
get "worldsList"(): $List<($SparkProtos$WorldStatistics$World)>
get "entityCountsMap"(): $Map<(string), (integer)>
get "totalEntities"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$WorldStatistics$Type = ($SparkProtos$WorldStatistics);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$WorldStatistics_ = $SparkProtos$WorldStatistics$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ByteBufferWriter" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ByteBufferWriter {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ByteBufferWriter$Type = ($ByteBufferWriter);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ByteBufferWriter_ = $ByteBufferWriter$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder" {
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$MutableStyleSetter, $MutableStyleSetter$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$MutableStyleSetter"
import {$ComponentLike, $ComponentLike$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentLike"
import {$BuildableComponent, $BuildableComponent$Type} from "packages/me/lucko/spark/lib/adventure/text/$BuildableComponent"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$AbstractBuilder, $AbstractBuilder$Type} from "packages/me/lucko/spark/lib/adventure/builder/$AbstractBuilder"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Component, $Component$Type} from "packages/me/lucko/spark/lib/adventure/text/$Component"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$List, $List$Type} from "packages/java/util/$List"
import {$ComponentBuilderApplicable, $ComponentBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilderApplicable"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"

export interface $ComponentBuilder<C extends $BuildableComponent<(C), (B)>, B extends $ComponentBuilder<(C), (B)>> extends $AbstractBuilder<(C)>, $Buildable$Builder<(C)>, $ComponentBuilderApplicable, $ComponentLike, $MutableStyleSetter<(B)> {

 "append"(components: $Iterable$Type<(any)>): B
 "append"(...components: ($ComponentLike$Type)[]): B
 "append"(...components: ($Component$Type)[]): B
 "append"(component: $Component$Type): B
 "append"(component: $ComponentLike$Type): B
 "append"(builder: $ComponentBuilder$Type<(any), (any)>): B
 "apply"(consumer: $Consumer$Type<(any)>): B
 "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): B
 "style"(style: $Style$Type): B
 "children"(): $List<($Component)>
 "appendNewline"(): B
 "mergeStyle"(that: $Component$Type): B
 "mergeStyle"(that: $Component$Type, ...merges: ($Style$Merge$Type)[]): B
 "mergeStyle"(that: $Component$Type, merges: $Set$Type<($Style$Merge$Type)>): B
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
 "mapChildrenDeep"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
 "applyDeep"(action: $Consumer$Type<(any)>): B
 "mapChildren"(arg0: $Function$Type<($BuildableComponent$Type<(any), (any)>), (any)>): B
 "resetStyle"(): B
 "applicableApply"(applicable: $ComponentBuilderApplicable$Type): B
 "asComponent"(): $Component
 "decoration"(decoration: $TextDecoration$Type, flag: boolean): B
 "decorate"(decoration: $TextDecoration$Type): B
 "font"(font: $Key$Type): B
 "appendSpace"(): B
 "insertion"(insertion: string): B
 "clickEvent"(event: $ClickEvent$Type): B
}

export namespace $ComponentBuilder {
function configureAndBuild<R, B>(builder: B, consumer: $Consumer$Type<(any)>): C
function unbox(like: $ComponentLike$Type): $Component
function asComponents(likes: $List$Type<(any)>): $List<($Component)>
function asComponents(likes: $List$Type<(any)>, filter: $Predicate$Type<(any)>): $List<($Component)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ComponentBuilder$Type<C, B> = ($ComponentBuilder<(C), (B)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ComponentBuilder_<C, B> = $ComponentBuilder$Type<(C), (B)>;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/exceptions/$IncompleteHandshakeException" {
import {$RuntimeException, $RuntimeException$Type} from "packages/java/lang/$RuntimeException"

export class $IncompleteHandshakeException extends $RuntimeException {

constructor(arg0: integer)
constructor()

public "getPreferredSize"(): integer
get "preferredSize"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IncompleteHandshakeException$Type = ($IncompleteHandshakeException);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IncompleteHandshakeException_ = $IncompleteHandshakeException$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$StyleImpl" {
import {$Style$Merge$Strategy, $Style$Merge$Strategy$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge$Strategy"
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$Key, $Key$Type} from "packages/me/lucko/spark/lib/adventure/key/$Key"
import {$Buildable$Builder, $Buildable$Builder$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable$Builder"
import {$Style, $Style$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$HoverEvent, $HoverEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$HoverEvent"
import {$TextColor, $TextColor$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextColor"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$Style$Merge, $Style$Merge$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Merge"
import {$Buildable, $Buildable$Type} from "packages/me/lucko/spark/lib/adventure/util/$Buildable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ClickEvent, $ClickEvent$Type} from "packages/me/lucko/spark/lib/adventure/text/event/$ClickEvent"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $StyleImpl implements $Style {


public "equals"(other: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style
public "color"(): $TextColor
public "color"(color: $TextColor$Type): $Style
public "colorIfAbsent"(color: $TextColor$Type): $Style
public "decorationIfAbsent"(decoration: $TextDecoration$Type, state: $TextDecoration$State$Type): $Style
public "examinableProperties"(): $Stream<(any)>
public "unmerge"(that: $Style$Type): $Style
public "decoration"(decoration: $TextDecoration$Type): $TextDecoration$State
public "decorations"(decorations: $Map$Type<($TextDecoration$Type), ($TextDecoration$State$Type)>): $Style
public "decorations"(): $Map<($TextDecoration), ($TextDecoration$State)>
public "font"(): $Key
public "toBuilder"(): $Style$Builder
public "insertion"(insertion: string): $Style
public "insertion"(): string
public "clickEvent"(): $ClickEvent
public "hoverEvent"(): $HoverEvent<(any)>
public "merge"(that: $Style$Type, merge: $Style$Merge$Type): $Style
public "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, merge: $Style$Merge$Type): $Style
public "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type): $Style
public "merge"(that: $Style$Type): $Style
public "merge"(that: $Style$Type, merges: $Set$Type<($Style$Merge$Type)>): $Style
public "merge"(that: $Style$Type, strategy: $Style$Merge$Strategy$Type, ...merges: ($Style$Merge$Type)[]): $Style
public "merge"(that: $Style$Type, ...merges: ($Style$Merge$Type)[]): $Style
public static "empty"(): $Style
public static "style"(color: $TextColor$Type, ...decorations: ($TextDecoration$Type)[]): $Style
public static "style"(...applicables: ($StyleBuilderApplicable$Type)[]): $Style
public static "style"(applicables: $Iterable$Type<(any)>): $Style
public static "style"(color: $TextColor$Type, decorations: $Set$Type<($TextDecoration$Type)>): $Style
public static "style"(): $Style$Builder
public static "style"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Style
public static "style"(color: $TextColor$Type): $Style
public static "style"(decoration: $TextDecoration$Type): $Style
public "edit"(consumer: $Consumer$Type<($Style$Builder$Type)>, strategy: $Style$Merge$Strategy$Type): $Style
public "edit"(consumer: $Consumer$Type<($Style$Builder$Type)>): $Style
public "decoration"(decoration: $TextDecoration$Type, flag: boolean): $Style
public "decorate"(decoration: $TextDecoration$Type): $Style
public "hasDecoration"(decoration: $TextDecoration$Type): boolean
/**
 * 
 * @deprecated
 */
public static "configureAndBuild"<R extends $Buildable<(R), (B)>, B extends $Buildable$Builder<(R)>>(builder: $Style$Builder$Type, consumer: $Consumer$Type<(any)>): $Style
public "examinableName"(): string
public "examine"<R>(examiner: $Examiner$Type<(R)>): R
public "decorate"(...decorations: ($TextDecoration$Type)[]): $Style
public "decorations"(decorations: $Set$Type<($TextDecoration$Type)>, flag: boolean): $Style
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $StyleImpl$Type = ($StyleImpl);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $StyleImpl_ = $StyleImpl$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool" {
import {$SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder, $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder, $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SparkProtos$PlatformStatistics$Memory$MemoryPool extends $GeneratedMessageLite<($SparkProtos$PlatformStatistics$Memory$MemoryPool), ($SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder)> implements $SparkProtos$PlatformStatistics$Memory$MemoryPoolOrBuilder {
static readonly "USED_FIELD_NUMBER": integer
static readonly "TOTAL_FIELD_NUMBER": integer


public static "parser"(): $Parser<($SparkProtos$PlatformStatistics$Memory$MemoryPool)>
public static "newBuilder"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
public static "newBuilder"(arg0: $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "getDefaultInstance"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public "getTotal"(): long
public "getUsed"(): long
public static "parseFrom"(arg0: $ByteBuffer$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $CodedInputStream$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $InputStream$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: (byte)[]): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
public static "parseFrom"(arg0: $ByteString$Type): $SparkProtos$PlatformStatistics$Memory$MemoryPool
get "defaultInstance"(): $SparkProtos$PlatformStatistics$Memory$MemoryPool
get "total"(): long
get "used"(): long
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type = ($SparkProtos$PlatformStatistics$Memory$MemoryPool);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProtos$PlatformStatistics$Memory$MemoryPool_ = $SparkProtos$PlatformStatistics$Memory$MemoryPool$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$SourceContext" {
import {$SourceContext$Builder, $SourceContext$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContext$Builder"
import {$SourceContextOrBuilder, $SourceContextOrBuilder$Type} from "packages/me/lucko/spark/lib/protobuf/$SourceContextOrBuilder"
import {$GeneratedMessageLite, $GeneratedMessageLite$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite"
import {$Parser, $Parser$Type} from "packages/me/lucko/spark/lib/protobuf/$Parser"
import {$CodedInputStream, $CodedInputStream$Type} from "packages/me/lucko/spark/lib/protobuf/$CodedInputStream"
import {$InputStream, $InputStream$Type} from "packages/java/io/$InputStream"
import {$ExtensionRegistryLite, $ExtensionRegistryLite$Type} from "packages/me/lucko/spark/lib/protobuf/$ExtensionRegistryLite"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $SourceContext extends $GeneratedMessageLite<($SourceContext), ($SourceContext$Builder)> implements $SourceContextOrBuilder {
static readonly "FILE_NAME_FIELD_NUMBER": integer


public "getFileName"(): string
public static "parser"(): $Parser<($SourceContext)>
public static "newBuilder"(): $SourceContext$Builder
public static "newBuilder"(arg0: $SourceContext$Type): $SourceContext$Builder
public static "parseDelimitedFrom"(arg0: $InputStream$Type): $SourceContext
public static "parseDelimitedFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "getDefaultInstance"(): $SourceContext
public static "parseFrom"(arg0: $CodedInputStream$Type, arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "parseFrom"(arg0: $ByteBuffer$Type, arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "parseFrom"(arg0: $ByteBuffer$Type): $SourceContext
public static "parseFrom"(arg0: $InputStream$Type, arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "parseFrom"(arg0: (byte)[]): $SourceContext
public static "parseFrom"(arg0: (byte)[], arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "parseFrom"(arg0: $InputStream$Type): $SourceContext
public static "parseFrom"(arg0: $ByteString$Type, arg1: $ExtensionRegistryLite$Type): $SourceContext
public static "parseFrom"(arg0: $ByteString$Type): $SourceContext
public static "parseFrom"(arg0: $CodedInputStream$Type): $SourceContext
public "getFileNameBytes"(): $ByteString
get "fileName"(): string
get "defaultInstance"(): $SourceContext
get "fileNameBytes"(): $ByteString
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SourceContext$Type = ($SourceContext);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SourceContext_ = $SourceContext$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ProtobufLists" {
import {$Internal$ProtobufList, $Internal$ProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$ProtobufList"
import {$Internal$LongList, $Internal$LongList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$LongList"
import {$Internal$FloatList, $Internal$FloatList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$FloatList"
import {$Internal$BooleanList, $Internal$BooleanList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$BooleanList"
import {$Internal$IntList, $Internal$IntList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$IntList"
import {$Internal$DoubleList, $Internal$DoubleList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$DoubleList"

export class $ProtobufLists {


public static "mutableCopy"<E>(arg0: $Internal$ProtobufList$Type<(E)>): $Internal$ProtobufList<(E)>
public static "emptyDoubleList"(): $Internal$DoubleList
public static "emptyIntList"(): $Internal$IntList
public static "emptyBooleanList"(): $Internal$BooleanList
public static "emptyLongList"(): $Internal$LongList
public static "emptyFloatList"(): $Internal$FloatList
public static "emptyProtobufList"<E>(): $Internal$ProtobufList<(E)>
public static "newDoubleList"(): $Internal$DoubleList
public static "newBooleanList"(): $Internal$BooleanList
public static "newIntList"(): $Internal$IntList
public static "newFloatList"(): $Internal$FloatList
public static "newLongList"(): $Internal$LongList
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ProtobufLists$Type = ($ProtobufLists);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ProtobufLists_ = $ProtobufLists$Type;
}}
declare module "packages/me/lucko/spark/lib/adventure/text/format/$TextDecorationAndState" {
import {$TextDecoration$State, $TextDecoration$State$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration$State"
import {$ComponentBuilder, $ComponentBuilder$Type} from "packages/me/lucko/spark/lib/adventure/text/$ComponentBuilder"
import {$StyleBuilderApplicable, $StyleBuilderApplicable$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$StyleBuilderApplicable"
import {$TextDecoration, $TextDecoration$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$TextDecoration"
import {$Style$Builder, $Style$Builder$Type} from "packages/me/lucko/spark/lib/adventure/text/format/$Style$Builder"
import {$Examiner, $Examiner$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examiner"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$Examinable, $Examinable$Type} from "packages/me/lucko/spark/lib/adventure/examination/$Examinable"

export interface $TextDecorationAndState extends $Examinable, $StyleBuilderApplicable {

 "state"(): $TextDecoration$State
 "styleApply"(style: $Style$Builder$Type): void
 "examinableProperties"(): $Stream<(any)>
 "decoration"(): $TextDecoration
 "examinableName"(): string
 "examine"<R>(examiner: $Examiner$Type<(R)>): R
 "componentBuilderApply"(component: $ComponentBuilder$Type<(any), (any)>): void
}

export namespace $TextDecorationAndState {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $TextDecorationAndState$Type = ($TextDecorationAndState);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $TextDecorationAndState_ = $TextDecorationAndState$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$UnsafeByteOperations" {
import {$ByteOutput, $ByteOutput$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteOutput"
import {$ByteString, $ByteString$Type} from "packages/me/lucko/spark/lib/protobuf/$ByteString"
import {$ByteBuffer, $ByteBuffer$Type} from "packages/java/nio/$ByteBuffer"

export class $UnsafeByteOperations {


public static "unsafeWrap"(arg0: $ByteBuffer$Type): $ByteString
public static "unsafeWrap"(arg0: (byte)[], arg1: integer, arg2: integer): $ByteString
public static "unsafeWrap"(arg0: (byte)[]): $ByteString
public static "unsafeWriteTo"(arg0: $ByteString$Type, arg1: $ByteOutput$Type): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $UnsafeByteOperations$Type = ($UnsafeByteOperations);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $UnsafeByteOperations_ = $UnsafeByteOperations$Type;
}}
declare module "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics$Builder" {
import {$GeneratedMessageLite$Builder, $GeneratedMessageLite$Builder$Type} from "packages/me/lucko/spark/lib/protobuf/$GeneratedMessageLite$Builder"
import {$SparkProtos$SystemStatistics, $SparkProtos$SystemStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics"
import {$SparkProtos$SystemStatistics$Builder, $SparkProtos$SystemStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$SystemStatistics$Builder"
import {$SparkWebSocketProtos$ServerUpdateStatistics, $SparkWebSocketProtos$ServerUpdateStatistics$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatistics"
import {$SparkProtos$PlatformStatistics$Builder, $SparkProtos$PlatformStatistics$Builder$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics$Builder"
import {$SparkProtos$PlatformStatistics, $SparkProtos$PlatformStatistics$Type} from "packages/me/lucko/spark/proto/$SparkProtos$PlatformStatistics"
import {$SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder, $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder$Type} from "packages/me/lucko/spark/proto/$SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder"

export class $SparkWebSocketProtos$ServerUpdateStatistics$Builder extends $GeneratedMessageLite$Builder<($SparkWebSocketProtos$ServerUpdateStatistics), ($SparkWebSocketProtos$ServerUpdateStatistics$Builder)> implements $SparkWebSocketProtos$ServerUpdateStatisticsOrBuilder {


public "getPlatform"(): $SparkProtos$PlatformStatistics
public "hasPlatform"(): boolean
public "hasSystem"(): boolean
public "setSystem"(arg0: $SparkProtos$SystemStatistics$Builder$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "setSystem"(arg0: $SparkProtos$SystemStatistics$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "setPlatform"(arg0: $SparkProtos$PlatformStatistics$Builder$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "setPlatform"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "mergePlatform"(arg0: $SparkProtos$PlatformStatistics$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "mergeSystem"(arg0: $SparkProtos$SystemStatistics$Type): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "clearPlatform"(): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "clearSystem"(): $SparkWebSocketProtos$ServerUpdateStatistics$Builder
public "getSystem"(): $SparkProtos$SystemStatistics
get "platform"(): $SparkProtos$PlatformStatistics
set "system"(value: $SparkProtos$SystemStatistics$Builder$Type)
set "system"(value: $SparkProtos$SystemStatistics$Type)
set "platform"(value: $SparkProtos$PlatformStatistics$Builder$Type)
set "platform"(value: $SparkProtos$PlatformStatistics$Type)
get "system"(): $SparkProtos$SystemStatistics
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type = ($SparkWebSocketProtos$ServerUpdateStatistics$Builder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkWebSocketProtos$ServerUpdateStatistics$Builder_ = $SparkWebSocketProtos$ServerUpdateStatistics$Builder$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$DoubleArrayList" {
import {$AbstractProtobufList, $AbstractProtobufList$Type} from "packages/me/lucko/spark/lib/protobuf/$AbstractProtobufList"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$PrimitiveNonBoxingCollection, $PrimitiveNonBoxingCollection$Type} from "packages/me/lucko/spark/lib/protobuf/$PrimitiveNonBoxingCollection"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Internal$DoubleList, $Internal$DoubleList$Type} from "packages/me/lucko/spark/lib/protobuf/$Internal$DoubleList"

export class $DoubleArrayList extends $AbstractProtobufList<(double)> implements $Internal$DoubleList, $RandomAccess, $PrimitiveNonBoxingCollection {


public "add"(arg0: double): boolean
public "add"(arg0: integer, arg1: double): void
public "remove"(arg0: integer): double
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "indexOf"(arg0: any): integer
public "getDouble"(arg0: integer): double
public "size"(): integer
public "contains"(arg0: any): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: double): double
public static "emptyList"(): $DoubleArrayList
public "setDouble"(arg0: integer, arg1: double): double
public "addDouble"(arg0: double): void
public "mutableCopyWithCapacity"(arg0: integer): $Internal$DoubleList
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(double)>
public "isEmpty"(): boolean
public "toArray"(): (any)[]
public "toArray"<T>(arg0: (T)[]): (T)[]
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double): $List<(double)>
public static "of"<E>(arg0: double): $List<(double)>
public static "of"<E>(): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
public static "of"<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
public static "of"<E>(...arg0: (double)[]): $List<(double)>
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleArrayList$Type = ($DoubleArrayList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleArrayList_ = $DoubleArrayList$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshakeBuilder" {
import {$HandshakeBuilder, $HandshakeBuilder$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$HandshakeBuilder"
import {$ClientHandshake, $ClientHandshake$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/handshake/$ClientHandshake"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ClientHandshakeBuilder extends $HandshakeBuilder, $ClientHandshake {

 "setResourceDescriptor"(arg0: string): void
 "put"(arg0: string, arg1: string): void
 "setContent"(arg0: (byte)[]): void
 "getResourceDescriptor"(): string
 "getContent"(): (byte)[]
 "getFieldValue"(arg0: string): string
 "iterateHttpFields"(): $Iterator<(string)>
 "hasFieldValue"(arg0: string): boolean
}

export namespace $ClientHandshakeBuilder {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ClientHandshakeBuilder$Type = ($ClientHandshakeBuilder);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ClientHandshakeBuilder_ = $ClientHandshakeBuilder$Type;
}}
declare module "packages/me/lucko/spark/lib/bytesocks/ws/framing/$ContinuousFrame" {
import {$DataFrame, $DataFrame$Type} from "packages/me/lucko/spark/lib/bytesocks/ws/framing/$DataFrame"

export class $ContinuousFrame extends $DataFrame {

constructor()

}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ContinuousFrame$Type = ($ContinuousFrame);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ContinuousFrame_ = $ContinuousFrame$Type;
}}
declare module "packages/me/lucko/spark/api/$SparkProvider" {
import {$Spark, $Spark$Type} from "packages/me/lucko/spark/api/$Spark"

export class $SparkProvider {


public static "get"(): $Spark
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $SparkProvider$Type = ($SparkProvider);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $SparkProvider_ = $SparkProvider$Type;
}}
declare module "packages/me/lucko/spark/lib/protobuf/$ExtensionSchemas" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export class $ExtensionSchemas {


}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ExtensionSchemas$Type = ($ExtensionSchemas);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ExtensionSchemas_ = $ExtensionSchemas$Type;
}}
